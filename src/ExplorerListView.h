//////////////////////////////////////////////////////////////////////
/// \class ExplorerListView
/// \author Timo "TimoSoft" Kunze
/// \brief <em>Superclasses \c SysListView32</em>
///
/// This class superclasses \c SysListView32 and makes it accessible by COM.
///
/// \todo Remove cachedSettings::hSmallImageList?
/// \todo Move the OLE drag'n'drop flags into their own struct?
/// \todo Separate \c MouseStatus for the listview and the contained edit control.
/// \todo \c IMEFlags is the name of a struct as well as a variable.
/// \todo Verify documentation of \c PreTranslateAccelerator.
/// \todo Verify comctl32 requirements for \c OnListGetEmptyTextNotification and \c put_EmptyMarkupText.
/// \todo Improve documentation of the \c HotItem property.
///
/// \if UNICODE
///   \sa ExLVwLibU::IExplorerListView
/// \else
///   \sa ExLVwLibA::IExplorerListView
/// \endif
//////////////////////////////////////////////////////////////////////


#pragma once

#include "CompilerFlags.h"
#include "res/resource.h"
#ifdef UNICODE
	#include "ExLVwU.h"
#else
	#include "ExLVwA.h"
#endif
#include "UndocComctl32.h"
#include "SubItemControls.h"
#include "_IExplorerListViewEvents_CP.h"
#include "ICategorizeProperties.h"
#include "ICreditsProvider.h"
#include "IGroupComparator.h"
#include "IItemComparator.h"
#include "IListViewFooter.h"
#include "IDrawPropertyControl.h"
#include "IPropertyControl.h"
#include "IPropertyValueImpl.h"
#include "IListView.h"
#include "helpers.h"
#include "HashFunctions.h"
#include "EnumOLEVERB.h"
#include "PropertyNotifySinkImpl.h"
#ifdef INCLUDESUBITEMCALLBACKCODE
	#include "DefaultDrawPropertyControl.h"
	#include "DefaultPropertyControl.h"
#endif
#include "AboutDlg.h"
#include "CommonProperties.h"
#include "StringProperties.h"
#include "ListViewColumn.h"
#include "ListViewColumns.h"
#include "VirtualListViewColumn.h"
#include "ListViewFooterItem.h"
#include "ListViewFooterItems.h"
#include "ListViewGroup.h"
#include "ListViewGroups.h"
#include "VirtualListViewGroup.h"
#include "ListViewItem.h"
#include "ListViewItems.h"
#include "ListViewItemContainer.h"
#include "VirtualListViewItem.h"
#include "ListViewSubItem.h"
#include "ListViewSubItems.h"
#include "ListViewWorkArea.h"
#include "ListViewWorkAreas.h"
#include "VirtualListViewWorkArea.h"
#include "VirtualListViewWorkAreas.h"
#include "TargetOLEDataObject.h"
#include "SourceOLEDataObject.h"

#ifdef INCLUDESHELLBROWSERINTERFACE
	#include "shbrowser/definitions.h"
	#include "shbrowser/IMessageListener.h"
	#include "shbrowser/IInternalMessageListener.h"
#endif


class ATL_NO_VTABLE ExplorerListView : 
    public CComObjectRootEx<CComSingleThreadModel>,
    #ifdef UNICODE
    	public IDispatchImpl<IExplorerListView, &IID_IExplorerListView, &LIBID_ExLVwLibU, /*wMajor =*/ VERSION_MAJOR, /*wMinor =*/ VERSION_MINOR>,
    #else
    	public IDispatchImpl<IExplorerListView, &IID_IExplorerListView, &LIBID_ExLVwLibA, /*wMajor =*/ VERSION_MAJOR, /*wMinor =*/ VERSION_MINOR>,
    #endif
    public IPersistStreamInitImpl<ExplorerListView>,
    public IOleControlImpl<ExplorerListView>,
    public IOleObjectImpl<ExplorerListView>,
    public IOleInPlaceActiveObjectImpl<ExplorerListView>,
    public IViewObjectExImpl<ExplorerListView>,
    public IOleInPlaceObjectWindowlessImpl<ExplorerListView>,
    public ISupportErrorInfo,
    public IConnectionPointContainerImpl<ExplorerListView>,
    public Proxy_IExplorerListViewEvents<ExplorerListView>,
    public IPersistStorageImpl<ExplorerListView>,
    public IPersistPropertyBagImpl<ExplorerListView>,
    public ISpecifyPropertyPages,
    public IQuickActivateImpl<ExplorerListView>,
    #ifdef UNICODE
    	public IProvideClassInfo2Impl<&CLSID_ExplorerListView, &__uuidof(_IExplorerListViewEvents), &LIBID_ExLVwLibU, /*wMajor =*/ VERSION_MAJOR, /*wMinor =*/ VERSION_MINOR>,
    #else
    	public IProvideClassInfo2Impl<&CLSID_ExplorerListView, &__uuidof(_IExplorerListViewEvents), &LIBID_ExLVwLibA, /*wMajor =*/ VERSION_MAJOR, /*wMinor =*/ VERSION_MINOR>,
    #endif
    public IPropertyNotifySinkCP<ExplorerListView>,
    public CComCoClass<ExplorerListView, &CLSID_ExplorerListView>,
    public CComControl<ExplorerListView>,
    public IPerPropertyBrowsingImpl<ExplorerListView>,
    public IDropTarget,
    public IDropSource,
    public IDropSourceNotify,
    #ifdef INCLUDESHELLBROWSERINTERFACE
    	public IInternalMessageListener,
    #endif
    public ICategorizeProperties,
    public ICreditsProvider,
    public IGroupComparator,
    public IItemComparator,
    public IListViewFooterCallback,
   	public IOwnerDataCallback,
   	public ISubItemCallback
{
	friend class ListViewColumn;
	friend class VirtualListViewColumn;
	friend class ListViewColumns;
	friend class ListViewItem;
	friend class ListViewItems;
	friend class ListViewItemContainer;
	friend class VirtualListViewItem;
	friend class ListViewSubItem;
	friend class ListViewSubItems;
	friend class ListViewFooterItem;
	friend class ListViewFooterItems;
	friend class ListViewGroup;
	friend class ListViewGroups;
	friend class SourceOLEDataObject;

public:
	/// \brief <em>The contained edit control</em>
	CContainedWindow containedEdit;
	/// \brief <em>The contained header control</em>
	CContainedWindow containedSysHeader32;

	/// \brief <em>The constructor of this class</em>
	///
	/// Used for initialization.
	ExplorerListView();

	#ifndef DOXYGEN_SHOULD_SKIP_THIS
		DECLARE_OLEMISC_STATUS(OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_ALIGNABLE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT | OLEMISC_RECOMPOSEONRESIZE | OLEMISC_SETCLIENTSITEFIRST)
		DECLARE_REGISTRY_RESOURCEID(IDR_EXPLORERLISTVIEW)

		#ifdef UNICODE
			DECLARE_WND_SUPERCLASS(TEXT("ExplorerListViewU"), WC_LISTVIEWW)
		#else
			DECLARE_WND_SUPERCLASS(TEXT("ExplorerListViewA"), WC_LISTVIEWA)
		#endif

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		// we have a solid background and draw the entire rectangle
		DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

		BEGIN_COM_MAP(ExplorerListView)
			COM_INTERFACE_ENTRY(IExplorerListView)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(IViewObjectEx)
			COM_INTERFACE_ENTRY(IViewObject2)
			COM_INTERFACE_ENTRY(IViewObject)
			COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
			COM_INTERFACE_ENTRY(IOleInPlaceObject)
			COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
			COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
			COM_INTERFACE_ENTRY(IOleControl)
			COM_INTERFACE_ENTRY(IOleObject)
			COM_INTERFACE_ENTRY(IPersistStreamInit)
			COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY(IConnectionPointContainer)
			COM_INTERFACE_ENTRY(IPersistPropertyBag)
			COM_INTERFACE_ENTRY(IQuickActivate)
			COM_INTERFACE_ENTRY(IPersistStorage)
			COM_INTERFACE_ENTRY(IProvideClassInfo)
			COM_INTERFACE_ENTRY(IProvideClassInfo2)
			COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
			COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
			COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
			COM_INTERFACE_ENTRY(IDropTarget)
			COM_INTERFACE_ENTRY(IDropSource)
			COM_INTERFACE_ENTRY(IDropSourceNotify)
			COM_INTERFACE_ENTRY_IID(IID_IListViewFooterCallback, IListViewFooterCallback)
			COM_INTERFACE_ENTRY_IID(IID_IOwnerDataCallback, IOwnerDataCallback)
			COM_INTERFACE_ENTRY_IID(IID_ISubItemCallback, ISubItemCallback)
		END_COM_MAP()

		BEGIN_PROP_MAP(ExplorerListView)
			// NOTE: Don't forget to update Load and Save! This is for property bags only, not for streams!
			PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
			PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
			PROP_ENTRY_TYPE("AbsoluteBkImagePosition", DISPID_EXLVW_ABSOLUTEBKIMAGEPOSITION, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("AllowHeaderDragDrop", DISPID_EXLVW_ALLOWHEADERDRAGDROP, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("AllowLabelEditing", DISPID_EXLVW_ALLOWLABELEDITING, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("AlwaysShowSelection", DISPID_EXLVW_ALWAYSSHOWSELECTION, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("Appearance", DISPID_EXLVW_APPEARANCE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("AutoArrangeItems", DISPID_EXLVW_AUTOARRANGEITEMS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("AutoSizeColumns", DISPID_EXLVW_AUTOSIZECOLUMNS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("BackColor", DISPID_EXLVW_BACKCOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("BackgroundDrawMode", DISPID_EXLVW_BACKGROUNDDRAWMODE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("BkImagePositionX", DISPID_EXLVW_BKIMAGEPOSITIONX, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("BkImagePositionY", DISPID_EXLVW_BKIMAGEPOSITIONY, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("BkImageStyle", DISPID_EXLVW_BKIMAGESTYLE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("BlendSelectionLasso", DISPID_EXLVW_BLENDSELECTIONLASSO, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("BorderSelect", DISPID_EXLVW_BORDERSELECT, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("BorderStyle", DISPID_EXLVW_BORDERSTYLE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("CallBackMask", DISPID_EXLVW_CALLBACKMASK, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("CheckItemOnSelect", DISPID_EXLVW_CHECKITEMONSELECT, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ClickableColumnHeaders", DISPID_EXLVW_CLICKABLECOLUMNHEADERS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ColumnHeaderVisibility", DISPID_EXLVW_COLUMNHEADERVISIBILITY, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("DisabledEvents", DISPID_EXLVW_DISABLEDEVENTS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("DontRedraw", DISPID_EXLVW_DONTREDRAW, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("DragScrollTimeBase", DISPID_EXLVW_DRAGSCROLLTIMEBASE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("DrawImagesAsynchronously", DISPID_EXLVW_DRAWIMAGESASYNCHRONOUSLY, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("EditBackColor", DISPID_EXLVW_EDITBACKCOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("EditForeColor", DISPID_EXLVW_EDITFORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("EditHoverTime", DISPID_EXLVW_EDITHOVERTIME, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("EditIMEMode", DISPID_EXLVW_EDITIMEMODE, CLSID_NULL, VT_I4)
			//PROP_ENTRY_TYPE("EmptyMarkupText", DISPID_EXLVW_EMPTYMARKUPTEXT, CLSID_StringProperties, VT_BSTR)
			PROP_ENTRY_TYPE("EmptyMarkupTextAlignment", DISPID_EXLVW_EMPTYMARKUPTEXTALIGNMENT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("Enabled", DISPID_EXLVW_ENABLED, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("FilterChangedTimeout", DISPID_EXLVW_FILTERCHANGEDTIMEOUT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("Font", DISPID_EXLVW_FONT, CLSID_StockFontPage, VT_DISPATCH)
			//PROP_ENTRY_TYPE("FooterIntroText", DISPID_EXLVW_FOOTERINTROTEXT, CLSID_StringProperties, VT_BSTR)
			PROP_ENTRY_TYPE("ForeColor", DISPID_EXLVW_FORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("FullRowSelect", DISPID_EXLVW_FULLROWSELECT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("GridLines", DISPID_EXLVW_GRIDLINES, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("GroupFooterForeColor", DISPID_EXLVW_GROUPFOOTERFORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("GroupHeaderForeColor", DISPID_EXLVW_GROUPHEADERFORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("GroupMarginBottom", DISPID_EXLVW_GROUPMARGINBOTTOM, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("GroupMarginLeft", DISPID_EXLVW_GROUPMARGINLEFT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("GroupMarginRight", DISPID_EXLVW_GROUPMARGINRIGHT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("GroupMarginTop", DISPID_EXLVW_GROUPMARGINTOP, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("GroupSortOrder", DISPID_EXLVW_GROUPSORTORDER, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("HeaderFullDragging", DISPID_EXLVW_HEADERFULLDRAGGING, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("HeaderHotTracking", DISPID_EXLVW_HEADERHOTTRACKING, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("HeaderHoverTime", DISPID_EXLVW_HEADERHOVERTIME, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("HeaderOLEDragImageStyle", DISPID_EXLVW_HEADEROLEDRAGIMAGESTYLE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("HideLabels", DISPID_EXLVW_HIDELABELS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("HotForeColor", DISPID_EXLVW_HOTFORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("HotMouseIcon", DISPID_EXLVW_HOTMOUSEICON, CLSID_StockPicturePage, VT_DISPATCH)
			PROP_ENTRY_TYPE("HotMousePointer", DISPID_EXLVW_HOTMOUSEPOINTER, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("HotTracking", DISPID_EXLVW_HOTTRACKING, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("HotTrackingHoverTime", DISPID_EXLVW_HOTTRACKINGHOVERTIME, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("HoverTime", DISPID_EXLVW_HOVERTIME, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("IMEMode", DISPID_EXLVW_IMEMODE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("IncludeHeaderInTabOrder", DISPID_EXLVW_INCLUDEHEADERINTABORDER, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("InsertMarkColor", DISPID_EXLVW_INSERTMARKCOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("ItemActivationMode", DISPID_EXLVW_ITEMACTIVATIONMODE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("ItemAlignment", DISPID_EXLVW_ITEMALIGNMENT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("ItemBoundingBoxDefinition", DISPID_EXLVW_ITEMBOUNDINGBOXDEFINITION, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("ItemHeight", DISPID_EXLVW_ITEMHEIGHT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("JustifyIconColumns", DISPID_EXLVW_JUSTIFYICONCOLUMNS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("LabelWrap", DISPID_EXLVW_LABELWRAP, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("MinItemRowsVisibleInGroups", DISPID_EXLVW_MINITEMROWSVISIBLEINGROUPS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("MouseIcon", DISPID_EXLVW_MOUSEICON, CLSID_StockPicturePage, VT_DISPATCH)
			PROP_ENTRY_TYPE("MousePointer", DISPID_EXLVW_MOUSEPOINTER, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("MultiSelect", DISPID_EXLVW_MULTISELECT, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("OLEDragImageStyle", DISPID_EXLVW_OLEDRAGIMAGESTYLE, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("OutlineColor", DISPID_EXLVW_OUTLINECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("OwnerDrawn", DISPID_EXLVW_OWNERDRAWN, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ProcessContextMenuKeys", DISPID_EXLVW_PROCESSCONTEXTMENUKEYS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("Regional", DISPID_EXLVW_REGIONAL, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("RegisterForOLEDragDrop", DISPID_EXLVW_REGISTERFOROLEDRAGDROP, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ResizableColumns", DISPID_EXLVW_RESIZABLECOLUMNS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("RightToLeft", DISPID_EXLVW_RIGHTTOLEFT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("ScrollBars", DISPID_EXLVW_SCROLLBARS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("SelectedColumnBackColor", DISPID_EXLVW_SELECTEDCOLUMNBACKCOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("ShowFilterBar", DISPID_EXLVW_SHOWFILTERBAR, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ShowGroups", DISPID_EXLVW_SHOWGROUPS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ShowHeaderChevron", DISPID_EXLVW_SHOWHEADERCHEVRON, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ShowHeaderStateImages", DISPID_EXLVW_SHOWHEADERSTATEIMAGES, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ShowStateImages", DISPID_EXLVW_SHOWSTATEIMAGES, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("ShowSubItemImages", DISPID_EXLVW_SHOWSUBITEMIMAGES, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("SimpleSelect", DISPID_EXLVW_SIMPLESELECT, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("SingleRow", DISPID_EXLVW_SINGLEROW, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("SnapToGrid", DISPID_EXLVW_SNAPTOGRID, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("SortOrder", DISPID_EXLVW_SORTORDER, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("SupportOLEDragImages", DISPID_EXLVW_SUPPORTOLEDRAGIMAGES, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("TextBackColor", DISPID_EXLVW_TEXTBACKCOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("TileViewItemLines", DISPID_EXLVW_TILEVIEWITEMLINES, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewLabelMarginBottom", DISPID_EXLVW_TILEVIEWLABELMARGINBOTTOM, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewLabelMarginLeft", DISPID_EXLVW_TILEVIEWLABELMARGINLEFT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewLabelMarginRight", DISPID_EXLVW_TILEVIEWLABELMARGINRIGHT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewLabelMarginTop", DISPID_EXLVW_TILEVIEWLABELMARGINTOP, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewSubItemForeColor", DISPID_EXLVW_TILEVIEWSUBITEMFORECOLOR, CLSID_StockColorPage, VT_I4)
			PROP_ENTRY_TYPE("TileViewTileHeight", DISPID_EXLVW_TILEVIEWTILEHEIGHT, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("TileViewTileWidth", DISPID_EXLVW_TILEVIEWTILEWIDTH, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("ToolTips", DISPID_EXLVW_TOOLTIPS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("UnderlinedItems", DISPID_EXLVW_UNDERLINEDITEMS, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("UseMinColumnWidths", DISPID_EXLVW_USEMINCOLUMNWIDTHS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("UseSystemFont", DISPID_EXLVW_USESYSTEMFONT, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("UseWorkAreas", DISPID_EXLVW_USEWORKAREAS, CLSID_NULL, VT_BOOL)
			PROP_ENTRY_TYPE("View", DISPID_EXLVW_VIEW, CLSID_NULL, VT_I4)
			PROP_ENTRY_TYPE("VirtualMode", DISPID_EXLVW_VIRTUALMODE, CLSID_NULL, VT_BOOL)
		END_PROP_MAP()

		BEGIN_CONNECTION_POINT_MAP(ExplorerListView)
			CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
			CONNECTION_POINT_ENTRY(__uuidof(_IExplorerListViewEvents))
		END_CONNECTION_POINT_MAP()

		#ifdef INCLUDESHELLBROWSERINTERFACE
			BEGIN_FILTERED_MSG_MAP(ExplorerListView, shellBrowserInterface.pMessageListener)
				FILTERED_MESSAGE_HANDLER(WM_CHAR, OnChar)
				FILTERED_MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
				FILTERED_MESSAGE_HANDLER(WM_CREATE, OnCreate)
				FILTERED_MESSAGE_HANDLER(WM_CTLCOLOREDIT, OnCtlColorEdit)
				FILTERED_MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
				FILTERED_MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
				FILTERED_MESSAGE_HANDLER(WM_INPUTLANGCHANGE, OnInputLangChange)
				FILTERED_MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnMButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONUP, OnMButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHOVER, OnMouseHover)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
				FILTERED_MESSAGE_HANDLER(WM_PAINT, OnPaint)
				FILTERED_MESSAGE_HANDLER(WM_PARENTNOTIFY, OnParentNotify)
				FILTERED_MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
				FILTERED_MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
				FILTERED_MESSAGE_HANDLER(WM_SETFONT, OnSetFont)
				FILTERED_MESSAGE_HANDLER(WM_SETREDRAW, OnSetRedraw)
				FILTERED_MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYDOWN, OnKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYUP, OnKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_THEMECHANGED, OnThemeChanged)
				FILTERED_MESSAGE_HANDLER(WM_TIMER, OnTimer)
				FILTERED_MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnXButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDOWN, OnXButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONUP, OnXButtonUp)

				FILTERED_MESSAGE_HANDLER(OCM_DRAWITEM, OnReflectedDrawItem)
				FILTERED_MESSAGE_HANDLER(OCM_MEASUREITEM, OnReflectedMeasureItem)
				FILTERED_MESSAGE_HANDLER(OCM_NOTIFY, OnReflectedNotify)
				FILTERED_MESSAGE_HANDLER(OCM__BASE + WM_NOTIFYFORMAT, OnReflectedNotifyFormat)

				FILTERED_MESSAGE_HANDLER(SHBM_HANDSHAKE, OnHandshake)

				FILTERED_MESSAGE_HANDLER(GetDragImageMessage(), OnGetDragImage)

				FILTERED_MESSAGE_HANDLER(LVM_CREATEDRAGIMAGE, OnCreateDragImage)
				FILTERED_MESSAGE_HANDLER(LVM_DELETECOLUMN, OnDeleteColumn)
				FILTERED_MESSAGE_HANDLER(LVM_DELETEALLITEMS, OnDeleteAllItems)
				FILTERED_MESSAGE_HANDLER(LVM_DELETEITEM, OnDeleteItem)
				FILTERED_MESSAGE_HANDLER(LVM_FINDITEMA, OnFindItem)
				FILTERED_MESSAGE_HANDLER(LVM_FINDITEMW, OnFindItem)
				FILTERED_MESSAGE_HANDLER(LVM_GETITEMA, OnGetItem)
				FILTERED_MESSAGE_HANDLER(LVM_GETITEMW, OnGetItem)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTCOLUMNA, OnInsertColumn)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTCOLUMNW, OnInsertColumn)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTGROUP, OnInsertGroup)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTGROUPSORTED, OnInsertGroupSorted)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTITEMA, OnInsertItem)
				FILTERED_MESSAGE_HANDLER(LVM_INSERTITEMW, OnInsertItem)
				FILTERED_MESSAGE_HANDLER(LVM_REMOVEALLGROUPS, OnRemoveAllGroups)
				FILTERED_MESSAGE_HANDLER(LVM_REMOVEGROUP, OnRemoveGroup)
				FILTERED_MESSAGE_HANDLER(LVM_SETBKIMAGEA, OnSetBkImage)
				FILTERED_MESSAGE_HANDLER(LVM_SETBKIMAGEW, OnSetBkImage)
				FILTERED_MESSAGE_HANDLER(LVM_SETEXTENDEDLISTVIEWSTYLE, OnSetExtendedListViewStyle)
				FILTERED_MESSAGE_HANDLER(LVM_SETGROUPINFO, OnSetGroupInfo)
				FILTERED_MESSAGE_HANDLER(LVM_SETHOTCURSOR, OnSetHotCursor)
				FILTERED_MESSAGE_HANDLER(LVM_SETHOTITEM, OnSetHotItem)
				FILTERED_MESSAGE_HANDLER(LVM_SETIMAGELIST, OnSetImageList)
				FILTERED_MESSAGE_HANDLER(LVM_SETINFOTIP, OnSetInfoTip)
				FILTERED_MESSAGE_HANDLER(LVM_SETITEMA, OnSetItem)
				FILTERED_MESSAGE_HANDLER(LVM_SETITEMW, OnSetItem)
				FILTERED_MESSAGE_HANDLER(LVM_SETITEMCOUNT, OnSetItemCount)
				FILTERED_MESSAGE_HANDLER(LVM_SETVIEW, OnSetView)
				FILTERED_MESSAGE_HANDLER(LVM_SETWORKAREAS, OnSetWorkAreas)
				FILTERED_MESSAGE_HANDLER(LVM_SORTGROUPS, OnSortGroups)
				FILTERED_MESSAGE_HANDLER(LVM_SORTITEMS, OnSortItems)
				FILTERED_MESSAGE_HANDLER(LVM_SORTITEMSEX, OnSortItemsEx)

				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(NM_CLICK, OnClickNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDblClkNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(NM_RCLICK, OnRClickNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(NM_RDBLCLK, OnRDblClkNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(NM_SETFOCUS, OnSetFocusNotification)

				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ASYNCDRAWN, OnAsyncDrawnNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINDRAG, OnBeginDragNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINLABELEDITA, OnBeginLabelEditNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINLABELEDITW, OnBeginLabelEditNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINRDRAG, OnBeginRDragNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINSCROLL, OnBeginScrollNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNCLICK, OnColumnClickNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNDROPDOWN, OnColumnDropDownNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNOVERFLOWCLICK, OnColumnOverflowClickNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_DELETEALLITEMS, OnDeleteAllItemsNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItemNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDLABELEDITA, OnEndLabelEditNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDLABELEDITW, OnEndLabelEditNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDSCROLL, OnEndScrollNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETDISPINFOA, OnGetDispInfoNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETDISPINFOW, OnGetDispInfoNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYMARKUP, OnGetEmptyMarkupNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYTEXTA, OnGetEmptyTextNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYTEXTW, OnGetEmptyTextNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETINFOTIPA, OnGetInfoTipNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETINFOTIPW, OnGetInfoTipNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_GROUPINFO, OnGroupInfoNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_HOTTRACK, OnHotTrackNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_INCREMENTALSEARCHA, OnIncrementalSearchNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_INCREMENTALSEARCHW, OnIncrementalSearchNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, OnItemActivateNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChangedNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDownNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_LINKCLICK, OnLinkClickNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_MARQUEEBEGIN, OnMarqueeBeginNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODCACHEHINT, OnODCacheHintNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODFINDITEMA, OnODFindItemNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODFINDITEMW, OnODFindItemNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODSTATECHANGED, OnODStateChangedNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_SETDISPINFOA, OnSetDispInfoNotification)
				FILTERED_REFLECTED_NOTIFY_CODE_HANDLER(LVN_SETDISPINFOW, OnSetDispInfoNotification)

				/* NOTE: From comctl32.dll version 5.80 onwards, SysListView32 control forwards the header control's
				         notifications to its parent window. Maybe we should use REFLECTED_NOTIFY_CODE_HANDLER
				         instead NOTIFY_CODE_HANDLER someday. */
				FILTERED_NOTIFY_CODE_HANDLER(HDN_BEGINDRAG, OnHeaderBeginDragNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_BEGINTRACKA, OnHeaderBeginTrackNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_BEGINTRACKW, OnHeaderBeginTrackNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_DIVIDERDBLCLICKA, OnHeaderDividerDblClickNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_DIVIDERDBLCLICKW, OnHeaderDividerDblClickNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ENDDRAG, OnHeaderEndDragNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ENDTRACKA, OnHeaderEndTrackNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ENDTRACKW, OnHeaderEndTrackNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_FILTERBTNCLICK, OnHeaderFilterBtnClickNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_FILTERCHANGE, OnHeaderFilterChangeNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_GETDISPINFOA, OnHeaderGetDispInfoNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_GETDISPINFOW, OnHeaderGetDispInfoNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ITEMCHANGINGA, OnHeaderItemChangingNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ITEMCHANGINGW, OnHeaderItemChangingNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ITEMDBLCLICKA, OnHeaderItemDblClkNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ITEMDBLCLICKW, OnHeaderItemDblClkNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_ITEMSTATEICONCLICK, OnHeaderStateIconClickNotification)
				//FILTERED_NOTIFY_CODE_HANDLER(HDN_OVERFLOWCLICK, OnHeaderOverflowClickNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_TRACKA, OnHeaderTrackNotification)
				FILTERED_NOTIFY_CODE_HANDLER(HDN_TRACKW, OnHeaderTrackNotification)

				FILTERED_COMMAND_CODE_HANDLER(EN_CHANGE, OnEditChange)

				FILTERED_CHAIN_MSG_MAP(CComControl<ExplorerListView>)
				FILTERED_ALT_MSG_MAP(1)
				FILTERED_MESSAGE_HANDLER(WM_CHAR, OnEditChar)
				FILTERED_MESSAGE_HANDLER(WM_CONTEXTMENU, OnEditContextMenu)
				FILTERED_MESSAGE_HANDLER(WM_DESTROY, OnEditDestroy)
				FILTERED_MESSAGE_HANDLER(WM_KEYDOWN, OnEditKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_KEYUP, OnEditKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_KILLFOCUS, OnEditKillFocus)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnEditLButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDOWN, OnEditLButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONUP, OnEditLButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnEditMButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDOWN, OnEditMButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONUP, OnEditMButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHOVER, OnEditMouseHover)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnEditMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_MOUSELEAVE, OnEditMouseLeave)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEMOVE, OnEditMouseMove)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEWHEEL, OnEditMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnEditRButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONDOWN, OnEditRButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONUP, OnEditRButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_SETFOCUS, OnEditSetFocus)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYDOWN, OnEditKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYUP, OnEditKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnEditXButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDOWN, OnEditXButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONUP, OnEditXButtonUp)
				FILTERED_ALT_MSG_MAP(2)
				FILTERED_MESSAGE_HANDLER(WM_CHAR, OnHeaderChar)
				FILTERED_MESSAGE_HANDLER(WM_CONTEXTMENU, OnHeaderContextMenu)
				FILTERED_MESSAGE_HANDLER(WM_DESTROY, OnHeaderDestroy)
				FILTERED_MESSAGE_HANDLER(WM_KEYDOWN, OnHeaderKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_KEYUP, OnHeaderKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_KILLFOCUS, OnHeaderKillFocus)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnHeaderLButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONDOWN, OnHeaderLButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_LBUTTONUP, OnHeaderLButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnHeaderMButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONDOWN, OnHeaderMButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_MBUTTONUP, OnHeaderMButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHOVER, OnHeaderMouseHover)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnHeaderMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_MOUSELEAVE, OnHeaderMouseLeave)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEMOVE, OnHeaderMouseMove)
				FILTERED_MESSAGE_HANDLER(WM_MOUSEWHEEL, OnHeaderMouseWheel)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnHeaderRButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONDOWN, OnHeaderRButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_RBUTTONUP, OnHeaderRButtonUp)
				FILTERED_MESSAGE_HANDLER(WM_PARENTNOTIFY, OnParentNotify)
				FILTERED_MESSAGE_HANDLER(WM_SETFOCUS, OnHeaderSetFocus)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYDOWN, OnHeaderKeyDown)
				FILTERED_MESSAGE_HANDLER(WM_SYSKEYUP, OnHeaderKeyUp)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnHeaderXButtonDblClk)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONDOWN, OnHeaderXButtonDown)
				FILTERED_MESSAGE_HANDLER(WM_XBUTTONUP, OnHeaderXButtonUp)

				FILTERED_MESSAGE_HANDLER(GetDragImageMessage(), OnHeaderGetDragImage)

				FILTERED_MESSAGE_HANDLER(HDM_GETITEMA, OnHeaderGetItem)
				FILTERED_MESSAGE_HANDLER(HDM_GETITEMW, OnHeaderGetItem)
				FILTERED_MESSAGE_HANDLER(HDM_INSERTITEMA, OnHeaderInsertItem)
				FILTERED_MESSAGE_HANDLER(HDM_INSERTITEMW, OnHeaderInsertItem)
				FILTERED_MESSAGE_HANDLER(HDM_SETFILTERCHANGETIMEOUT, OnHeaderSetFilterChangeTimeout)
				FILTERED_MESSAGE_HANDLER(HDM_SETIMAGELIST, OnHeaderSetImageList)
				FILTERED_MESSAGE_HANDLER(HDM_SETITEMA, OnHeaderSetItem)
				FILTERED_MESSAGE_HANDLER(HDM_SETITEMW, OnHeaderSetItem)

				FILTERED_COMMAND_CODE_HANDLER(EN_CHANGE, OnEditChange)
			END_FILTERED_MSG_MAP(shellBrowserInterface.pMessageListener)
		#else
			BEGIN_MSG_MAP(ExplorerListView)
				MESSAGE_HANDLER(WM_CHAR, OnChar)
				MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
				MESSAGE_HANDLER(WM_CREATE, OnCreate)
				MESSAGE_HANDLER(WM_CTLCOLOREDIT, OnCtlColorEdit)
				MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
				MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
				MESSAGE_HANDLER(WM_INPUTLANGCHANGE, OnInputLangChange)
				MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
				MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
				MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnMButtonDblClk)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMButtonDown)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnMButtonUp)
				MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
				MESSAGE_HANDLER(WM_MOUSEHOVER, OnMouseHover)
				MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnMouseWheel)
				MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
				MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
				MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
				MESSAGE_HANDLER(WM_PAINT, OnPaint)
				MESSAGE_HANDLER(WM_PARENTNOTIFY, OnParentNotify)
				MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnRButtonDown)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
				MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
				MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
				MESSAGE_HANDLER(WM_SETFONT, OnSetFont)
				MESSAGE_HANDLER(WM_SETREDRAW, OnSetRedraw)
				MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
				MESSAGE_HANDLER(WM_SYSKEYDOWN, OnKeyDown)
				MESSAGE_HANDLER(WM_SYSKEYUP, OnKeyUp)
				MESSAGE_HANDLER(WM_THEMECHANGED, OnThemeChanged)
				MESSAGE_HANDLER(WM_TIMER, OnTimer)
				MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
				MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnXButtonDblClk)
				MESSAGE_HANDLER(WM_XBUTTONDOWN, OnXButtonDown)
				MESSAGE_HANDLER(WM_XBUTTONUP, OnXButtonUp)

				MESSAGE_HANDLER(OCM_DRAWITEM, OnReflectedDrawItem)
				MESSAGE_HANDLER(OCM_MEASUREITEM, OnReflectedMeasureItem)
				MESSAGE_HANDLER(OCM_NOTIFY, OnReflectedNotify)
				MESSAGE_HANDLER(OCM__BASE + WM_NOTIFYFORMAT, OnReflectedNotifyFormat)

				MESSAGE_HANDLER(GetDragImageMessage(), OnGetDragImage)

				MESSAGE_HANDLER(LVM_CREATEDRAGIMAGE, OnCreateDragImage)
				MESSAGE_HANDLER(LVM_DELETECOLUMN, OnDeleteColumn)
				MESSAGE_HANDLER(LVM_DELETEALLITEMS, OnDeleteAllItems)
				MESSAGE_HANDLER(LVM_DELETEITEM, OnDeleteItem)
				MESSAGE_HANDLER(LVM_FINDITEMA, OnFindItem)
				MESSAGE_HANDLER(LVM_FINDITEMW, OnFindItem)
				MESSAGE_HANDLER(LVM_GETITEMA, OnGetItem)
				MESSAGE_HANDLER(LVM_GETITEMW, OnGetItem)
				MESSAGE_HANDLER(LVM_INSERTCOLUMNA, OnInsertColumn)
				MESSAGE_HANDLER(LVM_INSERTCOLUMNW, OnInsertColumn)
				MESSAGE_HANDLER(LVM_INSERTGROUP, OnInsertGroup)
				MESSAGE_HANDLER(LVM_INSERTGROUPSORTED, OnInsertGroupSorted)
				MESSAGE_HANDLER(LVM_INSERTITEMA, OnInsertItem)
				MESSAGE_HANDLER(LVM_INSERTITEMW, OnInsertItem)
				MESSAGE_HANDLER(LVM_REMOVEALLGROUPS, OnRemoveAllGroups)
				MESSAGE_HANDLER(LVM_REMOVEGROUP, OnRemoveGroup)
				MESSAGE_HANDLER(LVM_SETBKIMAGEA, OnSetBkImage)
				MESSAGE_HANDLER(LVM_SETBKIMAGEW, OnSetBkImage)
				MESSAGE_HANDLER(LVM_SETEXTENDEDLISTVIEWSTYLE, OnSetExtendedListViewStyle)
				MESSAGE_HANDLER(LVM_SETGROUPINFO, OnSetGroupInfo)
				MESSAGE_HANDLER(LVM_SETHOTCURSOR, OnSetHotCursor)
				MESSAGE_HANDLER(LVM_SETHOTITEM, OnSetHotItem)
				MESSAGE_HANDLER(LVM_SETIMAGELIST, OnSetImageList)
				MESSAGE_HANDLER(LVM_SETINFOTIP, OnSetInfoTip)
				MESSAGE_HANDLER(LVM_SETITEMA, OnSetItem)
				MESSAGE_HANDLER(LVM_SETITEMW, OnSetItem)
				MESSAGE_HANDLER(LVM_SETITEMCOUNT, OnSetItemCount)
				MESSAGE_HANDLER(LVM_SETVIEW, OnSetView)
				MESSAGE_HANDLER(LVM_SETWORKAREAS, OnSetWorkAreas)
				MESSAGE_HANDLER(LVM_SORTGROUPS, OnSortGroups)
				MESSAGE_HANDLER(LVM_SORTITEMS, OnSortItems)
				MESSAGE_HANDLER(LVM_SORTITEMSEX, OnSortItemsEx)

				REFLECTED_NOTIFY_CODE_HANDLER(NM_CLICK, OnClickNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDblClkNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(NM_RCLICK, OnRClickNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(NM_RDBLCLK, OnRDblClkNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(NM_SETFOCUS, OnSetFocusNotification)

				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ASYNCDRAWN, OnAsyncDrawnNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINDRAG, OnBeginDragNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINLABELEDITA, OnBeginLabelEditNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINLABELEDITW, OnBeginLabelEditNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINRDRAG, OnBeginRDragNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_BEGINSCROLL, OnBeginScrollNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNCLICK, OnColumnClickNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNDROPDOWN, OnColumnDropDownNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_COLUMNOVERFLOWCLICK, OnColumnOverflowClickNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_DELETEALLITEMS, OnDeleteAllItemsNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItemNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDLABELEDITA, OnEndLabelEditNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDLABELEDITW, OnEndLabelEditNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ENDSCROLL, OnEndScrollNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETDISPINFOA, OnGetDispInfoNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETDISPINFOW, OnGetDispInfoNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYMARKUP, OnGetEmptyMarkupNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYTEXTA, OnGetEmptyTextNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETEMPTYTEXTW, OnGetEmptyTextNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETINFOTIPA, OnGetInfoTipNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GETINFOTIPW, OnGetInfoTipNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_GROUPINFO, OnGroupInfoNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_HOTTRACK, OnHotTrackNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_INCREMENTALSEARCHA, OnIncrementalSearchNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_INCREMENTALSEARCHW, OnIncrementalSearchNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, OnItemActivateNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChangedNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDownNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_LINKCLICK, OnLinkClickNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_MARQUEEBEGIN, OnMarqueeBeginNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODCACHEHINT, OnODCacheHintNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODFINDITEMA, OnODFindItemNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODFINDITEMW, OnODFindItemNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_ODSTATECHANGED, OnODStateChangedNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_SETDISPINFOA, OnSetDispInfoNotification)
				REFLECTED_NOTIFY_CODE_HANDLER(LVN_SETDISPINFOW, OnSetDispInfoNotification)

				/* NOTE: From comctl32.dll version 5.80 onwards, SysListView32 control forwards the header control's
				         notifications to its parent window. Maybe we should use REFLECTED_NOTIFY_CODE_HANDLER
				         instead NOTIFY_CODE_HANDLER someday. */
				NOTIFY_CODE_HANDLER(HDN_BEGINDRAG, OnHeaderBeginDragNotification)
				NOTIFY_CODE_HANDLER(HDN_BEGINTRACKA, OnHeaderBeginTrackNotification)
				NOTIFY_CODE_HANDLER(HDN_BEGINTRACKW, OnHeaderBeginTrackNotification)
				NOTIFY_CODE_HANDLER(HDN_DIVIDERDBLCLICKA, OnHeaderDividerDblClickNotification)
				NOTIFY_CODE_HANDLER(HDN_DIVIDERDBLCLICKW, OnHeaderDividerDblClickNotification)
				NOTIFY_CODE_HANDLER(HDN_ENDDRAG, OnHeaderEndDragNotification)
				NOTIFY_CODE_HANDLER(HDN_ENDTRACKA, OnHeaderEndTrackNotification)
				NOTIFY_CODE_HANDLER(HDN_ENDTRACKW, OnHeaderEndTrackNotification)
				NOTIFY_CODE_HANDLER(HDN_FILTERBTNCLICK, OnHeaderFilterBtnClickNotification)
				NOTIFY_CODE_HANDLER(HDN_FILTERCHANGE, OnHeaderFilterChangeNotification)
				NOTIFY_CODE_HANDLER(HDN_GETDISPINFOA, OnHeaderGetDispInfoNotification)
				NOTIFY_CODE_HANDLER(HDN_GETDISPINFOW, OnHeaderGetDispInfoNotification)
				NOTIFY_CODE_HANDLER(HDN_ITEMCHANGINGA, OnHeaderItemChangingNotification)
				NOTIFY_CODE_HANDLER(HDN_ITEMCHANGINGW, OnHeaderItemChangingNotification)
				NOTIFY_CODE_HANDLER(HDN_ITEMDBLCLICKA, OnHeaderItemDblClkNotification)
				NOTIFY_CODE_HANDLER(HDN_ITEMDBLCLICKW, OnHeaderItemDblClkNotification)
				NOTIFY_CODE_HANDLER(HDN_ITEMSTATEICONCLICK, OnHeaderStateIconClickNotification)
				//NOTIFY_CODE_HANDLER(HDN_OVERFLOWCLICK, OnHeaderOverflowClickNotification)
				NOTIFY_CODE_HANDLER(HDN_TRACKA, OnHeaderTrackNotification)
				NOTIFY_CODE_HANDLER(HDN_TRACKW, OnHeaderTrackNotification)

				COMMAND_CODE_HANDLER(EN_CHANGE, OnEditChange)

				CHAIN_MSG_MAP(CComControl<ExplorerListView>)
				ALT_MSG_MAP(1)
				MESSAGE_HANDLER(WM_CHAR, OnEditChar)
				MESSAGE_HANDLER(WM_CONTEXTMENU, OnEditContextMenu)
				MESSAGE_HANDLER(WM_DESTROY, OnEditDestroy)
				MESSAGE_HANDLER(WM_KEYDOWN, OnEditKeyDown)
				MESSAGE_HANDLER(WM_KEYUP, OnEditKeyUp)
				MESSAGE_HANDLER(WM_KILLFOCUS, OnEditKillFocus)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnEditLButtonDblClk)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnEditLButtonDown)
				MESSAGE_HANDLER(WM_LBUTTONUP, OnEditLButtonUp)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnEditMButtonDblClk)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnEditMButtonDown)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnEditMButtonUp)
				MESSAGE_HANDLER(WM_MOUSEHOVER, OnEditMouseHover)
				MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnEditMouseWheel)
				MESSAGE_HANDLER(WM_MOUSELEAVE, OnEditMouseLeave)
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnEditMouseMove)
				MESSAGE_HANDLER(WM_MOUSEWHEEL, OnEditMouseWheel)
				MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnEditRButtonDblClk)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnEditRButtonDown)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnEditRButtonUp)
				MESSAGE_HANDLER(WM_SETFOCUS, OnEditSetFocus)
				MESSAGE_HANDLER(WM_SYSKEYDOWN, OnEditKeyDown)
				MESSAGE_HANDLER(WM_SYSKEYUP, OnEditKeyUp)
				MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnEditXButtonDblClk)
				MESSAGE_HANDLER(WM_XBUTTONDOWN, OnEditXButtonDown)
				MESSAGE_HANDLER(WM_XBUTTONUP, OnEditXButtonUp)
				ALT_MSG_MAP(2)
				MESSAGE_HANDLER(WM_CHAR, OnHeaderChar)
				MESSAGE_HANDLER(WM_CONTEXTMENU, OnHeaderContextMenu)
				MESSAGE_HANDLER(WM_DESTROY, OnHeaderDestroy)
				MESSAGE_HANDLER(WM_KEYDOWN, OnHeaderKeyDown)
				MESSAGE_HANDLER(WM_KEYUP, OnHeaderKeyUp)
				MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnHeaderLButtonDblClk)
				MESSAGE_HANDLER(WM_LBUTTONDOWN, OnHeaderLButtonDown)
				MESSAGE_HANDLER(WM_LBUTTONUP, OnHeaderLButtonUp)
				MESSAGE_HANDLER(WM_MBUTTONDBLCLK, OnHeaderMButtonDblClk)
				MESSAGE_HANDLER(WM_MBUTTONDOWN, OnHeaderMButtonDown)
				MESSAGE_HANDLER(WM_MBUTTONUP, OnHeaderMButtonUp)
				MESSAGE_HANDLER(WM_MOUSEHOVER, OnHeaderMouseHover)
				MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnHeaderMouseWheel)
				MESSAGE_HANDLER(WM_MOUSELEAVE, OnHeaderMouseLeave)
				MESSAGE_HANDLER(WM_MOUSEMOVE, OnHeaderMouseMove)
				MESSAGE_HANDLER(WM_MOUSEWHEEL, OnHeaderMouseWheel)
				MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnHeaderRButtonDblClk)
				MESSAGE_HANDLER(WM_RBUTTONDOWN, OnHeaderRButtonDown)
				MESSAGE_HANDLER(WM_RBUTTONUP, OnHeaderRButtonUp)
				MESSAGE_HANDLER(WM_PARENTNOTIFY, OnParentNotify)
				MESSAGE_HANDLER(WM_SYSKEYDOWN, OnHeaderKeyDown)
				MESSAGE_HANDLER(WM_SYSKEYUP, OnHeaderKeyUp)
				MESSAGE_HANDLER(WM_XBUTTONDBLCLK, OnHeaderXButtonDblClk)
				MESSAGE_HANDLER(WM_XBUTTONDOWN, OnHeaderXButtonDown)
				MESSAGE_HANDLER(WM_XBUTTONUP, OnHeaderXButtonUp)

				MESSAGE_HANDLER(GetDragImageMessage(), OnHeaderGetDragImage)

				MESSAGE_HANDLER(HDM_GETITEMA, OnHeaderGetItem)
				MESSAGE_HANDLER(HDM_GETITEMW, OnHeaderGetItem)
				MESSAGE_HANDLER(HDM_INSERTITEMA, OnHeaderInsertItem)
				MESSAGE_HANDLER(HDM_INSERTITEMW, OnHeaderInsertItem)
				MESSAGE_HANDLER(HDM_SETFILTERCHANGETIMEOUT, OnHeaderSetFilterChangeTimeout)
				MESSAGE_HANDLER(HDM_SETIMAGELIST, OnHeaderSetImageList)
				MESSAGE_HANDLER(HDM_SETITEMA, OnHeaderSetItem)
				MESSAGE_HANDLER(HDM_SETITEMW, OnHeaderSetItem)

				COMMAND_CODE_HANDLER(EN_CHANGE, OnEditChange)
			END_MSG_MAP()
		#endif
	#endif

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of ISupportErrorInfo
	///
	//@{
	/// \brief <em>Retrieves whether an interface supports the \c IErrorInfo interface</em>
	///
	/// \param[in] interfaceToCheck The IID of the interface to check.
	///
	/// \return \c S_OK if the interface identified by \c interfaceToCheck supports \c IErrorInfo;
	///         otherwise \c S_FALSE.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms221233.aspx">IErrorInfo</a>
	virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo(REFIID interfaceToCheck);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of persistance
	///
	//@{
	/// \brief <em>Overrides \c IPersistPropertyBagImpl::Load to make the control persistent</em>
	///
	/// We want to persist a Unicode text property. This can't be done by just using ATL's persistence
	/// macros. So we override \c IPersistPropertyBagImpl::Load and read directly from the property bag.
	///
	/// \param[in] pPropertyBag The \c IPropertyBag implementation which stores the control's properties.
	/// \param[in] pErrorLog The caller's \c IErrorLog implementation which will receive any errors
	///            that occur during property loading.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Save,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa768206.aspx">IPersistPropertyBag::Load</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa768196.aspx">IPropertyBag</a>
	virtual HRESULT STDMETHODCALLTYPE Load(LPPROPERTYBAG pPropertyBag, LPERRORLOG pErrorLog);
	/// \brief <em>Overrides \c IPersistPropertyBagImpl::Save to make the control persistent</em>
	///
	/// We want to persist a Unicode text property. This can't be done by just using ATL's persistence
	/// macros. So we override \c IPersistPropertyBagImpl::Save and write directly into the property bag.
	///
	/// \param[in] pPropertyBag The \c IPropertyBag implementation which stores the control's properties.
	/// \param[in] clearDirtyFlag Flag indicating whether the control should clear its dirty flag after
	///            saving. If \c TRUE, the flag is cleared, otherwise not. A value of \c FALSE allows
	///            the caller to do a "Save Copy As" operation.
	/// \param[in] saveAllProperties Flag indicating whether the control should save all its properties
	///            (\c TRUE) or only those that have changed from the default value (\c FALSE).
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Load,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa768207.aspx">IPersistPropertyBag::Save</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa768196.aspx">IPropertyBag</a>
	virtual HRESULT STDMETHODCALLTYPE Save(LPPROPERTYBAG pPropertyBag, BOOL clearDirtyFlag, BOOL saveAllProperties);
	/// \brief <em>Overrides \c IPersistStreamInitImpl::GetSizeMax to make object properties persistent</em>
	///
	/// Object properties can't be persisted through \c IPersistStreamInitImpl by just using ATL's
	/// persistence macros. So we communicate directly with the stream. This requires we override
	/// \c IPersistStreamInitImpl::GetSizeMax.
	///
	/// \param[in] pSize The maximum number of bytes that persistence of the control's properties will
	///            consume.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Load, Save,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms687287.aspx">IPersistStreamInit::GetSizeMax</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms682273.aspx">IPersistStreamInit</a>
	virtual HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER* pSize);
	/// \brief <em>Overrides \c IPersistStreamInitImpl::Load to make object properties persistent</em>
	///
	/// Object properties can't be persisted through \c IPersistStreamInitImpl by just using ATL's
	/// persistence macros. So we override \c IPersistStreamInitImpl::Load and read directly from
	/// the stream.
	///
	/// \param[in] pStream The \c IStream implementation which stores the control's properties.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Save, GetSizeMax,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms680730.aspx">IPersistStreamInit::Load</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms682273.aspx">IPersistStreamInit</a>
	///     <a href="https://msdn.microsoft.com/en-us/library/aa380034.aspx">IStream</a>
	virtual HRESULT STDMETHODCALLTYPE Load(LPSTREAM pStream);
	/// \brief <em>Overrides \c IPersistStreamInitImpl::Save to make object properties persistent</em>
	///
	/// Object properties can't be persisted through \c IPersistStreamInitImpl by just using ATL's
	/// persistence macros. So we override \c IPersistStreamInitImpl::Save and write directly into
	/// the stream.
	///
	/// \param[in] pStream The \c IStream implementation which stores the control's properties.
	/// \param[in] clearDirtyFlag Flag indicating whether the control should clear its dirty flag after
	///            saving. If \c TRUE, the flag is cleared, otherwise not. A value of \c FALSE allows
	///            the caller to do a "Save Copy As" operation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Load, GetSizeMax,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms694439.aspx">IPersistStreamInit::Save</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms682273.aspx">IPersistStreamInit</a>
	///     <a href="https://msdn.microsoft.com/en-us/library/aa380034.aspx">IStream</a>
	virtual HRESULT STDMETHODCALLTYPE Save(LPSTREAM pStream, BOOL clearDirtyFlag);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IExplorerListView
	///
	//@{
	/// \brief <em>Retrieves the current setting of the \c AbsoluteBkImagePosition property</em>
	///
	/// Retrieves whether the position defined by the \c BkImagePositionX and \c BkImagePositionY properties
	/// is a relative one or an absolute one.\n
	/// If set to \c VARIANT_TRUE, both properties define the absolute offset (in pixels) of the top-left
	/// tile of the control's background image. Otherwise they're treaten as percentage values defining the
	/// background image's alignment relative to the control's client area. A value of 0 left-aligns
	/// (respectively top-aligns), 50 centers, 100 right-aligns (bottom-aligns) the background image and so
	/// on.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_AbsoluteBkImagePosition, get_BkImagePositionX, get_BkImagePositionY, get_BkImageStyle
	virtual HRESULT STDMETHODCALLTYPE get_AbsoluteBkImagePosition(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c AbsoluteBkImagePosition property</em>
	///
	/// Sets whether the position defined by the \c BkImagePositionX and \c BkImagePositionY properties
	/// is a relative one or an absolute one.\n
	/// If set to \c VARIANT_TRUE, both properties define the absolute offset (in pixels) of the top-left
	/// tile of the control's background image. Otherwise they're treaten as percentage values defining the
	/// background image's alignment relative to the control's client area. A value of 0 left-aligns
	/// (respectively top-aligns), 50 centers, 100 right-aligns (bottom-aligns) the background image and so
	/// on.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_AbsoluteBkImagePosition, put_BkImagePositionX, put_BkImagePositionY, put_BkImageStyle
	virtual HRESULT STDMETHODCALLTYPE put_AbsoluteBkImagePosition(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c AllowHeaderDragDrop property</em>
	///
	/// Retrieves whether the control's columns can be reordered by drag'n'dropping the column headers.
	/// If set to \c VARIANT_TRUE, columns can be reordered; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_AllowHeaderDragDrop, get_RegisterForOLEDragDrop, get_DragScrollTimeBase,
	///     SetHeaderInsertMarkPosition, ListViewColumn::get_Position, Raise_ColumnBeginDrag
	virtual HRESULT STDMETHODCALLTYPE get_AllowHeaderDragDrop(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c AllowHeaderDragDrop property</em>
	///
	/// Sets whether the control's columns can be reordered by drag'n'dropping the column headers.
	/// If set to \c VARIANT_TRUE, columns can be reordered; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_AllowHeaderDragDrop, put_RegisterForOLEDragDrop, put_DragScrollTimeBase,
	///     SetHeaderInsertMarkPosition, ListViewColumn::put_Position, Raise_ColumnBeginDrag
	virtual HRESULT STDMETHODCALLTYPE put_AllowHeaderDragDrop(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c AllowLabelEditing property</em>
	///
	/// Retrieves whether label-editing mode can be entered. If set to \c VARIANT_TRUE, label-edit mode
	/// can be entered by either calling \c ListViewItem::StartLabelEditing or by single-clicking a
	/// selected item. If set to \c VARIANT_FALSE, label-edit mode is not available.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_AllowLabelEditing, get_hWndEdit, ListViewItem::StartLabelEditing,
	///     Raise_StartingLabelEditing
	virtual HRESULT STDMETHODCALLTYPE get_AllowLabelEditing(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c AllowLabelEditing property</em>
	///
	/// Sets whether label-editing mode can be entered. If set to \c VARIANT_TRUE, label-edit mode
	/// can be entered by either calling \c ListViewItem::StartLabelEditing or by single-clicking a
	/// selected item. If set to \c VARIANT_FALSE, label-edit mode is not available.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_AllowLabelEditing, get_hWndEdit, ListViewItem::StartLabelEditing,
	///     Raise_StartingLabelEditing
	virtual HRESULT STDMETHODCALLTYPE put_AllowLabelEditing(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c AlwaysShowSelection property</em>
	///
	/// Retrieves whether the selected items are highlighted even if the control doesn't have the focus.
	/// If set to \c VARIANT_TRUE, selected items are drawn as selected if the control does not have the
	/// focus; otherwise they're drawn as normal items.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_AlwaysShowSelection, get_CaretItem, ListViewItem::get_Selected
	virtual HRESULT STDMETHODCALLTYPE get_AlwaysShowSelection(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c AlwaysShowSelection property</em>
	///
	/// Sets whether the selected items are highlighted even if the control doesn't have the focus.
	/// If set to \c VARIANT_TRUE, selected items are drawn as selected if the control does not have the
	/// focus; otherwise they're drawn as normal items.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_AlwaysShowSelection, putref_CaretItem, ListViewItem::put_Selected
	virtual HRESULT STDMETHODCALLTYPE put_AlwaysShowSelection(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c AnchorItem property</em>
	///
	/// Retrieves the control's anchor item. The anchor item is the item with which range-selection
	/// begins.
	///
	/// \param[out] ppAnchorItem Receives the anchor item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa putref_AnchorItem, ListViewItem::get_Anchor, get_MultiSelect, get_CaretItem
	virtual HRESULT STDMETHODCALLTYPE get_AnchorItem(IListViewItem** ppAnchorItem);
	/// \brief <em>Sets the \c AnchorItem property</em>
	///
	/// Sets the control's anchor item. The anchor item is the item with which range-selection begins.
	///
	/// \param[in] pNewAnchorItem The new anchor item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_AnchorItem, put_MultiSelect, putref_CaretItem
	virtual HRESULT STDMETHODCALLTYPE putref_AnchorItem(IListViewItem* pNewAnchorItem);
	/// \brief <em>Retrieves the current setting of the \c Appearance property</em>
	///
	/// Retrieves the kind of border that is drawn around the control. Any of the values defined by the
	/// \c AppearanceConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_Appearance, get_BorderStyle, ExLVwLibU::AppearanceConstants
	/// \else
	///   \sa put_Appearance, get_BorderStyle, ExLVwLibA::AppearanceConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_Appearance(AppearanceConstants* pValue);
	/// \brief <em>Sets the \c Appearance property</em>
	///
	/// Sets the kind of border that is drawn around the control. Any of the values defined by the
	/// \c AppearanceConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_Appearance, put_BorderStyle, ExLVwLibU::AppearanceConstants
	/// \else
	///   \sa get_Appearance, put_BorderStyle, ExLVwLibA::AppearanceConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_Appearance(AppearanceConstants newValue);
	/// \brief <em>Retrieves the control's application ID</em>
	///
	/// Retrieves the control's application ID. This property is part of the fingerprint that
	/// uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The application ID.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppName, get_AppShortName, get_Build, get_CharSet, get_IsRelease, get_Programmer,
	///     get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_AppID(SHORT* pValue);
	/// \brief <em>Retrieves the control's application name</em>
	///
	/// Retrieves the control's application name. This property is part of the fingerprint that
	/// uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The application name.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppShortName, get_Build, get_CharSet, get_IsRelease, get_Programmer,
	///     get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_AppName(BSTR* pValue);
	/// \brief <em>Retrieves the control's short application name</em>
	///
	/// Retrieves the control's short application name. This property is part of the fingerprint that
	/// uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The short application name.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_Build, get_CharSet, get_IsRelease, get_Programmer, get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_AppShortName(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c AutoArrangeItems property</em>
	///
	/// Retrieves whether the control auto-arranges its items in 'Icons', 'Small Icons', 'Tiles' and
	/// 'Extended Tiles' view. Any of the values defined by the \c AutoArrangeItemsConstants enumeration
	/// is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_AutoArrangeItems, get_View, ArrangeItems, get_SnapToGrid, get_UseWorkAreas, get_WorkAreas,
	///       ExLVwLibU::AutoArrangeItemsConstants
	/// \else
	///   \sa put_AutoArrangeItems, get_View, ArrangeItems, get_SnapToGrid, get_UseWorkAreas, get_WorkAreas,
	///       ExLVwLibA::AutoArrangeItemsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_AutoArrangeItems(AutoArrangeItemsConstants* pValue);
	/// \brief <em>Sets the \c AutoArrangeItems property</em>
	///
	/// Sets whether the control auto-arranges its items in 'Icons', 'Small Icons', 'Tiles' and
	/// 'Extended Tiles' view. Any of the values defined by the \c AutoArrangeItemsConstants enumeration
	/// is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_AutoArrangeItems, put_View, ArrangeItems, put_SnapToGrid, put_UseWorkAreas, get_WorkAreas,
	///       ExLVwLibU::AutoArrangeItemsConstants
	/// \else
	///   \sa get_AutoArrangeItems, put_View, ArrangeItems, put_SnapToGrid, put_UseWorkAreas, get_WorkAreas,
	///       ExLVwLibA::AutoArrangeItemsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_AutoArrangeItems(AutoArrangeItemsConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c AutoSizeColumns property</em>
	///
	/// Retrieves whether the other columns are sized automatically to optimally fill the available space if
	/// one column is resized by the user. If set to \c VARIANT_TRUE, the columns are sized automatically;
	/// otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_AutoSizeColumns, get_Columns, ListViewColumn::get_Width
	virtual HRESULT STDMETHODCALLTYPE get_AutoSizeColumns(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c AutoSizeColumns property</em>
	///
	/// Sets whether the other columns are sized automatically to optimally fill the available space if
	/// one column is resized by the user. If set to \c VARIANT_TRUE, the columns are sized automatically;
	/// otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_AutoSizeColumns, get_Columns, ListViewColumn::put_Width
	virtual HRESULT STDMETHODCALLTYPE put_AutoSizeColumns(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c BackColor property</em>
	///
	/// Retrieves the control's background color.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_BackColor, get_BkImage, get_BackgroundDrawMode, get_ForeColor, get_TextBackColor,
	///     get_EditBackColor, get_InsertMarkColor
	virtual HRESULT STDMETHODCALLTYPE get_BackColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c BackColor property</em>
	///
	/// Sets the control's background color.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_BackColor, put_BkImage, put_BackgroundDrawMode, put_ForeColor, put_TextBackColor,
	///     put_EditBackColor, put_InsertMarkColor
	virtual HRESULT STDMETHODCALLTYPE put_BackColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c BackgroundDrawMode property</em>
	///
	/// Retrieves how the control's background is drawn. Any of the values defined by the
	/// \c BackgroundDrawModeConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa put_BackgroundDrawMode, get_BackColor, get_BkImage, get_Regional,
	///       ExLVwLibU::BackgroundDrawModeConstants
	/// \else
	///   \sa put_BackgroundDrawMode, get_BackColor, get_BkImage, get_Regional,
	///       ExLVwLibA::BackgroundDrawModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_BackgroundDrawMode(BackgroundDrawModeConstants* pValue);
	/// \brief <em>Sets the \c BackgroundDrawMode property</em>
	///
	/// Sets how the control's background is drawn. Any of the values defined by the
	/// \c BackgroundDrawModeConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa get_BackgroundDrawMode, put_BackColor, put_BkImage, put_Regional,
	///       ExLVwLibU::BackgroundDrawModeConstants
	/// \else
	///   \sa get_BackgroundDrawMode, put_BackColor, put_BkImage, put_Regional,
	///       ExLVwLibA::BackgroundDrawModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_BackgroundDrawMode(BackgroundDrawModeConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c BkImage property</em>
	///
	/// Retrieves the control's background image. Valid values are:\n
	/// \arg A string containing the image's URL. Use the \c res:// protocol to load an image from a
	///      binary's resources.
	/// \arg An \c IPictureDisp object containg the image (requires comctl32.dll version 6.0 or higher).
	/// \arg The bitmap's handle (requires comctl32.dll version 6.0 or higher).
	/// \arg \c Empty if the control doesn't have a background image.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_BkImage, putref_BkImage, get_BkImageStyle, get_BkImagePositionX, get_BkImagePositionY,
	///     get_BackColor, get_BackgroundDrawMode, get_TextBackColor
	virtual HRESULT STDMETHODCALLTYPE get_BkImage(VARIANT* pValue);
	/// \brief <em>Sets the \c BkImage property</em>
	///
	/// Sets the control's background image. Valid values are:\n
	/// \arg A string containing the image's URL. Use the \c res:// protocol to load an image from a
	///      binary's resources.
	/// \arg An \c IPictureDisp object containg the image (requires comctl32.dll version 6.0 or higher).
	/// \arg The bitmap's handle (requires comctl32.dll version 6.0 or higher).
	/// \arg \c Empty if the control doesn't have a background image.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If \c newValue defines an \c IPictureDisp object, it is cloned.
	///
	/// \sa get_BkImage, putref_BkImage, put_BkImageStyle, put_BkImagePositionX, put_BkImagePositionY,
	///     put_BackColor, put_BackgroundDrawMode, put_TextBackColor
	virtual HRESULT STDMETHODCALLTYPE put_BkImage(VARIANT newValue);
	/// \brief <em>Sets the \c BkImage property</em>
	///
	/// Sets the control's background image. Valid values are:\n
	/// \arg A string containing the image's URL. Use the \c res:// protocol to load an image from a
	///      binary's resources.
	/// \arg An \c IPictureDisp object containg the image (requires comctl32.dll version 6.0 or higher).
	/// \arg The bitmap's handle (requires comctl32.dll version 6.0 or higher).
	/// \arg \c Empty if the control doesn't have a background image.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_BkImage, put_BkImage, put_BkImageStyle, put_BkImagePositionX, put_BkImagePositionY,
	///     put_BackColor, put_BackgroundDrawMode, put_TextBackColor
	virtual HRESULT STDMETHODCALLTYPE putref_BkImage(VARIANT newValue);
	/// \brief <em>Retrieves the current setting of the \c BkImagePositionX property</em>
	///
	/// Retrieves the x-coordinate of the position of the control's background bitmap. Depending on the
	/// setting of the \c AbsoluteBkImagePosition property, the value is either an absolute pixel value
	/// or a relative percentage value.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_BkImagePositionX, get_AbsoluteBkImagePosition, get_BkImagePositionY, get_BkImage
	virtual HRESULT STDMETHODCALLTYPE get_BkImagePositionX(LONG* pValue);
	/// \brief <em>Sets the \c BkImagePositionX property</em>
	///
	/// Sets the x-coordinate of the position of the control's background bitmap. Depending on the
	/// setting of the \c AbsoluteBkImagePosition property, the value is either an absolute pixel value
	/// or a relative percentage value.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_BkImagePositionX, put_AbsoluteBkImagePosition, put_BkImagePositionY, put_BkImage
	virtual HRESULT STDMETHODCALLTYPE put_BkImagePositionX(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c BkImagePositionY property</em>
	///
	/// Retrieves the y-coordinate of the position of the control's background bitmap. Depending on the
	/// setting of the \c AbsoluteBkImagePosition property, the value is either an absolute pixel value
	/// or a relative percentage value.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_BkImagePositionY, get_AbsoluteBkImagePosition, get_BkImagePositionX, get_BkImage
	virtual HRESULT STDMETHODCALLTYPE get_BkImagePositionY(LONG* pValue);
	/// \brief <em>Sets the \c BkImagePositionY property</em>
	///
	/// Sets the y-coordinate of the position of the control's background bitmap. Depending on the
	/// setting of the \c AbsoluteBkImagePosition property, the value is either an absolute pixel value
	/// or a relative percentage value.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_BkImagePositionY, put_AbsoluteBkImagePosition, put_BkImagePositionX, put_BkImage
	virtual HRESULT STDMETHODCALLTYPE put_BkImagePositionY(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c BkImageStyle property</em>
	///
	/// Retrieves how the control's background image is drawn. Any of the values defined by the
	/// \c BkImageStyleConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_BkImageStyle, get_BkImage, get_BkImagePositionX, get_BkImagePositionY,
	///       ExLVwLibU::BkImageStyleConstants
	/// \else
	///   \sa put_BkImageStyle, get_BkImage, get_BkImagePositionX, get_BkImagePositionY,
	///       ExLVwLibA::BkImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_BkImageStyle(BkImageStyleConstants* pValue);
	/// \brief <em>Sets the \c BkImageStyle property</em>
	///
	/// Sets how the control's background image is drawn. Any of the values defined by the
	/// \c BkImageStyleConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_BkImageStyle, put_BkImage, putref_BkImage, put_BkImagePositionX, put_BkImagePositionY,
	///       ExLVwLibU::BkImageStyleConstants
	/// \else
	///   \sa get_BkImageStyle, put_BkImage, putref_BkImage, put_BkImagePositionX, put_BkImagePositionY,
	///       ExLVwLibA::BkImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_BkImageStyle(BkImageStyleConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c BlendSelectionLasso property</em>
	///
	/// Retrieves whether the selection lasso will be drawn as a semi-transparent filled rectangle. If set to
	/// \c VARIANT_TRUE, the selection lasso is drawn as a filled rectangle with a solid border; otherwise
	/// only the border is drawn (as a dotted line).
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_BlendSelectionLasso, get_MultiSelect, Raise_BeginMarqueeSelection
	virtual HRESULT STDMETHODCALLTYPE get_BlendSelectionLasso(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c BlendSelectionLasso property</em>
	///
	/// Sets whether the selection lasso will be drawn as a semi-transparent filled rectangle. If set to
	/// \c VARIANT_TRUE, the selection lasso is drawn as a filled rectangle with a solid border; otherwise
	/// only the border is drawn (as a dotted line).
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_BlendSelectionLasso, put_MultiSelect, Raise_BeginMarqueeSelection
	virtual HRESULT STDMETHODCALLTYPE put_BlendSelectionLasso(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c BorderSelect property</em>
	///
	/// Retrieves how selected items are drawn. If set to \c VARIANT_TRUE, selected items are surrounded
	/// by a rectangular border in the system's highlight color; otherwise they are blended with the system's
	/// highlight color. Unselected items are surrounded by a rectangular border that has the color defined
	/// by the \c OutlineColor property, if this property is set to \c VARIANT_TRUE.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is useful with the 'Icons' view only.\n
	///          Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa put_BorderSelect, get_OutlineColor, get_View
	virtual HRESULT STDMETHODCALLTYPE get_BorderSelect(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c BorderSelect property</em>
	///
	/// Sets how selected items are drawn. If set to \c VARIANT_TRUE, selected items are surrounded
	/// by a rectangular border in the system's highlight color; otherwise they are blended with the system's
	/// highlight color. Unselected items are surrounded by a rectangular border that has the color defined
	/// by the \c OutlineColor property, if this property is set to \c VARIANT_TRUE.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is useful with the 'Icons' view only.\n
	///          Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa get_BorderSelect, put_OutlineColor, put_View
	virtual HRESULT STDMETHODCALLTYPE put_BorderSelect(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c BorderStyle property</em>
	///
	/// Retrieves the kind of inner border that is drawn around the control. Any of the values defined by the
	/// \c BorderStyleConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_BorderStyle, get_Appearance, ExLVwLibU::BorderStyleConstants
	/// \else
	///   \sa put_BorderStyle, get_Appearance, ExLVwLibA::BorderStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_BorderStyle(BorderStyleConstants* pValue);
	/// \brief <em>Sets the \c BorderStyle property</em>
	///
	/// Sets the kind of inner border that is drawn around the control. Any of the values defined by the
	/// \c BorderStyleConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_BorderStyle, put_Appearance, ExLVwLibU::BorderStyleConstants
	/// \else
	///   \sa get_BorderStyle, put_Appearance, ExLVwLibA::BorderStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_BorderStyle(BorderStyleConstants newValue);
	/// \brief <em>Retrieves the control's build number</em>
	///
	/// Retrieves the control's build number. This property is part of the fingerprint that
	/// uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The build number.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_AppShortName, get_CharSet, get_IsRelease, get_Programmer,
	///     get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_Build(LONG* pValue);
	/// \brief <em>Retrieves the current setting of the \c CallBackMask property</em>
	///
	/// Retrieves the item properties for which the client, rather than the control, stores the current data.
	/// The callback mask applies to all of the control's items.\n
	/// Any combination of the values defined by the \c CallBackMaskConstants enumeration is valid. The
	/// control will fire the \c ItemGetDisplayInfo event each time one of the callback properties' value
	/// is required.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_CallBackMask, Raise_ItemGetDisplayInfo, ExLVwLibU::CallBackMaskConstants
	/// \else
	///   \sa put_CallBackMask, Raise_ItemGetDisplayInfo, ExLVwLibA::CallBackMaskConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_CallBackMask(CallBackMaskConstants* pValue);
	/// \brief <em>Sets the \c CallBackMask property</em>
	///
	/// Sets the item properties for which the client, rather than the control, stores the current data.
	/// The callback mask applies to all of the control's items.\n
	/// Any combination of the values defined by the \c CallBackMaskConstants enumeration is valid. The
	/// control will fire the \c ItemGetDisplayInfo event each time one of the callback properties' value
	/// is required.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_CallBackMask, Raise_ItemGetDisplayInfo, ExLVwLibU::CallBackMaskConstants
	/// \else
	///   \sa get_CallBackMask, Raise_ItemGetDisplayInfo, ExLVwLibA::CallBackMaskConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_CallBackMask(CallBackMaskConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c CaretColumn property</em>
	///
	/// Retrieves the control's caret column header. The caret column header is the column header that has
	/// the focus.
	///
	/// \param[out] ppCaretColumn Receives the caret column header's \c IListViewColumn implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa putref_CaretColumn, get_SelectedColumn, ListViewColumn::get_Caret, SetFocusToHeader
	virtual HRESULT STDMETHODCALLTYPE get_CaretColumn(IListViewColumn** ppCaretColumn);
	/// \brief <em>Sets the \c CaretColumn property</em>
	///
	/// Sets the control's caret column header. The caret column header is the column header that has
	/// the focus.
	///
	/// \param[in] pNewCaretColumn The new caret column header's \c IListViewColumn implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_CaretColumn, putref_SelectedColumn, ListViewColumn::get_Caret, SetFocusToHeader
	virtual HRESULT STDMETHODCALLTYPE putref_CaretColumn(IListViewColumn* pNewCaretColumn);
	/// \brief <em>Retrieves the current setting of the \c CaretFooterItem property</em>
	///
	/// Retrieves the control's caret footer item. The caret footer item is the footer item that has the
	/// focus.
	///
	/// \param[out] ppCaretFooterItem Receives the caret footer item's \c IListViewFooterItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa putref_CaretFooterItem, ListViewFooterItem::get_Caret
	virtual HRESULT STDMETHODCALLTYPE get_CaretFooterItem(IListViewFooterItem** ppCaretFooterItem);
	/// \brief <em>Sets the \c CaretFooterItem property</em>
	///
	/// Sets the control's caret footer item. The caret footer item is the footer item that has the
	/// focus.
	///
	/// \param[in] pNewCaretFooterItem The new caret footer item's \c IListViewFooterItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_CaretFooterItem, ListViewFooterItem::get_Caret
	virtual HRESULT STDMETHODCALLTYPE putref_CaretFooterItem(IListViewFooterItem* pNewCaretFooterItem);
	/// \brief <em>Retrieves the current setting of the \c CaretGroup property</em>
	///
	/// Retrieves the control's caret group. The caret group is the group that has the focus.
	///
	/// \param[out] ppCaretGroup Receives the caret group's \c IListViewGroup implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa putref_CaretGroup, ListViewGroup::get_Caret, Raise_GroupGotFocus, Raise_GroupLostFocus
	virtual HRESULT STDMETHODCALLTYPE get_CaretGroup(IListViewGroup** ppCaretGroup);
	/// \brief <em>Sets the \c CaretGroup property</em>
	///
	/// Sets the control's caret group. The caret group is the group that has the focus.
	///
	/// \param[in] pNewCaretGroup The new caret group's \c IListViewGroup implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_CaretGroup, ListViewGroup::get_Caret, Raise_GroupGotFocus, Raise_GroupLostFocus
	virtual HRESULT STDMETHODCALLTYPE putref_CaretGroup(IListViewGroup* pNewCaretGroup);
	/// \brief <em>Retrieves the current setting of the \c CaretItem property</em>
	///
	/// Retrieves the control's caret item. The caret item is the item that has the focus.
	///
	/// \param[in] changeFocusOnly Ignored.
	/// \param[out] ppCaretItem Receives the caret item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa putref_CaretItem, ListViewItem::get_Caret, get_AnchorItem
	virtual HRESULT STDMETHODCALLTYPE get_CaretItem(VARIANT_BOOL changeFocusOnly = VARIANT_FALSE, IListViewItem** ppCaretItem = NULL);
	/// \brief <em>Sets the \c CaretItem property</em>
	///
	/// Sets the control's caret item. The caret item is the item that has the focus.
	///
	/// \param[in] changeFocusOnly If set to \c VARIANT_TRUE, the method does nothing more than setting
	///            the focus to the specified item. The items' selection states are not changed. If set
	///            to \c VARIANT_FALSE, the selection states are changed, too. This parameter is ignored when
	///            retrieving the caret item.
	/// \param[in] pNewCaretItem The new caret item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks \c ChangeFocusOnly must be set to \c VARIANT_TRUE, if the \c VirtualMode property is set to
	///          \c VARIANT_TRUE.
	///
	/// \sa get_CaretItem, put_MultiSelect, putref_AnchorItem, put_VirtualMode
	virtual HRESULT STDMETHODCALLTYPE putref_CaretItem(VARIANT_BOOL changeFocusOnly = VARIANT_FALSE, IListViewItem* pNewCaretItem = NULL);
	/// \brief <em>Retrieves the control's character set</em>
	///
	/// Retrieves the control's character set (Unicode/ANSI). This property is part of the fingerprint
	/// that uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The character set.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_AppShortName, get_Build, get_IsRelease, get_Programmer,
	///     get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_CharSet(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c CheckItemOnSelect property</em>
	///
	/// Retrieves whether selecting an item using the mouse sets its state image to 'Checked'. If set to
	/// \c VARIANT_TRUE, selecting an item changes its state image; otherwise not. Also state images are
	/// invisible by default and displayed only for selected items and the item below the mouse cursor, if
	/// this property is set to \c VARIANT_TRUE.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ShowHeaderStateImages property is overridden by this property. If
	///          \c CheckItemOnSelect is set to \c VARIANT_TRUE, \c ShowHeaderStateImages is also set to
	///          \c VARIANT_TRUE automatically. After \c CheckItemOnSelect has been changed from
	///          \c VARIANT_FALSE to \c VARIANT_TRUE, \c ShowHeaderStateImages can't be set to
	///          \c VARIANT_TRUE alone until the control window is recreated.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_CheckItemOnSelect, get_ShowStateImages, get_ShowHeaderStateImages
	virtual HRESULT STDMETHODCALLTYPE get_CheckItemOnSelect(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c CheckItemOnSelect property</em>
	///
	/// Sets whether selecting an item using the mouse sets its state image to 'Checked'. If set to
	/// \c VARIANT_TRUE, selecting an item changes its state image; otherwise not. Also state images are
	/// invisible by default and displayed only for selected items and the item below the mouse cursor, if
	/// this property is set to \c VARIANT_TRUE.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ShowHeaderStateImages property is overridden by this property. If
	///          \c CheckItemOnSelect is set to \c VARIANT_TRUE, \c ShowHeaderStateImages is also set to
	///          \c VARIANT_TRUE automatically. After \c CheckItemOnSelect has been changed from
	///          \c VARIANT_FALSE to \c VARIANT_TRUE, \c ShowHeaderStateImages can't be set to
	///          \c VARIANT_TRUE alone until the control window is recreated.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_CheckItemOnSelect, put_ShowStateImages, put_ShowHeaderStateImages
	virtual HRESULT STDMETHODCALLTYPE put_CheckItemOnSelect(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ClickableColumnHeaders property</em>
	///
	/// Retrieves whether the control's column headers act like buttons and are clickable. If set to
	/// \c VARIANT_TRUE, the headers can be clicked; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ClickableColumnHeaders, get_SelectedColumn, get_hWndHeader, get_View, get_Columns,
	///     ListViewColumn::get_SortArrow
	virtual HRESULT STDMETHODCALLTYPE get_ClickableColumnHeaders(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ClickableColumnHeaders property</em>
	///
	/// Sets whether the control's column headers act like buttons and are clickable. If set to
	/// \c VARIANT_TRUE, the headers can be clicked; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ClickableColumnHeaders, putref_SelectedColumn, get_hWndHeader, put_View, get_Columns,
	///     ListViewColumn::put_SortArrow
	virtual HRESULT STDMETHODCALLTYPE put_ClickableColumnHeaders(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ColumnHeaderVisibility property</em>
	///
	/// Retrieves the conditions under which the column headers are displayed. Any of the values defined by
	/// the \c DisabledEventsConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ColumnHeaderVisibility, get_Columns, ExLVwLibU::ColumnHeaderVisibilityConstants
	/// \else
	///   \sa put_ColumnHeaderVisibility, get_Columns, ExLVwLibA::ColumnHeaderVisibilityConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ColumnHeaderVisibility(ColumnHeaderVisibilityConstants* pValue);
	/// \brief <em>Sets the \c ColumnHeaderVisibility property</em>
	///
	/// Sets the conditions under which the column headers are displayed. Any of the values defined by
	/// the \c DisabledEventsConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ColumnHeaderVisibility, get_Columns, ExLVwLibU::ColumnHeaderVisibilityConstants
	/// \else
	///   \sa get_ColumnHeaderVisibility, get_Columns, ExLVwLibA::ColumnHeaderVisibilityConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ColumnHeaderVisibility(ColumnHeaderVisibilityConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c Columns property</em>
	///
	/// Retrieves a collection object wrapping the control's columns.
	///
	/// \param[out] ppColumns Receives the collection object's \c IListViewColumns implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa get_SelectedColumn, ListViewColumns
	virtual HRESULT STDMETHODCALLTYPE get_Columns(IListViewColumns** ppColumns);
	/// \brief <em>Retrieves the current setting of the \c ColumnWidth property</em>
	///
	/// Retrieves the width (in pixels) of a column in 'List' view.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The control must not be in 'Details' view when you call this property.
	///
	/// \sa put_ColumnWidth, ListViewColumn::get_Width, get_View
	virtual HRESULT STDMETHODCALLTYPE get_ColumnWidth(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c ColumnWidth property</em>
	///
	/// Sets the width (in pixels) of a column in 'List' view.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The control must not be in 'Details' view when you call this property.\n
	///          This property can't be set at design-time.
	///
	/// \sa get_ColumnWidth, ListViewColumn::put_Width, GetStringWidth, put_View
	virtual HRESULT STDMETHODCALLTYPE put_ColumnWidth(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c DisabledEvents property</em>
	///
	/// Retrieves the events that won't be fired. Disabling events increases performance. Any
	/// combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_DisabledEvents, ExLVwLibU::DisabledEventsConstants
	/// \else
	///   \sa put_DisabledEvents, ExLVwLibA::DisabledEventsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_DisabledEvents(DisabledEventsConstants* pValue);
	/// \brief <em>Sets the \c DisabledEvents property</em>
	///
	/// Sets the events that won't be fired. Disabling events increases performance. Any
	/// combination of the values defined by the \c DisabledEventsConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_DisabledEvents, ExLVwLibU::DisabledEventsConstants
	/// \else
	///   \sa get_DisabledEvents, ExLVwLibA::DisabledEventsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_DisabledEvents(DisabledEventsConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c DontRedraw property</em>
	///
	/// Retrieves whether automatic redrawing of the control is enabled or disabled. If set to
	/// \c VARIANT_FALSE, the control will redraw itself automatically; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_DontRedraw
	virtual HRESULT STDMETHODCALLTYPE get_DontRedraw(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c DontRedraw property</em>
	///
	/// Enables or disables automatic redrawing of the control. Disabling redraw while doing large changes
	/// on the listview (like adding many items) may increase performance. If set to \c VARIANT_FALSE, the
	/// control will redraw itself automatically; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_DontRedraw
	virtual HRESULT STDMETHODCALLTYPE put_DontRedraw(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c DraggedColumn property</em>
	///
	/// Retrieves the column that is currently dragged. This is the same column that was passed to the
	/// \c HeaderBeginDrag or \c HeaderOLEDrag method.
	///
	/// \param[out] ppColumn Receives the column being dragged.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa HeaderBeginDrag, HeaderOLEDrag, get_Columns, Raise_ColumnBeginDrag, get_DraggedItems
	virtual HRESULT STDMETHODCALLTYPE get_DraggedColumn(IListViewColumn** ppColumn);
	/// \brief <em>Retrieves the current setting of the \c DraggedItems property</em>
	///
	/// Retrieves a collection object wrapping the control's items that are currently dragged. These
	/// are the same items that were passed to the \c BeginDrag or \c OLEDrag method.
	///
	/// \param[out] ppItems Receives the collection object's \c IListViewItemContainer implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa BeginDrag, OLEDrag, ListViewItemContainer, get_ListItems, get_DraggedColumn
	virtual HRESULT STDMETHODCALLTYPE get_DraggedItems(IListViewItemContainer** ppItems);
	/// \brief <em>Retrieves the current setting of the \c DragScrollTimeBase property</em>
	///
	/// Retrieves the period of time (in milliseconds) that is used as the time-base to calculate the
	/// velocity of auto-scrolling during a drag'n'drop operation. If set to 0, auto-scrolling is
	/// disabled. If set to -1, the system's double-click time, divided by 4, is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_DragScrollTimeBase, get_AllowHeaderDragDrop, get_RegisterForOLEDragDrop,
	///     Raise_DragMouseMove, Raise_HeaderDragMouseMove, Raise_OLEDragMouseMove,
	///     Raise_HeaderOLEDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE get_DragScrollTimeBase(LONG* pValue);
	/// \brief <em>Sets the \c DragScrollTimeBase property</em>
	///
	/// Sets the period of time (in milliseconds) that is used as the time-base to calculate the
	/// velocity of auto-scrolling during a drag'n'drop operation. If set to 0, auto-scrolling is
	/// disabled. If set to -1, the system's double-click time divided by 4 is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_DragScrollTimeBase, put_AllowHeaderDragDrop, put_RegisterForOLEDragDrop,
	///     Raise_DragMouseMove, Raise_HeaderDragMouseMove, Raise_OLEDragMouseMove,
	///     Raise_HeaderOLEDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE put_DragScrollTimeBase(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c DrawImagesAsynchronously property</em>
	///
	/// Retrieves whether the control draws the items' associated images asynchronously. Asynchronous
	/// image drawing may improve performance. If set to \c VARIANT_TRUE, item images are drawn
	/// asynchronously; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_DrawImagesAsynchronously, get_hImageList, Raise_ItemAsynchronousDrawFailed,
	///     Raise_GroupAsynchronousDrawFailed
	virtual HRESULT STDMETHODCALLTYPE get_DrawImagesAsynchronously(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c DrawImagesAsynchronously property</em>
	///
	/// Sets whether the control draws the items' associated images asynchronously. Asynchronous
	/// image drawing may improve performance. If set to \c VARIANT_TRUE, item images are drawn
	/// asynchronously; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_DrawImagesAsynchronously, put_hImageList, Raise_ItemAsynchronousDrawFailed,
	///     Raise_GroupAsynchronousDrawFailed
	virtual HRESULT STDMETHODCALLTYPE put_DrawImagesAsynchronously(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c DropHilitedItem property</em>
	///
	/// Retrieves the item, that is the target of a drag'n'drop operation. Its background is drawn
	/// highlighted. If set to \c NULL, no item is a drop target.
	///
	/// \param[out] ppDropHilitedItem Receives the drop target's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa putref_DropHilitedItem, ListViewItem::get_DropHilited, get_RegisterForOLEDragDrop, get_CaretItem
	virtual HRESULT STDMETHODCALLTYPE get_DropHilitedItem(IListViewItem** ppDropHilitedItem);
	/// \brief <em>Sets the \c DropHilitedItem property</em>
	///
	/// Sets the item, that is the target of a drag'n'drop operation. It's background is drawn
	/// highlighted. If set to \c NULL, no item is a drop target.
	///
	/// \param[in] pNewDropHilitedItem The new drop target's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_DropHilitedItem, put_RegisterForOLEDragDrop, putref_CaretItem, Raise_DragMouseMove,
	///     Raise_OLEDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE putref_DropHilitedItem(IListViewItem* pNewDropHilitedItem);
	/// \brief <em>Retrieves the current setting of the \c EditBackColor property</em>
	///
	/// Retrieves the contained edit control's background color.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_EditBackColor, get_EditForeColor, get_BackColor
	virtual HRESULT STDMETHODCALLTYPE get_EditBackColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c EditBackColor property</em>
	///
	/// Sets the contained edit control's background color.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_EditBackColor, put_EditForeColor, put_BackColor
	virtual HRESULT STDMETHODCALLTYPE put_EditBackColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c EditForeColor property</em>
	///
	/// Retrieves the contained edit control's text color.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_EditForeColor, get_EditBackColor, get_ForeColor
	virtual HRESULT STDMETHODCALLTYPE get_EditForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c EditForeColor property</em>
	///
	/// Sets the contained edit control's text color.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_EditForeColor, put_EditBackColor, put_ForeColor
	virtual HRESULT STDMETHODCALLTYPE put_EditForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c EditHoverTime property</em>
	///
	/// Retrieves the number of milliseconds the mouse cursor must be located over the contained edit
	/// control's client area before the \c EditMouseHover event is fired. If set to -1, the system
	/// hover time is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_EditHoverTime, Raise_EditMouseHover, get_HoverTime, get_HeaderHoverTime
	virtual HRESULT STDMETHODCALLTYPE get_EditHoverTime(LONG* pValue);
	/// \brief <em>Sets the \c EditHoverTime property</em>
	///
	/// Sets the number of milliseconds the mouse cursor must be located over the contained edit control's
	/// client area before the \c EditMouseHover event is fired. If set to -1, the system hover time
	/// is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_EditHoverTime, Raise_EditMouseHover, put_HoverTime, put_HeaderHoverTime
	virtual HRESULT STDMETHODCALLTYPE put_EditHoverTime(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c EditIMEMode property</em>
	///
	/// Retrieves the contained edit control's IME mode. IME is a Windows feature making it easy to enter
	/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_EditIMEMode, get_IMEMode, ExLVwLibU::IMEModeConstants
	/// \else
	///   \sa put_EditIMEMode, get_IMEMode, ExLVwLibA::IMEModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_EditIMEMode(IMEModeConstants* pValue);
	/// \brief <em>Sets the \c EditIMEMode property</em>
	///
	/// Sets the contained edit control's IME mode. IME is a Windows feature making it easy to enter
	/// Asian characters. Any of the values defined by the \c IMEModeConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_EditIMEMode, put_IMEMode, ExLVwLibU::IMEModeConstants
	/// \else
	///   \sa get_EditIMEMode, put_IMEMode, ExLVwLibA::IMEModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_EditIMEMode(IMEModeConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c EditText property</em>
	///
	/// Retrieves the text displayed by the control's contained edit control.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_EditText, ListViewItem::get_Text, Raise_EditChange
	virtual HRESULT STDMETHODCALLTYPE get_EditText(BSTR* pValue);
	/// \brief <em>Sets the \c EditText property</em>
	///
	/// Sets the text displayed by the control's contained edit control.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_EditText, ListViewItem::put_Text, Raise_EditChange
	virtual HRESULT STDMETHODCALLTYPE put_EditText(BSTR newValue);
	/// \brief <em>Retrieves the current setting of the \c EmptyMarkupText property</em>
	///
	/// Retrieves the text that the control will display if it contains no items.\n
	/// <strong>Comctl32.dll version 6.10 and newer only:</strong> Any &lt;a&gt; tags in the text are
	/// converted to links. So to make the word <em>Click</em> in the text <em>Click here to add an
	/// item</em> clickable, set the \c EmptyMarkupText property to <em>&lt;a&gt;Click&lt;/a&gt; here to
	/// add an item</em>. You can define more than one link. If the user clicks such a link, the event
	/// \c EmptyMarkupTextLinkClick will be raised.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The text's maximum length is 79 characters for comctl32.dll version 6.00 and older and
	///          2083 characters for comctl32.dll version 6.10 and higher.\n
	///          You should set the \c ShowFilterBar property to \c VARIANT_FALSE, if you want to use this
	///          property.\n
	///          Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa put_EmptyMarkupText, get_EmptyMarkupTextAlignment, Raise_EmptyMarkupTextLinkClick,
	///     get_ShowFilterBar, get_ListItems
	virtual HRESULT STDMETHODCALLTYPE get_EmptyMarkupText(BSTR* pValue);
	/// \brief <em>Sets the \c EmptyMarkupText property</em>
	///
	/// Sets the text that the control will display if it contains no items.\n
	/// <strong>Comctl32.dll version 6.10 and newer only:</strong> Any &lt;a&gt; tags in the text are
	/// converted to links. So to make the word <em>Click</em> in the text <em>Click here to add an
	/// item</em> clickable, set the \c EmptyMarkupText property to <em>&lt;a&gt;Click&lt;/a&gt; here to
	/// add an item</em>. You can define more than one link. If the user clicks such a link, the event
	/// \c EmptyMarkupTextLinkClick will be raised.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The text's maximum length is 79 characters for comctl32.dll version 6.00 and older and
	///          2083 characters for comctl32.dll version 6.10 and higher.\n
	///          You should set the \c ShowFilterBar property to \c VARIANT_FALSE, if you want to use this
	///          property.\n
	///          Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa get_EmptyMarkupText, put_EmptyMarkupTextAlignment, Raise_EmptyMarkupTextLinkClick,
	///     put_ShowFilterBar, get_ListItems
	virtual HRESULT STDMETHODCALLTYPE put_EmptyMarkupText(BSTR newValue);
	/// \brief <em>Retrieves the current setting of the \c EmptyMarkupTextAlignment property</em>
	///
	/// Retrieves the alignment of the text that is displayed if the control does not contain any items. Any
	/// of the values defined by the \c AlignmentConstants enumeration except \c alRight is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa put_EmptyMarkupTextAlignment, get_EmptyMarkupText, ExLVwLibU::AlignmentConstants
	/// \else
	///   \sa put_EmptyMarkupTextAlignment, get_EmptyMarkupText, ExLVwLibA::AlignmentConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_EmptyMarkupTextAlignment(AlignmentConstants* pValue);
	/// \brief <em>Sets the \c EmptyMarkupTextAlignment property</em>
	///
	/// Sets the alignment of the text that is displayed if the control does not contain any items. Any
	/// of the values defined by the \c AlignmentConstants enumeration except \c alRight is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa get_EmptyMarkupTextAlignment, put_EmptyMarkupText, ExLVwLibU::AlignmentConstants
	/// \else
	///   \sa get_EmptyMarkupTextAlignment, put_EmptyMarkupText, ExLVwLibA::AlignmentConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_EmptyMarkupTextAlignment(AlignmentConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c Enabled property</em>
	///
	/// Retrieves whether the control is enabled or disabled for user input. If set to \c VARIANT_TRUE, it
	/// reacts to user input; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_Enabled
	virtual HRESULT STDMETHODCALLTYPE get_Enabled(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c Enabled property</em>
	///
	/// Enables or disables the control for user input. If set to \c VARIANT_TRUE, it reacts to user input;
	/// otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_Enabled
	virtual HRESULT STDMETHODCALLTYPE put_Enabled(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c FilterChangedTimeout property</em>
	///
	/// Retrieves the number of milliseconds, that will pass before the \c FilterChanged event
	/// is fired after a column's filter was changed. If set to -1, the system's default setting is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_FilterChangedTimeout, Raise_FilterChanged, get_ShowFilterBar
	virtual HRESULT STDMETHODCALLTYPE get_FilterChangedTimeout(LONG* pValue);
	/// \brief <em>Sets the \c FilterChangedTimeout property</em>
	///
	/// Sets the number of milliseconds, that will pass before the \c FilterChanged event is
	/// fired after a column's filter was changed. If set to -1, the system's default setting is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_FilterChangedTimeout, Raise_FilterChanged, put_ShowFilterBar
	virtual HRESULT STDMETHODCALLTYPE put_FilterChangedTimeout(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c FirstVisibleItem property</em>
	///
	/// Retrieves the first listview item, that is entirely located within the control's client area and
	/// therefore visible to the user. This applies to 'List' and 'Details' view only.
	///
	/// \param[out] ppFirstItem Receives the first visible item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa get_ListItems, get_View
	virtual HRESULT STDMETHODCALLTYPE get_FirstVisibleItem(IListViewItem** ppFirstItem);
	/// \brief <em>Retrieves the current setting of the \c Font property</em>
	///
	/// Retrieves the control's font. It's used to draw the items' text.
	///
	/// \param[out] ppFont Receives the font object's \c IFontDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_Font, putref_Font, get_UseSystemFont, get_ForeColor, ListViewItem::get_Text,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms692695.aspx">IFontDisp</a>
	virtual HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont);
	/// \brief <em>Sets the \c Font property</em>
	///
	/// Sets the control's font. It's used to draw the items' text.
	///
	/// \param[in] pNewFont The new font object's \c IFontDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The object identified by \c pNewFont is cloned.
	///
	/// \sa get_Font, putref_Font, put_UseSystemFont, put_ForeColor, ListViewItem::put_Text,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms692695.aspx">IFontDisp</a>
	virtual HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pNewFont);
	/// \brief <em>Sets the \c Font property</em>
	///
	/// Sets the control's font. It's used to draw the items' text.
	///
	/// \param[in] pNewFont The new font object's \c IFontDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_Font, put_Font, put_UseSystemFont, put_ForeColor, ListViewItem::put_Text,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms692695.aspx">IFontDisp</a>
	virtual HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pNewFont);
	/// \brief <em>Retrieves the current setting of the \c FooterIntroText property</em>
	///
	/// Retrieves the text that the control will display in the footer area's caption.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_FooterIntroText, get_FooterItems, ShowFooter
	virtual HRESULT STDMETHODCALLTYPE get_FooterIntroText(BSTR* pValue);
	/// \brief <em>Sets the \c FooterIntroText property</em>
	///
	/// Sets the text that the control will display in the footer area's caption.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_FooterIntroText, get_FooterItems, ShowFooter
	virtual HRESULT STDMETHODCALLTYPE put_FooterIntroText(BSTR newValue);
	/// \brief <em>Retrieves the current setting of the \c FooterItems property</em>
	///
	/// Retrieves a collection object wrapping the control's footer items.
	///
	/// \param[out] ppFooterItems Receives the collection object's \c IListViewFooterItems implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.\n
	///          This property is read-only.
	///
	/// \sa get_ShowFooter, ListViewFooterItems, get_hImageList
	virtual HRESULT STDMETHODCALLTYPE get_FooterItems(IListViewFooterItems** ppFooterItems);
	/// \brief <em>Retrieves the current setting of the \c ForeColor property</em>
	///
	/// Retrieves the control's text color.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ForeColor, get_BackColor, get_TextBackColor, get_HotForeColor, get_EditForeColor,
	///     get_InsertMarkColor
	virtual HRESULT STDMETHODCALLTYPE get_ForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c ForeColor property</em>
	///
	/// Sets the control's text color.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ForeColor, put_BackColor, put_TextBackColor, put_HotForeColor, put_EditForeColor,
	///     put_InsertMarkColor
	virtual HRESULT STDMETHODCALLTYPE put_ForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c FullRowSelect property</em>
	///
	/// Retrieves whether an item's entire row (in 'Details' view) is highlighted if it is selected.
	/// Any of the values defined by the \c FullRowSelectConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_FullRowSelect, get_View, ExLVwLibU::FullRowSelectConstants
	/// \else
	///   \sa put_FullRowSelect, get_View, ExLVwLibA::FullRowSelectConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_FullRowSelect(FullRowSelectConstants* pValue);
	/// \brief <em>Sets the \c FullRowSelect property</em>
	///
	/// Sets whether an item's entire row (in 'Details' view) is highlighted if it is selected.
	/// Any of the values defined by the \c FullRowSelectConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_FullRowSelect, put_View, ExLVwLibU::FullRowSelectConstants
	/// \else
	///   \sa get_FullRowSelect, put_View, ExLVwLibA::FullRowSelectConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_FullRowSelect(FullRowSelectConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c GridLines property</em>
	///
	/// Retrieves whether the control draws gridlines in 'Details' view. If set to \c VARIANT_TRUE,
	/// gridlines are drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_GridLines, get_View
	virtual HRESULT STDMETHODCALLTYPE get_GridLines(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c GridLines property</em>
	///
	/// Sets whether the control draws gridlines in 'Details' view. If set to \c VARIANT_TRUE,
	/// gridlines are drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_GridLines, put_View
	virtual HRESULT STDMETHODCALLTYPE put_GridLines(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupFooterForeColor property</em>
	///
	/// Retrieves the color that the footer texts of the control's groups are drawn in.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.\n
	///          This property isn't supported for themed listviews.
	///
	/// \sa put_GroupFooterForeColor, get_GroupHeaderForeColor, get_Groups, get_ForeColor,
	///     ListViewGroup::get_Text
	virtual HRESULT STDMETHODCALLTYPE get_GroupFooterForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c GroupFooterForeColor property</em>
	///
	/// Sets the color that the footer texts of the control's groups are drawn in.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.\n
	///          This property isn't supported for themed listviews.
	///
	/// \sa get_GroupFooterForeColor, put_GroupHeaderForeColor, get_Groups, put_ForeColor,
	///     ListViewGroup::get_Text
	virtual HRESULT STDMETHODCALLTYPE put_GroupFooterForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupHeaderForeColor property</em>
	///
	/// Retrieves the color that the header texts of the control's groups are drawn in.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.\n
	///          Comctl32.dll version 6.10 or higher doesn't support this property for themed listviews.
	///
	/// \sa put_GroupHeaderForeColor, get_GroupFooterForeColor, get_Groups, get_ForeColor,
	///     ListViewGroup::get_Text
	virtual HRESULT STDMETHODCALLTYPE get_GroupHeaderForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c GroupHeaderForeColor property</em>
	///
	/// Sets the color that the header texts of the control's groups are drawn in.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.\n
	///          Comctl32.dll version 6.10 or higher doesn't support this property for themed listviews.
	///
	/// \sa get_GroupHeaderForeColor, put_GroupFooterForeColor, get_Groups, put_ForeColor,
	///     ListViewGroup::get_Text
	virtual HRESULT STDMETHODCALLTYPE put_GroupHeaderForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupLocale property</em>
	///
	/// Retrieves the unique ID of the locale to use when sorting the list view groups.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The locale is used when sorting using the \c sobNumericIntText, \c sobNumericFloatText,
	///          \c sobCurrencyText or \c sobDateTimeText sorting criterion.
	///
	/// \if UNICODE
	///   \sa put_GroupLocale, get_GroupTextParsingFlags, SortGroups, ExLVwLibU::SortByConstants
	/// \else
	///   \sa put_GroupLocale, get_GroupTextParsingFlags, SortGroups, ExLVwLibA::SortByConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_GroupLocale(LONG* pValue);
	/// \brief <em>Sets the \c GroupLocale property</em>
	///
	/// Sets the unique ID of the locale to use when sorting the list view groups.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The locale is used when sorting using the \c sobNumericIntText, \c sobNumericFloatText,
	///          \c sobCurrencyText or \c sobDateTimeText sorting criterion.
	///
	/// \if UNICODE
	///   \sa get_GroupLocale, put_GroupTextParsingFlags, SortGroups, ExLVwLibU::SortByConstants
	/// \else
	///   \sa get_GroupLocale, put_GroupTextParsingFlags, SortGroups, ExLVwLibA::SortByConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_GroupLocale(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupMarginBottom property</em>
	///
	/// Retrieves the bottom margin (in pixels) of the control's groups.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_GroupMarginBottom, get_GroupMarginLeft, get_GroupMarginRight, get_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE get_GroupMarginBottom(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c GroupMarginBottom property</em>
	///
	/// Sets the bottom margin (in pixels) of the control's groups.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_GroupMarginBottom, put_GroupMarginLeft, put_GroupMarginRight, put_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE put_GroupMarginBottom(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupMarginLeft property</em>
	///
	/// Retrieves the left margin (in pixels) of the control's groups.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_GroupMarginLeft, get_GroupMarginBottom, get_GroupMarginRight, get_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE get_GroupMarginLeft(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c GroupMarginLeft property</em>
	///
	/// Sets the left margin (in pixels) of the control's groups.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_GroupMarginLeft, put_GroupMarginBottom, put_GroupMarginRight, put_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE put_GroupMarginLeft(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupMarginRight property</em>
	///
	/// Retrieves the right margin (in pixels) of the control's groups.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_GroupMarginRight, get_GroupMarginBottom, get_GroupMarginLeft, get_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE get_GroupMarginRight(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c GroupMarginRight property</em>
	///
	/// Sets the right margin (in pixels) of the control's groups.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_GroupMarginRight, put_GroupMarginBottom, put_GroupMarginLeft, put_GroupMarginTop, get_Groups
	virtual HRESULT STDMETHODCALLTYPE put_GroupMarginRight(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupMarginTop property</em>
	///
	/// Retrieves the top margin (in pixels) of the control's groups.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_GroupMarginTop, get_GroupMarginBottom, get_GroupMarginLeft, get_GroupMarginRight, get_Groups
	virtual HRESULT STDMETHODCALLTYPE get_GroupMarginTop(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c GroupMarginTop property</em>
	///
	/// Sets the top margin (in pixels) of the control's groups.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_GroupMarginTop, put_GroupMarginBottom, put_GroupMarginLeft, put_GroupMarginRight, get_Groups
	virtual HRESULT STDMETHODCALLTYPE put_GroupMarginTop(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c Groups property</em>
	///
	/// Retrieves a collection object wrapping the control's groups.
	///
	/// \param[out] ppGroups Receives the collection object's \c IListViewGroups implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.\n
	///          This property is read-only.
	///
	/// \sa get_ShowGroups, ListViewGroups, ListViewItem::get_Group, get_hImageList
	virtual HRESULT STDMETHODCALLTYPE get_Groups(IListViewGroups** ppGroups);
	/// \brief <em>Retrieves the current setting of the \c GroupSortOrder property</em>
	///
	/// Retrieves the direction groups are sorted in. Any of the values defined by the \c SortOrderConstants
	/// enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_GroupSortOrder, SortGroups, ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa put_GroupSortOrder, SortGroups, ExLVwLibA::SortOrderConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_GroupSortOrder(SortOrderConstants* pValue);
	/// \brief <em>Sets the \c GroupSortOrder property</em>
	///
	/// Sets the direction groups are sorted in. Any of the values defined by the \c SortOrderConstants
	/// enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_GroupSortOrder, SortGroups, ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa get_GroupSortOrder, SortGroups, ExLVwLibA::SortOrderConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_GroupSortOrder(SortOrderConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c GroupTextParsingFlags property</em>
	///
	/// Retrieves the options to apply when parsing the group header text into a numerical or date value.
	/// The parsing results may be used when sorting the list view groups.
	///
	/// \param[in] parsingFunction Specifies the parsing function for which to retrieve the options. Any of
	///            the values defined by the \c TextParsingFunctionConstants enumeration is valid.
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The parsing options are used when sorting using the \c sobNumericIntText,
	///          \c sobNumericFloatText, \c sobCurrencyText or \c sobDateTimeText sorting criterion.\n
	///          They are also used when sorting using the \c sobText criterion if a specific locale
	///          identifier has been set for group sorting.
	///
	/// \if UNICODE
	///   \sa put_GroupTextParsingFlags, get_GroupLocale, SortGroups, ExLVwLibU::SortByConstants,
	///       ExLVwLibU::TextParsingFunctionConstants
	/// \else
	///   \sa put_GroupTextParsingFlags, get_GroupLocale, SortGroups, ExLVwLibA::SortByConstants,
	///       ExLVwLibA::TextParsingFunctionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_GroupTextParsingFlags(TextParsingFunctionConstants parsingFunction, LONG* pValue);
	/// \brief <em>Sets the \c GroupTextParsingFlags property</em>
	///
	/// Sets the options to apply when parsing the group header text into a numerical or date value.
	/// The parsing results may be used when sorting the list view groups.
	///
	/// \param[in] parsingFunction Specifies the parsing function for which to set the options. Any of
	///            the values defined by the \c TextParsingFunctionConstants enumeration is valid.
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The parsing options are used when sorting using the \c sobNumericIntText,
	///          \c sobNumericFloatText, \c sobCurrencyText or \c sobDateTimeText sorting criterion.\n
	///          They are also used when sorting using the \c sobText criterion if a specific locale
	///          identifier has been set for group sorting.
	///
	/// \if UNICODE
	///   \sa get_GroupTextParsingFlags, put_GroupLocale, SortGroups, ExLVwLibU::SortByConstants,
	///       ExLVwLibU::TextParsingFunctionConstants
	/// \else
	///   \sa get_GroupTextParsingFlags, put_GroupLocale, SortGroups, ExLVwLibA::SortByConstants,
	///       ExLVwLibA::TextParsingFunctionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_GroupTextParsingFlags(TextParsingFunctionConstants parsingFunction, LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c hDragImageList property</em>
	///
	/// Retrieves the handle to the imagelist containing the drag image that is used during a
	/// drag'n'drop operation to visualize the dragged items or column.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ShowDragImage, BeginDrag, HeaderBeginDrag, Raise_DragMouseMove, Raise_HeaderDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE get_hDragImageList(OLE_HANDLE* pValue);
	/// \brief <em>Retrieves the current setting of the \c HeaderFullDragging property</em>
	///
	/// Retrieves whether a column's caption and content are redrawn while the user is resizing the column.
	/// If set to \c VARIANT_TRUE, the column is redrawn immediately; otherwise it is redrawn when
	/// leaving column resize mode.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HeaderFullDragging, get_AllowHeaderDragDrop, get_View
	virtual HRESULT STDMETHODCALLTYPE get_HeaderFullDragging(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c HeaderFullDragging property</em>
	///
	/// Sets whether a column's caption and content are redrawn while the user is resizing the column.
	/// If set to \c VARIANT_TRUE, the column is redrawn immediately; otherwise it is redrawn when
	/// leaving column resize mode.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HeaderFullDragging, put_AllowHeaderDragDrop, put_View
	virtual HRESULT STDMETHODCALLTYPE put_HeaderFullDragging(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c HeaderHotTracking property</em>
	///
	/// Retrieves whether the caption of the column header underneath the mouse cursor is highlighted.
	/// If set to \c VARIANT_TRUE, the caption is highlighted; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property has no effect if the header control is themed.
	///
	/// \sa put_HeaderHotTracking, get_View
	virtual HRESULT STDMETHODCALLTYPE get_HeaderHotTracking(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c HeaderHotTracking property</em>
	///
	/// Sets whether the caption of the column header underneath the mouse cursor is highlighted.
	/// If set to \c VARIANT_TRUE, the caption is highlighted; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property has no effect if the header control is themed.
	///
	/// \sa get_HeaderHotTracking, put_View
	virtual HRESULT STDMETHODCALLTYPE put_HeaderHotTracking(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c HeaderHoverTime property</em>
	///
	/// Retrieves the number of milliseconds the mouse cursor must be located over the header control's
	/// client area before the \c HeaderMouseHover event is fired. If set to -1, the system hover time
	/// is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HeaderHoverTime, Raise_HeaderMouseHover, get_HoverTime, get_EditHoverTime
	virtual HRESULT STDMETHODCALLTYPE get_HeaderHoverTime(LONG* pValue);
	/// \brief <em>Sets the \c HeaderHoverTime property</em>
	///
	/// Sets the number of milliseconds the mouse cursor must be located over the header control's
	/// client area before the \c HeaderMouseHover event is fired. If set to -1, the system hover time
	/// is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HeaderHoverTime, Raise_HeaderMouseHover, put_HoverTime, put_EditHoverTime
	virtual HRESULT STDMETHODCALLTYPE put_HeaderHoverTime(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c HeaderOLEDragImageStyle property</em>
	///
	/// Retrieves the appearance of the OLE drag images generated by the control for column header OLE
	/// drag'n'drop. Any of the values defined by the \c OLEDragImageStyleConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_HeaderOLEDragImageStyle, get_OLEDragImageStyle, get_SupportOLEDragImages, HeaderOLEDrag,
	///       ExLVwLibU::OLEDragImageStyleConstants
	/// \else
	///   \sa put_HeaderOLEDragImageStyle, get_OLEDragImageStyle, get_SupportOLEDragImages, HeaderOLEDrag,
	///       ExLVwLibA::OLEDragImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_HeaderOLEDragImageStyle(OLEDragImageStyleConstants* pValue);
	/// \brief <em>Sets the \c HeaderOLEDragImageStyle property</em>
	///
	/// Sets the appearance of the OLE drag images generated by the control for column header OLE
	/// drag'n'drop. Any of the values defined by the \c OLEDragImageStyleConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_HeaderOLEDragImageStyle, put_OLEDragImageStyle, put_SupportOLEDragImages, HeaderOLEDrag,
	///       ExLVwLibU::OLEDragImageStyleConstants
	/// \else
	///   \sa get_HeaderOLEDragImageStyle, put_OLEDragImageStyle, put_SupportOLEDragImages, HeaderOLEDrag,
	///       ExLVwLibA::OLEDragImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_HeaderOLEDragImageStyle(OLEDragImageStyleConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c HideLabels property</em>
	///
	/// Retrieves whether the control displays item-labels in 'Icons' and 'Small Icons' view. If set to
	/// \c VARIANT_FALSE, item-labels are displayed; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_HideLabels, get_TextBackColor, get_LabelWrap, get_View
	virtual HRESULT STDMETHODCALLTYPE get_HideLabels(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c HideLabels property</em>
	///
	/// Sets whether the control displays item-labels in 'Icons' and 'Small Icons' view. If set to
	/// \c VARIANT_FALSE, item-labels are displayed; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_HideLabels, put_TextBackColor, put_LabelWrap, put_View
	virtual HRESULT STDMETHODCALLTYPE put_HideLabels(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c hImageList property</em>
	///
	/// Retrieves the handle of the specified image list.
	///
	/// \param[in] imageList The image list to retrieve. Any of the values defined by the
	///            \c ImageListConstants enumeration is valid.
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The previously set image list does NOT get destroyed automatically.
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::ImageListConstants
	/// \else
	///   \sa ExLVwLibA::ImageListConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_hImageList(ImageListConstants imageList, OLE_HANDLE* pValue);
	/// \brief <em>Sets the \c hImageList property</em>
	///
	/// Sets the handle of the specified image list.
	///
	/// \param[in] imageList The image list to set. Any of the values defined by the \c ImageListConstants
	///            enumeration is valid.
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The previous image list does NOT get auto-destroyed.
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::ImageListConstants
	/// \else
	///   \sa ExLVwLibA::ImageListConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_hImageList(ImageListConstants imageList, OLE_HANDLE newValue);
	/// \brief <em>Retrieves the current setting of the \c HotForeColor property</em>
	///
	/// Retrieves the control's text color for hot items. If set to -1, the system's default is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HotForeColor, get_ForeColor, get_HotItem
	virtual HRESULT STDMETHODCALLTYPE get_HotForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c HotForeColor property</em>
	///
	/// Sets the control's text color for hot items. If set to -1, the system's default is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HotForeColor, put_ForeColor, putref_HotItem
	virtual HRESULT STDMETHODCALLTYPE put_HotForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c HotItem property</em>
	///
	/// Retrieves the control's hot item. Usually the hot item is underlined and/or highlighted. If set to
	/// \c NULL, the control does not have a hot item.
	///
	/// \param[out] ppHotItem Receives the hot item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks You should set the \c ItemActivationMode property to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks and the \c UnderlinedItems property should include \c uiHot,
	///          if you want to use this property.
	///
	/// \sa putref_HotItem, get_ItemActivationMode, get_UnderlinedItems, ListViewItem::get_Hot,
	///     get_HotForeColor, Raise_HotItemChanging, Raise_HotItemChanged
	virtual HRESULT STDMETHODCALLTYPE get_HotItem(IListViewItem** ppHotItem);
	/// \brief <em>Sets the \c HotItem property</em>
	///
	/// Sets the control's hot item. Usually the hot item is underlined and/or highlighted. If set to
	/// \c NULL, the control does not have a hot item.
	///
	/// \param[in] pNewHotItem The new hot item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks You should set the \c ItemActivationMode property to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks and the \c UnderlinedItems property should include \c uiHot,
	///          if you want to use this property.
	///
	/// \sa get_HotItem, put_ItemActivationMode, put_UnderlinedItems, put_HotForeColor,
	///     Raise_HotItemChanging, Raise_HotItemChanged
	virtual HRESULT STDMETHODCALLTYPE putref_HotItem(IListViewItem* pNewHotItem);
	/// \brief <em>Retrieves the current setting of the \c HotMouseIcon property</em>
	///
	/// Retrieves a user-defined mouse cursor. It's used if \c HotMousePointer is set to \c mpCustom and
	/// the mouse cursor is located over a hot item.
	///
	/// \param[out] ppHotMouseIcon Receives the picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ItemActivationMode property must be set to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks, if you want to use a non-default hot mouse cursor.
	///
	/// \if UNICODE
	///   \sa put_HotMouseIcon, putref_HotMouseIcon, get_HotMousePointer, get_HotTracking,
	///       get_ItemActivationMode, get_MouseIcon, ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa put_HotMouseIcon, putref_HotMouseIcon, get_HotMousePointer, get_HotTracking,
	///       get_ItemActivationMode, get_MouseIcon, ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_HotMouseIcon(IPictureDisp** ppHotMouseIcon);
	/// \brief <em>Sets the \c HotMouseIcon property</em>
	///
	/// Sets a user-defined mouse cursor. It's used if \c HotMousePointer is set to \c mpCustom and.
	/// the mouse cursor is located over a hot item.
	///
	/// \param[in] pNewHotMouseIcon The new picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The object identified by \c pNewMouseIcon is cloned.\n
	///          The \c ItemActivationMode property must be set to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks, if you want to use a non-default hot mouse cursor.
	///
	/// \if UNICODE
	///   \sa get_HotMouseIcon, putref_HotMouseIcon, put_HotMousePointer, put_HotTracking,
	///       put_ItemActivationMode, put_MouseIcon, ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa get_HotMouseIcon, putref_HotMouseIcon, put_HotMousePointer, put_HotTracking,
	///       put_ItemActivationMode, put_MouseIcon, ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_HotMouseIcon(IPictureDisp* pNewHotMouseIcon);
	/// \brief <em>Sets the \c HotMouseIcon property</em>
	///
	/// Sets a user-defined mouse cursor. It's used if \c HotMousePointer is set to \c mpCustom and.
	/// the mouse cursor is located over a hot item.
	///
	/// \param[in] pNewHotMouseIcon The new picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ItemActivationMode property must be set to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks, if you want to use a non-default hot mouse cursor.
	///
	/// \if UNICODE
	///   \sa get_HotMouseIcon, put_HotMouseIcon, put_HotMousePointer, put_HotTracking,
	///       put_ItemActivationMode, putref_MouseIcon, ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa get_HotMouseIcon, put_HotMouseIcon, put_HotMousePointer, put_HotTracking,
	///       put_ItemActivationMode, putref_MouseIcon, ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE putref_HotMouseIcon(IPictureDisp* pNewHotMouseIcon);
	/// \brief <em>Retrieves the current setting of the \c HotMousePointer property</em>
	///
	/// Retrieves the cursor's type that's used if the mouse cursor is placed over an item that has the
	/// 'Hot' attribute set. Any of the values defined by the \c MousePointerConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ItemActivationMode property must be set to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks, if you want to use a non-default hot mouse cursor.
	///
	/// \if UNICODE
	///   \sa put_HotMousePointer, get_HotMouseIcon, get_HotTracking, get_ItemActivationMode,
	///       get_MousePointer, ExLVwLibU::MousePointerConstants
	/// \else
	///   \sa put_HotMousePointer, get_HotMouseIcon, get_HotTracking, get_ItemActivationMode,
	///       get_MousePointer, ExLVwLibA::MousePointerConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_HotMousePointer(MousePointerConstants* pValue);
	/// \brief <em>Sets the \c HotMousePointer property</em>
	///
	/// Sets the cursor's type that's used if the mouse cursor is placed over an item that has the
	/// 'Hot' attribute set. Any of the values defined by the \c MousePointerConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c ItemActivationMode property must be set to \c iamOneSingleClick or
	///          \c iamTwoSingleClicks, if you want to use a non-default hot mouse cursor.
	///
	/// \if UNICODE
	///   \sa get_HotMousePointer, put_HotMouseIcon, put_HotTracking, put_ItemActivationMode,
	///       put_MousePointer, ExLVwLibU::MousePointerConstants
	/// \else
	///   \sa get_HotMousePointer, put_HotMouseIcon, put_HotTracking, put_ItemActivationMode,
	///       put_MousePointer, ExLVwLibA::MousePointerConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_HotMousePointer(MousePointerConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c HotTracking property</em>
	///
	/// Retrieves whether the item underneath the mouse cursor is selected automatically. If set to
	/// \c VARIANT_TRUE, the item is selected automatically; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HotTracking, get_HotTrackingHoverTime, get_HotItem, get_HotMousePointer, get_HotMouseIcon,
	///     get_ItemActivationMode, get_UnderlinedItems, Raise_HotItemChanging, Raise_HotItemChanged
	virtual HRESULT STDMETHODCALLTYPE get_HotTracking(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c HotTracking property</em>
	///
	/// Sets whether the item underneath the mouse cursor is selected automatically. If set to
	/// \c VARIANT_TRUE, the item is selected automatically; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HotTracking, put_HotTrackingHoverTime, putref_HotItem, put_HotMousePointer,
	///     put_HotMouseIcon, put_ItemActivationMode, put_UnderlinedItems, Raise_HotItemChanging,
	///     Raise_HotItemChanged
	virtual HRESULT STDMETHODCALLTYPE put_HotTracking(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c HotTrackingHoverTime property</em>
	///
	/// Retrieves the number of milliseconds the mouse cursor must be located over an item before
	/// it is selected (if \c HotTracking is activated). If set to -1, the system's default setting
	/// is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HotTrackingHoverTime, get_HotTracking, get_HotItem, get_HoverTime
	virtual HRESULT STDMETHODCALLTYPE get_HotTrackingHoverTime(LONG* pValue);
	/// \brief <em>Sets the \c HotTrackingHoverTime property</em>
	///
	/// Sets the number of milliseconds the mouse cursor must be located over an item before
	/// it is selected (if \c HotTracking is activated). If set to -1, the system's default setting
	/// is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HotTrackingHoverTime, put_HotTracking, putref_HotItem, put_HoverTime
	virtual HRESULT STDMETHODCALLTYPE put_HotTrackingHoverTime(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c HoverTime property</em>
	///
	/// Retrieves the number of milliseconds the mouse cursor must be located over the control's client
	/// area before the \c MouseHover event is fired. If set to -1, the system hover time is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_HoverTime, Raise_MouseHover, get_HotTrackingHoverTime, get_HeaderHoverTime, get_EditHoverTime
	virtual HRESULT STDMETHODCALLTYPE get_HoverTime(LONG* pValue);
	/// \brief <em>Sets the \c HoverTime property</em>
	///
	/// Sets the number of milliseconds the mouse cursor must be located over the control's client
	/// area before the \c MouseHover event is fired. If set to -1, the system hover time is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_HoverTime, Raise_MouseHover, put_HotTrackingHoverTime, put_HeaderHoverTime, put_EditHoverTime
	virtual HRESULT STDMETHODCALLTYPE put_HoverTime(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c hWnd property</em>
	///
	/// Retrieves the control's window handle.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa get_hWndEdit, get_hWndHeader, Raise_RecreatedControlWindow, Raise_DestroyedControlWindow
	virtual HRESULT STDMETHODCALLTYPE get_hWnd(OLE_HANDLE* pValue);
	/// \brief <em>Retrieves the current setting of the \c hWndEdit property</em>
	///
	/// Retrieves the contained edit control's window handle.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa get_hWnd, get_hWndHeader, Raise_CreatedEditControlWindow, Raise_DestroyedEditControlWindow
	virtual HRESULT STDMETHODCALLTYPE get_hWndEdit(OLE_HANDLE* pValue);
	/// \brief <em>Retrieves the current setting of the \c hWndHeader property</em>
	///
	/// Retrieves the contained header control's window handle.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa get_hWnd, get_hWndEdit, Raise_CreatedHeaderControlWindow, Raise_DestroyedHeaderControlWindow
	virtual HRESULT STDMETHODCALLTYPE get_hWndHeader(OLE_HANDLE* pValue);
	/// \brief <em>Retrieves the current setting of the \c hWndToolTip property</em>
	///
	/// Retrieves the tooltip control's window handle.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_hWndToolTip, get_ToolTips
	virtual HRESULT STDMETHODCALLTYPE get_hWndToolTip(OLE_HANDLE* pValue);
	/// \brief <em>Sets the \c hWndToolTip property</em>
	///
	/// Sets the window handle of the tooltip control to use.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The previous tooltip window does NOT get auto-destroyed.
	///
	/// \sa get_hWndToolTip, put_ToolTips
	virtual HRESULT STDMETHODCALLTYPE put_hWndToolTip(OLE_HANDLE newValue);
	/// \brief <em>Retrieves the current setting of the \c IMEMode property</em>
	///
	/// Retrieves the control's IME mode. IME is a Windows feature making it easy to enter Asian characters.
	/// Any of the values defined by the \c IMEModeConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_IMEMode, get_EditIMEMode, ExLVwLibU::IMEModeConstants
	/// \else
	///   \sa put_IMEMode, get_EditIMEMode, ExLVwLibA::IMEModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_IMEMode(IMEModeConstants* pValue);
	/// \brief <em>Sets the \c IMEMode property</em>
	///
	/// Sets the control's IME mode. IME is a Windows feature making it easy to enter Asian characters.
	/// Any of the values defined by the \c IMEModeConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_IMEMode, put_EditIMEMode, ExLVwLibU::IMEModeConstants
	/// \else
	///   \sa get_IMEMode, put_EditIMEMode, ExLVwLibA::IMEModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_IMEMode(IMEModeConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c IncludeHeaderInTabOrder property</em>
	///
	/// Retrieves whether the header control is included in the tab order, so that the keyboard focus can be
	/// set to it by pressing the [TAB] key. If set to \c VARIANT_TRUE, the header control is part of the tab
	/// order; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_IncludeHeaderInTabOrder, Raise_HeaderGotFocus, Raise_HeaderLostFocus
	virtual HRESULT STDMETHODCALLTYPE get_IncludeHeaderInTabOrder(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c IncludeHeaderInTabOrder property</em>
	///
	/// Sets whether the header control is included in the tab order, so that the keyboard focus can be
	/// set to it by pressing the [TAB] key. If set to \c VARIANT_TRUE, the header control is part of the tab
	/// order; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_IncludeHeaderInTabOrder, Raise_HeaderGotFocus, Raise_HeaderLostFocus
	virtual HRESULT STDMETHODCALLTYPE put_IncludeHeaderInTabOrder(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c IncrementalSearchString property</em>
	///
	/// Retrieves the control's current incremental search-string. This string is used to select an item
	/// based on characters entered by the user.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa Raise_IncrementalSearchStringChanging, Raise_IncrementalSearching
	virtual HRESULT STDMETHODCALLTYPE get_IncrementalSearchString(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c InsertMarkColor property</em>
	///
	/// Retrieves the color that is the control's insertion mark is drawn in.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_InsertMarkColor, GetInsertMarkPosition, get_BackColor, get_ForeColor
	virtual HRESULT STDMETHODCALLTYPE get_InsertMarkColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c InsertMarkColor property</em>
	///
	/// Sets the color that is the control's insertion mark is drawn in.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_InsertMarkColor, SetInsertMarkPosition, put_BackColor, put_ForeColor
	virtual HRESULT STDMETHODCALLTYPE put_InsertMarkColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the control's release type</em>
	///
	/// Retrieves the control's release type. This property is part of the fingerprint that uniquely
	/// identifies each software written by Timo "TimoSoft" Kunze. If set to \c VARIANT_TRUE, the
	/// control was compiled for release; otherwise it was compiled for debugging.
	///
	/// \param[out] pValue The release type.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_AppShortName, get_Build, get_CharSet, get_Programmer, get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_IsRelease(VARIANT_BOOL* pValue);
	/// \brief <em>Retrieves the current setting of the \c ItemActivationMode property</em>
	///
	/// Retrieves the circumstances under which the control will fire the \c ItemActivate event. Any of
	/// the values defined by the \c ItemActivationModeConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ItemActivationMode, get_HotTracking, get_UnderlinedItems, Raise_ItemActivate,
	///       ListViewItem::get_Activating, ListViewSubItem::get_Activating,
	///       ExLVwLibU::ItemActivationModeConstants
	/// \else
	///   \sa put_ItemActivationMode, get_HotTracking, get_UnderlinedItems, Raise_ItemActivate,
	///       ListViewItem::get_Activating, ListViewSubItem::get_Activating,
	///       ExLVwLibA::ItemActivationModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ItemActivationMode(ItemActivationModeConstants* pValue);
	/// \brief <em>Sets the \c ItemActivationMode property</em>
	///
	/// Sets the circumstances under which the control will fire the \c ItemActivate event. Any of
	/// the values defined by the \c ItemActivationModeConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ItemActivationMode, put_HotTracking, put_UnderlinedItems, Raise_ItemActivate,
	///       ListViewItem::put_Activating, ListViewSubItem::put_Activating,
	///       ExLVwLibU::ItemActivationModeConstants
	/// \else
	///   \sa get_ItemActivationMode, put_HotTracking, put_UnderlinedItems, Raise_ItemActivate,
	///       ListViewItem::put_Activating, ListViewSubItem::put_Activating,
	///       ExLVwLibA::ItemActivationModeConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ItemActivationMode(ItemActivationModeConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c ItemAlignment property</em>
	///
	/// Retrieves how items are aligned in 'Icons', 'Small Icons', 'Tiles' and 'Extended Tiles' view. Any of
	/// the values defined by the \c ItemAlignmentConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ItemAlignment, get_View, ExLVwLibU::ItemAlignmentConstants
	/// \else
	///   \sa put_ItemAlignment, get_View, ExLVwLibA::ItemAlignmentConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ItemAlignment(ItemAlignmentConstants* pValue);
	/// \brief <em>Sets the \c ItemAlignment property</em>
	///
	/// Sets how items are aligned in 'Icons', 'Small Icons', 'Tiles' and 'Extended Tiles' view. Any of
	/// the values defined by the \c ItemAlignmentConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ItemAlignment, put_View, ExLVwLibU::ItemAlignmentConstants
	/// \else
	///   \sa get_ItemAlignment, put_View, ExLVwLibA::ItemAlignmentConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ItemAlignment(ItemAlignmentConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c ItemBoundingBoxDefinition property</em>
	///
	/// Retrieves the parts of an item that get treated as such if firing any kind of mouse event. Any
	/// combination of the values defined by the \c ItemBoundingBoxDefinitionConstants enumeration is
	/// valid. E. g. if set to \c ibbdItemIcon combined with \c ibbdItemStateImage, the \c listItem
	/// parameter of the \c MouseMove event will identify the item only if the mouse cursor is located
	/// over the item's icon or state image; otherwise (e. g. if the cursor is located over the
	/// item's text) it will be \c NULL.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ItemBoundingBoxDefinition, HitTest, ExLVwLibU::ItemBoundingBoxDefinitionConstants
	/// \else
	///   \sa put_ItemBoundingBoxDefinition, HitTest, ExLVwLibA::ItemBoundingBoxDefinitionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ItemBoundingBoxDefinition(ItemBoundingBoxDefinitionConstants* pValue);
	/// \brief <em>Sets the \c ItemBoundingBoxDefinition property</em>
	///
	/// Sets the parts of an item that get treated as such if firing any kind of mouse event. Any
	/// combination of the values defined by the \c ItemBoundingBoxDefinitionConstants enumeration is
	/// valid. E. g. if set to \c ibbdItemIcon combined with \c ibbdItemStateImage, the \c listItem
	/// parameter of the \c MouseMove event will identify the item only if the mouse cursor is located
	/// over the item's icon or state image; otherwise (e. g. if the cursor is located over the
	/// item's text) it will be \c NULL.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ItemBoundingBoxDefinition, HitTest, ExLVwLibU::ItemBoundingBoxDefinitionConstants
	/// \else
	///   \sa get_ItemBoundingBoxDefinition, HitTest, ExLVwLibA::ItemBoundingBoxDefinitionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ItemBoundingBoxDefinition(ItemBoundingBoxDefinitionConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c ItemHeight property</em>
	///
	/// Retrieves the items' height in pixels. This setting is used in 'Details' view if the \c OwnerDrawn
	/// property is set to \c VARIANT_TRUE.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ItemHeight, get_OwnerDrawn, get_View, ListViewItem::GetRectangle
	virtual HRESULT STDMETHODCALLTYPE get_ItemHeight(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c ItemHeight property</em>
	///
	/// Sets the items' height in pixels. This setting is used in 'Details' view if the \c OwnerDrawn
	/// property is set to \c VARIANT_TRUE.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ItemHeight, put_OwnerDrawn, put_View, ListViewItem::GetRectangle
	virtual HRESULT STDMETHODCALLTYPE put_ItemHeight(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c JustifyIconColumns property</em>
	///
	/// Retrieves whether icon spacing may be adjusted automatically by some pixels so that the available
	/// space is filled up optimally. If set to \c VARIANT_TRUE, horizontal icon spacing is adjusted
	/// automatically; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_JustifyIconColumns, SetIconSpacing, get_View
	virtual HRESULT STDMETHODCALLTYPE get_JustifyIconColumns(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c JustifyIconColumns property</em>
	///
	/// Sets whether icon spacing may be adjusted automatically by some pixels so that the available
	/// space is filled up optimally. If set to \c VARIANT_TRUE, horizontal icon spacing is adjusted
	/// automatically; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_JustifyIconColumns, SetIconSpacing, put_View
	virtual HRESULT STDMETHODCALLTYPE put_JustifyIconColumns(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c LabelWrap property</em>
	///
	/// Retrieves whether an item's text may be wrapped in 'Icons' view. If set to \c VARIANT_TRUE, it may be
	/// wrapped; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_LabelWrap, get_HideLabels, get_View
	virtual HRESULT STDMETHODCALLTYPE get_LabelWrap(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c LabelWrap property</em>
	///
	/// Sets whether an item's text may be wrapped in 'Icons' view. If set to \c VARIANT_TRUE, it may be
	/// wrapped; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_LabelWrap, put_HideLabels, put_View
	virtual HRESULT STDMETHODCALLTYPE put_LabelWrap(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ListItems property</em>
	///
	/// Retrieves a collection object wrapping the control's listview items.
	///
	/// \param[out] ppItems Receives the collection object's \c IListViewItems implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	///
	/// \sa ListViewItems
	virtual HRESULT STDMETHODCALLTYPE get_ListItems(IListViewItems** ppItems);
	/// \brief <em>Retrieves the current setting of the \c MinItemRowsVisibleInGroups property</em>
	///
	/// Retrieves the number of item rows that are always displayed in subseted groups. If set to 0, the
	/// control always displays all of the groups' items.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_MinItemRowsVisibleInGroups, ListViewGroup::get_Subseted
	virtual HRESULT STDMETHODCALLTYPE get_MinItemRowsVisibleInGroups(LONG* pValue);
	/// \brief <em>Sets the \c MinItemRowsVisibleInGroups property</em>
	///
	/// Sets the number of item rows that are always displayed in subseted groups. If set to 0, the
	/// control always displays all of the groups' items.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_MinItemRowsVisibleInGroups, ListViewGroup::put_Subseted
	virtual HRESULT STDMETHODCALLTYPE put_MinItemRowsVisibleInGroups(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c MouseIcon property</em>
	///
	/// Retrieves a user-defined mouse cursor. It's used if \c MousePointer is set to \c mpCustom.
	///
	/// \param[out] ppMouseIcon Receives the picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_MouseIcon, putref_MouseIcon, get_MousePointer, get_HotMouseIcon,
	///       ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa put_MouseIcon, putref_MouseIcon, get_MousePointer, get_HotMouseIcon,
	///       ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppMouseIcon);
	/// \brief <em>Sets the \c MouseIcon property</em>
	///
	/// Sets a user-defined mouse cursor. It's used if \c MousePointer is set to \c mpCustom.
	///
	/// \param[in] pNewMouseIcon The new picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The object identified by \c pNewMouseIcon is cloned.
	///
	/// \if UNICODE
	///   \sa get_MouseIcon, putref_MouseIcon, put_MousePointer, put_HotMouseIcon,
	///       ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa get_MouseIcon, putref_MouseIcon, put_MousePointer, put_HotMouseIcon,
	///       ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pNewMouseIcon);
	/// \brief <em>Sets the \c MouseIcon property</em>
	///
	/// Sets a user-defined mouse cursor. It's used if \c MousePointer is set to \c mpCustom.
	///
	/// \param[in] pNewMouseIcon The new picture object's \c IPictureDisp implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_MouseIcon, put_MouseIcon, put_MousePointer, putref_HotMouseIcon,
	///       ExLVwLibU::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \else
	///   \sa get_MouseIcon, put_MouseIcon, put_MousePointer, putref_HotMouseIcon,
	///       ExLVwLibA::MousePointerConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms680762.aspx">IPictureDisp</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pNewMouseIcon);
	/// \brief <em>Retrieves the current setting of the \c MousePointer property</em>
	///
	/// Retrieves the cursor's type that's used if the mouse cursor is placed within the control's client
	/// area. Any of the values defined by the \c MousePointerConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_MousePointer, get_MouseIcon, get_HotMousePointer, ExLVwLibU::MousePointerConstants
	/// \else
	///   \sa put_MousePointer, get_MouseIcon, get_HotMousePointer, ExLVwLibA::MousePointerConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_MousePointer(MousePointerConstants* pValue);
	/// \brief <em>Sets the \c MousePointer property</em>
	///
	/// Sets the cursor's type that's used if the mouse cursor is placed within the control's client
	/// area. Any of the values defined by the \c MousePointerConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_MousePointer, put_MouseIcon, put_HotMousePointer, ExLVwLibU::MousePointerConstants
	/// \else
	///   \sa get_MousePointer, put_MouseIcon, put_HotMousePointer, ExLVwLibA::MousePointerConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_MousePointer(MousePointerConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c MultiSelect property</em>
	///
	/// Retrieves whether multiple items can be selected at the same time. If set to \c VARIANT_TRUE,
	/// the user may select multiple items; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_MultiSelect, get_BlendSelectionLasso, Raise_BeginMarqueeSelection
	virtual HRESULT STDMETHODCALLTYPE get_MultiSelect(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c MultiSelect property</em>
	///
	/// Sets whether multiple items can be selected at the same time. If set to \c VARIANT_TRUE,
	/// the user may select multiple items; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_MultiSelect, put_BlendSelectionLasso, Raise_BeginMarqueeSelection
	virtual HRESULT STDMETHODCALLTYPE put_MultiSelect(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c OLEDragImageStyle property</em>
	///
	/// Retrieves the appearance of the OLE drag images generated by the control. Any of the values defined
	/// by the \c OLEDragImageStyleConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_OLEDragImageStyle, get_HeaderOLEDragImageStyle, get_SupportOLEDragImages, OLEDrag,
	///       ExLVwLibU::OLEDragImageStyleConstants
	/// \else
	///   \sa put_OLEDragImageStyle, get_HeaderOLEDragImageStyle, get_SupportOLEDragImages, OLEDrag,
	///       ExLVwLibA::OLEDragImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_OLEDragImageStyle(OLEDragImageStyleConstants* pValue);
	/// \brief <em>Sets the \c OLEDragImageStyle property</em>
	///
	/// Sets the appearance of the OLE drag images generated by the control. Any of the values defined
	/// by the \c OLEDragImageStyleConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_OLEDragImageStyle, put_HeaderOLEDragImageStyle, put_SupportOLEDragImages, OLEDrag,
	///       ExLVwLibU::OLEDragImageStyleConstants
	/// \else
	///   \sa get_OLEDragImageStyle, put_HeaderOLEDragImageStyle, put_SupportOLEDragImages, OLEDrag,
	///       ExLVwLibA::OLEDragImageStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_OLEDragImageStyle(OLEDragImageStyleConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c OutlineColor property</em>
	///
	/// Retrieves the color, that the rectangular border is drawn in, that surrounds an unselected item if
	/// \c BorderSelect is set to \c VARIANT_TRUE.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_OutlineColor, get_BorderSelect
	virtual HRESULT STDMETHODCALLTYPE get_OutlineColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c OutlineColor property</em>
	///
	/// Sets the color, that the rectangular border is drawn in, that surrounds an unselected item if
	/// \c BorderSelect is set to \c VARIANT_TRUE.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_OutlineColor, put_BorderSelect
	virtual HRESULT STDMETHODCALLTYPE put_OutlineColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c OwnerDrawn property</em>
	///
	/// Retrieves whether the client application draws the items itself in 'Details' view. If set to
	/// \c VARIANT_TRUE, the control will fire the \c OwnerDrawItem event each time an item must be drawn in
	/// 'Details' view. If set to \c VARIANT_FALSE, the control will draw the items itself. In this case
	/// drawing can still be customized using the \c CustomDraw event.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_OwnerDrawn, get_ItemHeight, get_View, Raise_OwnerDrawItem, Raise_CustomDraw,
	///     ListViewColumn::get_OwnerDrawn
	virtual HRESULT STDMETHODCALLTYPE get_OwnerDrawn(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c OwnerDrawn property</em>
	///
	/// Sets whether the client application draws the items itself in 'Details' view. If set to
	/// \c VARIANT_TRUE, the control will fire the \c OwnerDrawItem event each time an item must be drawn in
	/// 'Details' view. If set to \c VARIANT_FALSE, the control will draw the items itself. In this case
	/// drawing can still be customized using the \c CustomDraw event.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_OwnerDrawn, put_ItemHeight, put_View, Raise_OwnerDrawItem, Raise_CustomDraw,
	///     ListViewColumn::put_OwnerDrawn
	virtual HRESULT STDMETHODCALLTYPE put_OwnerDrawn(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ProcessContextMenuKeys property</em>
	///
	/// Retrieves whether the control fires the \c ContextMenu, \c HeaderContextMenu and \c EditContextMenu
	/// events if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c VARIANT_TRUE,
	/// the events are fired; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ProcessContextMenuKeys, Raise_ContextMenu, Raise_HeaderContextMenu, Raise_EditContextMenu
	virtual HRESULT STDMETHODCALLTYPE get_ProcessContextMenuKeys(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ProcessContextMenuKeys property</em>
	///
	/// Sets whether the control fires the \c ContextMenu, \c HeaderContextMenu and \c EditContextMenu
	/// events if the user presses [SHIFT]+[F10] or [WINDOWS CONTEXTMENU]. If set to \c VARIANT_TRUE,
	/// the events are fired; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ProcessContextMenuKeys, Raise_ContextMenu, Raise_HeaderContextMenu, Raise_EditContextMenu
	virtual HRESULT STDMETHODCALLTYPE put_ProcessContextMenuKeys(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the name(s) of the control's programmer(s)</em>
	///
	/// Retrieves the name(s) of the control's programmer(s). This property is part of the fingerprint
	/// that uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The programmer.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_AppShortName, get_Build, get_CharSet, get_IsRelease, get_Tester
	virtual HRESULT STDMETHODCALLTYPE get_Programmer(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c Regional property</em>
	///
	/// Retrieves whether the control's window region includes only the item icons and text in 'Icons'
	/// view. Any area, that is not part of an item, is excluded from the window region. If set to
	/// \c VARIANT_TRUE, the control's window region contains only items; otherwise it contains the whole
	/// client area.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_Regional, get_BackgroundDrawMode, get_View
	virtual HRESULT STDMETHODCALLTYPE get_Regional(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c Regional property</em>
	///
	/// Sets whether the control's window region includes only the item icons and text in 'Icons' view. Any
	/// area, that is not part of an item, is excluded from the window region. If set to \c VARIANT_TRUE, the
	/// control's window region contains only items; otherwise it contains the whole client area.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_Regional, put_BackgroundDrawMode, put_View
	virtual HRESULT STDMETHODCALLTYPE put_Regional(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c RegisterForOLEDragDrop property</em>
	///
	/// Retrieves whether the control is registered as a target for OLE drag'n'drop. If set to
	/// \c VARIANT_TRUE, the control accepts OLE drag'n'drop actions; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_RegisterForOLEDragDrop, get_SupportOLEDragImages, Raise_OLEDragEnter,
	///     Raise_HeaderOLEDragEnter
	virtual HRESULT STDMETHODCALLTYPE get_RegisterForOLEDragDrop(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c RegisterForOLEDragDrop property</em>
	///
	/// Sets whether the control is registered as a target for OLE drag'n'drop. If set to
	/// \c VARIANT_TRUE, the control accepts OLE drag'n'drop actions; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_RegisterForOLEDragDrop, put_SupportOLEDragImages, Raise_OLEDragEnter,
	///     Raise_HeaderOLEDragEnter
	virtual HRESULT STDMETHODCALLTYPE put_RegisterForOLEDragDrop(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ResizableColumns property</em>
	///
	/// Retrieves whether the user can resize the control's columns. If set to \c VARIANT_TRUE, the columns
	/// can be resized; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_ResizableColumns, ListViewColumn::get_Resizable, ListViewColumn::get_Width,
	///     Raise_BeginColumnResizing
	virtual HRESULT STDMETHODCALLTYPE get_ResizableColumns(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ResizableColumns property</em>
	///
	/// Sets whether the user can resize the control's columns. If set to \c VARIANT_TRUE, the columns
	/// can be resized; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_ResizableColumns, ListViewColumn::put_Resizable, ListViewColumn::put_Width,
	///     Raise_BeginColumnResizing
	virtual HRESULT STDMETHODCALLTYPE put_ResizableColumns(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c RightToLeft property</em>
	///
	/// Retrieves whether bidirectional features are enabled or disabled. Any combination of the values
	/// defined by the \c RightToLeftConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_RightToLeft, get_IMEMode, ExLVwLibU::RightToLeftConstants
	/// \else
	///   \sa put_RightToLeft, get_IMEMode, ExLVwLibA::RightToLeftConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_RightToLeft(RightToLeftConstants* pValue);
	/// \brief <em>Sets the \c RightToLeft property</em>
	///
	/// Enables or disables bidirectional features. Any combination of the values defined by the
	/// \c RightToLeftConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \attention Setting or clearing the \c rtlLayout flag destroys and recreates the control window.
	///
	/// \if UNICODE
	///   \sa get_RightToLeft, put_IMEMode, ExLVwLibU::RightToLeftConstants
	/// \else
	///   \sa get_RightToLeft, put_IMEMode, ExLVwLibA::RightToLeftConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_RightToLeft(RightToLeftConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c ScrollBars property</em>
	///
	/// Retrieves the scrollbars to show if necessary. Any of the values defined by the
	/// \c ScrollBarsConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ScrollBars, Raise_BeforeScroll, Raise_AfterScroll, ExLVwLibU::ScrollBarsConstants
	/// \else
	///   \sa put_ScrollBars, Raise_BeforeScroll, Raise_AfterScroll, ExLVwLibA::ScrollBarsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ScrollBars(ScrollBarsConstants* pValue);
	/// \brief <em>Sets the \c ScrollBars property</em>
	///
	/// Sets the scrollbars to show if necessary. Any of the values defined by the \c ScrollBarsConstants
	/// enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \attention Changing this property may destroy and recreate the control window.
	///
	/// \if UNICODE
	///   \sa get_ScrollBars, Raise_BeforeScroll, Raise_AfterScroll, ExLVwLibU::ScrollBarsConstants
	/// \else
	///   \sa get_ScrollBars, Raise_BeforeScroll, Raise_AfterScroll, ExLVwLibA::ScrollBarsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ScrollBars(ScrollBarsConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c SelectedColumn property</em>
	///
	/// Retrieves the control's selected column. The selected column is highlighted.
	///
	/// \param[out] ppSelectedColumn Receives the selected column's \c IListViewColumn implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa putref_SelectedColumn, get_SelectedColumnBackColor, get_CaretColumn,
	///     ListViewColumn::get_Selected, ListViewColumn::get_SortArrow, get_View
	virtual HRESULT STDMETHODCALLTYPE get_SelectedColumn(IListViewColumn** ppSelectedColumn);
	/// \brief <em>Sets the \c SelectedColumn property</em>
	///
	/// Sets the control's selected column. The selected column is highlighted.
	///
	/// \param[in] pNewSelectedColumn The new selected column's \c IListViewColumn implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_SelectedColumn, put_SelectedColumnBackColor, putref_CaretColumn,
	///     ListViewColumn::get_Selected, ListViewColumn::put_SortArrow, put_View
	virtual HRESULT STDMETHODCALLTYPE putref_SelectedColumn(IListViewColumn* pNewSelectedColumn);
	/// \brief <em>Retrieves the current setting of the \c SelectedColumnBackColor property</em>
	///
	/// Retrieves the background color of the control's selected column. If set to -1, the system's default
	/// is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_SelectedColumnBackColor, get_SelectedColumn, get_BackColor, get_ForeColor
	virtual HRESULT STDMETHODCALLTYPE get_SelectedColumnBackColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c SelectedColumnBackColor property</em>
	///
	/// Sets the background color of the control's selected column. If set to -1, the system's default
	/// is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_SelectedColumnBackColor, putref_SelectedColumn, put_BackColor, put_ForeColor
	virtual HRESULT STDMETHODCALLTYPE put_SelectedColumnBackColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowDragImage property</em>
	///
	/// Retrieves whether the drag image is visible or hidden. If set to \c VARIANT_TRUE, it is visible;
	/// otherwise hidden.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ShowDragImage, get_hDragImageList, get_SupportOLEDragImages, Raise_DragMouseMove,
	///     Raise_HeaderDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE get_ShowDragImage(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowDragImage property</em>
	///
	/// Sets whether the drag image is visible or hidden. If set to \c VARIANT_TRUE, it is visible; otherwise
	/// hidden.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ShowDragImage, get_hDragImageList, put_SupportOLEDragImages, Raise_DragMouseMove,
	///     Raise_HeaderDragMouseMove
	virtual HRESULT STDMETHODCALLTYPE put_ShowDragImage(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowFilterBar property</em>
	///
	/// Retrieves whether the contained header control contains a filter bar in 'Details' view. If set to
	/// \c VARIANT_TRUE, it contains a filter bar; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa put_ShowFilterBar, get_hWndHeader, get_View, ListViewColumn::get_Filter
	virtual HRESULT STDMETHODCALLTYPE get_ShowFilterBar(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowFilterBar property</em>
	///
	/// Sets whether the contained header control contains a filter bar in 'Details' view. If set to
	/// \c VARIANT_TRUE, it contains a filter bar; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa get_ShowFilterBar, get_hWndHeader, put_View, ListViewColumn::put_Filter
	virtual HRESULT STDMETHODCALLTYPE put_ShowFilterBar(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowGroups property</em>
	///
	/// Retrieves whether the control organizes its items in groups. If set to \c VARIANT_TRUE, item groups
	/// are drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The 'List' view doesn't support groups.\n
	///          This property should be set to \c VARIANT_FALSE if \c ItemAlignment is set to \c iaLeft.\n
	///          This property should be set to \c VARIANT_FALSE if you want to use working areas.\n
	///          Requires comctl32.dll version 6.00 or higher.
	///
	/// \sa put_ShowGroups, get_Groups, get_View, get_ItemAlignment, get_WorkAreas, ListViewItem::get_Group
	virtual HRESULT STDMETHODCALLTYPE get_ShowGroups(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowGroups property</em>
	///
	/// Sets whether the control organizes its items in groups. If set to \c VARIANT_TRUE, item groups are
	/// drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The 'List' view doesn't support groups.\n
	///          Requires comctl32.dll version 6.00 or higher.
	///
	/// \sa get_ShowGroups, get_Groups, put_View, ListViewItem::putref_Group
	virtual HRESULT STDMETHODCALLTYPE put_ShowGroups(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowHeaderChevron property</em>
	///
	/// Retrieves whether the control's header control displays a chevron button if the column headers are
	/// wider than the control and therefore can't be displayed all together. If set to \c VARIANT_TRUE, a
	/// chevron is drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_ShowHeaderChevron, GetHeaderChevronRectangle, ListViewColumn::get_Width,
	///     Raise_HeaderChevronClick
	virtual HRESULT STDMETHODCALLTYPE get_ShowHeaderChevron(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowHeaderChevron property</em>
	///
	/// Sets whether the control's header control displays a chevron button if the column headers are
	/// wider than the control and therefore can't be displayed all together. If set to \c VARIANT_TRUE, a
	/// chevron is drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_ShowHeaderChevron, GetHeaderChevronRectangle, ListViewColumn::put_Width,
	///     Raise_HeaderChevronClick
	virtual HRESULT STDMETHODCALLTYPE put_ShowHeaderChevron(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowHeaderStateImages property</em>
	///
	/// Retrieves whether the control draws a state image (usually a checkbox) to the left of each column
	/// header's caption. If set to \c VARIANT_TRUE, the state images are drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c CheckItemOnSelect property overriddes this property. If \c CheckItemOnSelect is set
	///          to \c VARIANT_TRUE, \c ShowHeaderStateImages is also set to \c VARIANT_TRUE automatically.
	///          After \c CheckItemOnSelect has been changed from \c VARIANT_FALSE to \c VARIANT_TRUE,
	///          \c ShowHeaderStateImages can't be set to \c VARIANT_TRUE alone until the control window is
	///          recreated.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_ShowHeaderStateImages, get_hImageList, ListViewColumn::get_StateImageIndex,
	///     get_ShowStateImages, get_CheckItemOnSelect
	virtual HRESULT STDMETHODCALLTYPE get_ShowHeaderStateImages(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowHeaderStateImages property</em>
	///
	/// Sets whether the control draws a state image (usually a checkbox) to the left of each column
	/// header's caption. If set to \c VARIANT_TRUE, the state images are drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c CheckItemOnSelect property overriddes this property. If \c CheckItemOnSelect is set
	///          to \c VARIANT_TRUE, \c ShowHeaderStateImages is also set to \c VARIANT_TRUE automatically.
	///          After \c CheckItemOnSelect has been changed from \c VARIANT_FALSE to \c VARIANT_TRUE,
	///          \c ShowHeaderStateImages can't be set to \c VARIANT_TRUE alone until the control window is
	///          recreated.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_ShowHeaderStateImages, put_hImageList, ListViewColumn::put_StateImageIndex,
	///     put_ShowStateImages, put_CheckItemOnSelect
	virtual HRESULT STDMETHODCALLTYPE put_ShowHeaderStateImages(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowStateImages property</em>
	///
	/// Retrieves whether the control draws a state image (usually a checkbox) to the left of each item.
	/// If set to \c VARIANT_TRUE, the state images are drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With comctl32.dll version 6.0 state images aren't fully supported in 'Tiles' view, i. e. you
	///          can't toggle them using the mouse.
	///
	/// \sa put_ShowStateImages, get_hImageList, ListViewItem::get_StateImageIndex, get_SimpleSelect,
	///     get_CheckItemOnSelect, get_ShowHeaderStateImages
	virtual HRESULT STDMETHODCALLTYPE get_ShowStateImages(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowStateImages property</em>
	///
	/// Sets whether the control draws a state image (usually a checkbox) to the left of each item. If set to
	/// \c VARIANT_TRUE, the state images are drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With comctl32.dll version 6.0 state images aren't fully supported in 'Tiles' view, i. e. you
	///          can't toggle them using the mouse.
	///
	/// \sa get_ShowStateImages, put_hImageList, ListViewItem::put_StateImageIndex, put_SimpleSelect,
	///     put_CheckItemOnSelect, put_ShowHeaderStateImages, put_View
	virtual HRESULT STDMETHODCALLTYPE put_ShowStateImages(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c ShowSubItemImages property</em>
	///
	/// Retrieves whether the control draws icons for sub-items in 'Details' view. If set to \c VARIANT_TRUE,
	/// sub-item images are drawn; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_ShowSubItemImages, get_hImageList, ListViewSubItem::get_IconIndex, get_View
	virtual HRESULT STDMETHODCALLTYPE get_ShowSubItemImages(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c ShowSubItemImages property</em>
	///
	/// Sets whether the control draws icons for sub-items in 'Details' view. If set to \c VARIANT_TRUE,
	/// sub-item images are drawn; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_ShowSubItemImages, put_hImageList, ListViewSubItem::put_IconIndex, put_View
	virtual HRESULT STDMETHODCALLTYPE put_ShowSubItemImages(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c SimpleSelect property</em>
	///
	/// Retrieves whether pressing the spacebar changes the state image for all selected items or only for
	/// the item that has the focus. If set to \c VARIANT_TRUE, all selected items, otherwise only the
	/// focused item will be updated.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_SimpleSelect, get_ShowStateImages, get_hImageList, get_MultiSelect
	virtual HRESULT STDMETHODCALLTYPE get_SimpleSelect(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c SimpleSelect property</em>
	///
	/// Sets whether pressing the spacebar changes the state image for all selected items or only for
	/// the item that has the focus. If set to \c VARIANT_TRUE, all selected items, otherwise only the
	/// focused item will be updated.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If this property is set to \c VARIANT_TRUE and the state image is toggled using the
	///          keyboard, the state image will be updated for all selected items, but the
	///          \c ItemStateImageChanging and \c ItemStateImageChanged events will be raised for the
	///          caret item only.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_SimpleSelect, put_ShowStateImages, put_hImageList, put_MultiSelect,
	///     Raise_ItemStateImageChanging, Raise_ItemStateImageChanged
	virtual HRESULT STDMETHODCALLTYPE put_SimpleSelect(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c SingleRow property</em>
	///
	/// Retrieves whether items are arranged in a single row or column (depending on the setting for the
	/// \c ItemAlignment property) in 'Icons' and 'Small Icons' view. If set to \c VARIANT_TRUE, a single,
	/// otherwise multiple rows/columns are used to display the items.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_SingleRow, get_ItemAlignment, get_View
	virtual HRESULT STDMETHODCALLTYPE get_SingleRow(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c SingleRow property</em>
	///
	/// Sets whether items are arranged in a single row or column (depending on the setting for the
	/// \c ItemAlignment property) in 'Icons' and 'Small Icons' view. If set to \c VARIANT_TRUE, a single,
	/// otherwise multiple rows/columns are used to display the items.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_SingleRow, put_ItemAlignment, put_View
	virtual HRESULT STDMETHODCALLTYPE put_SingleRow(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c SnapToGrid property</em>
	///
	/// Retrieves whether items are automatically snapped to the nearest grid position in 'Icons',
	/// 'Small Icons', 'Tiles' and 'Extended Tiles' view. If set to \c VARIANT_TRUE, items are snapped to the
	/// nearest grid position; otherwise they can be positioned freely (if the \c AutoArrangeItems property
	/// is not set to \c aaiNormal).
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_SnapToGrid, get_AutoArrangeItems, get_View, ArrangeItems, ListViewItem::SetPosition
	virtual HRESULT STDMETHODCALLTYPE get_SnapToGrid(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c SnapToGrid property</em>
	///
	/// Sets whether items are automatically snapped to the nearest grid position in 'Icons',
	/// 'Small Icons', 'Tiles' and 'Extended Tiles' view. If set to \c VARIANT_TRUE, items are snapped to the
	/// nearest grid position; otherwise they can be positioned freely (if the \c AutoArrangeItems property
	/// is not set to \c aaiNormal).
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_SnapToGrid, put_AutoArrangeItems, put_View, ArrangeItems, ListViewItem::SetPosition
	virtual HRESULT STDMETHODCALLTYPE put_SnapToGrid(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c SortOrder property</em>
	///
	/// Retrieves the direction items are sorted in. Any of the values defined by the \c SortOrderConstants
	/// enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_SortOrder, SortItems, Raise_ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa put_SortOrder, SortItems, Raise_ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibA::SortOrderConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_SortOrder(SortOrderConstants* pValue);
	/// \brief <em>Sets the \c SortOrder property</em>
	///
	/// Sets the direction items are sorted in. Any of the values defined by the \c SortOrderConstants
	/// enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_SortOrder, SortItems, Raise_ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa get_SortOrder, SortItems, Raise_ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibA::SortOrderConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_SortOrder(SortOrderConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c SupportOLEDragImages property</em>
	///
	/// Retrieves whether the control creates \c IDropTargetHelper and \c IDragSourceHelper objects, so
	/// that a drag image can be shown during OLE drag'n'drop. If set to \c VARIANT_TRUE, the control
	/// creates the objects; otherwise not.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires shell32.dll version 5.0 or higher.
	///
	/// \sa put_SupportOLEDragImages, get_RegisterForOLEDragDrop, get_hImageList, get_ShowDragImage,
	///     get_OLEDragImageStyle, get_HeaderOLEDragImageStyle, FinishOLEDragDrop,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646441.aspx">IDragSourceHelper</a>
	virtual HRESULT STDMETHODCALLTYPE get_SupportOLEDragImages(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c SupportOLEDragImages property</em>
	///
	/// Sets whether the control creates \c IDropTargetHelper and \c IDragSourceHelper objects, so
	/// that a drag image can be shown during OLE drag'n'drop. If set to \c VARIANT_TRUE, the control
	/// creates the objects; otherwise not.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires shell32.dll version 5.0 or higher.
	///
	/// \sa get_SupportOLEDragImages, put_RegisterForOLEDragDrop, put_hImageList, put_ShowDragImage,
	///     put_OLEDragImageStyle, put_HeaderOLEDragImageStyle, FinishOLEDragDrop,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646441.aspx">IDragSourceHelper</a>
	virtual HRESULT STDMETHODCALLTYPE put_SupportOLEDragImages(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the name(s) of the control's tester(s)</em>
	///
	/// Retrieves the name(s) of the control's tester(s). This property is part of the fingerprint
	/// that uniquely identifies each software written by Timo "TimoSoft" Kunze.
	///
	/// \param[out] pValue The name(s) of the tester(s).
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is hidden and read-only.
	///
	/// \sa get_AppID, get_AppName, get_AppShortName, get_Build, get_CharSet, get_IsRelease,
	///     get_Programmer
	virtual HRESULT STDMETHODCALLTYPE get_Tester(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c TextBackColor property</em>
	///
	/// Retrieves the item labels' background color. If set to \c CLR_NONE, the item labels are transparent.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_TextBackColor, get_ForeColor, get_BackColor, get_BkImage, get_HideLabels
	virtual HRESULT STDMETHODCALLTYPE get_TextBackColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c TextBackColor property</em>
	///
	/// Sets the item labels' background color. If set to \c CLR_NONE, the item labels are transparent.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_TextBackColor, put_ForeColor, put_BackColor, put_BkImage, put_HideLabels
	virtual HRESULT STDMETHODCALLTYPE put_TextBackColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewItemLines property</em>
	///
	/// Retrieves the number of lines with additional details that are displayed in 'Tiles' and 'Extended
	/// Tiles' view for each item.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewItemLines, get_View, get_TileViewTileHeight, get_TileViewTileWidth,
	///     ListViewItem::get_TileViewColumns
	virtual HRESULT STDMETHODCALLTYPE get_TileViewItemLines(LONG* pValue);
	/// \brief <em>Sets the \c TileViewItemLines property</em>
	///
	/// Sets the number of lines with additional details that are displayed in 'Tiles' and 'Extended
	/// Tiles' view for each item.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewItemLines, put_View, put_TileViewTileHeight, put_TileViewTileWidth,
	///     ListViewItem::put_TileViewColumns
	virtual HRESULT STDMETHODCALLTYPE put_TileViewItemLines(LONG newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewLabelMarginBottom property</em>
	///
	/// Retrieves the bottom margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewLabelMarginBottom, get_TileViewLabelMarginLeft, get_TileViewLabelMarginRight,
	///     get_TileViewLabelMarginTop, get_TileViewTileHeight, get_TileViewTileWidth, get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewLabelMarginBottom(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewLabelMarginBottom property</em>
	///
	/// Sets the bottom margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewLabelMarginBottom, put_TileViewLabelMarginLeft, put_TileViewLabelMarginRight,
	///     put_TileViewLabelMarginTop, put_TileViewTileHeight, put_TileViewTileWidth, put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewLabelMarginBottom(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewLabelMarginLeft property</em>
	///
	/// Retrieves the left margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewLabelMarginLeft, get_TileViewLabelMarginBottom, get_TileViewLabelMarginRight,
	///     get_TileViewLabelMarginTop, get_TileViewTileHeight, get_TileViewTileWidth, get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewLabelMarginLeft(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewLabelMarginLeft property</em>
	///
	/// Sets the left margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewLabelMarginLeft, put_TileViewLabelMarginBottom, put_TileViewLabelMarginRight,
	///     put_TileViewLabelMarginTop, put_TileViewTileHeight, put_TileViewTileWidth, put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewLabelMarginLeft(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewLabelMarginRight property</em>
	///
	/// Retrieves the right margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewLabelMarginRight, get_TileViewLabelMarginBottom, get_TileViewLabelMarginLeft,
	///     get_TileViewLabelMarginTop, get_TileViewTileHeight, get_TileViewTileWidth, get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewLabelMarginRight(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewLabelMarginRight property</em>
	///
	/// Sets the right margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewLabelMarginRight, put_TileViewLabelMarginBottom, put_TileViewLabelMarginLeft,
	///     put_TileViewLabelMarginTop, put_TileViewTileHeight, put_TileViewTileWidth, put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewLabelMarginRight(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewLabelMarginTop property</em>
	///
	/// Retrieves the top margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewLabelMarginTop, get_TileViewLabelMarginBottom, get_TileViewLabelMarginLeft,
	///     get_TileViewLabelMarginRight, get_TileViewTileHeight, get_TileViewTileWidth, get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewLabelMarginTop(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewLabelMarginTop property</em>
	///
	/// Sets the top margin (in pixels) of the control's item labels in 'Tiles' and 'Extended Tiles'
	/// view.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewLabelMarginTop, put_TileViewLabelMarginBottom, put_TileViewLabelMarginLeft,
	///     put_TileViewLabelMarginRight, put_TileViewTileHeight, put_TileViewTileWidth, put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewLabelMarginTop(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewSubItemForeColor property</em>
	///
	/// Retrieves the text color of the sub-items in 'Tiles' and 'Extended Tiles' view. If set to -1, the
	/// system's default is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_TileViewSubItemForeColor, get_ForeColor, get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewSubItemForeColor(OLE_COLOR* pValue);
	/// \brief <em>Sets the \c TileViewSubItemForeColor property</em>
	///
	/// Sets the text color of the sub-items in 'Tiles' and 'Extended Tiles' view. If set to -1, the
	/// system's default is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_TileViewSubItemForeColor, put_ForeColor, put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewSubItemForeColor(OLE_COLOR newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewTileHeight property</em>
	///
	/// Retrieves the height (in pixels) of the control's tiles in 'Tiles' and 'Extended Tiles' view. If set
	/// to -1, the tiles' height is set to a value calculated automatically.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property must be set to -1 for the 'Extended Tiles' view.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewTileHeight, get_TileViewTileWidth, get_TileViewLabelMarginBottom,
	///     get_TileViewLabelMarginLeft, get_TileViewLabelMarginRight, get_TileViewLabelMarginTop,
	///     get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewTileHeight(OLE_YSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewTileHeight property</em>
	///
	/// Sets the height (in pixels) of the control's tiles in 'Tiles' and 'Extended Tiles' view. If set
	/// to -1, the tiles' height is set to a value calculated automatically.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property must be set to -1 for the 'Extended Tiles' view.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewTileHeight, put_TileViewTileWidth, put_TileViewLabelMarginBottom,
	///     put_TileViewLabelMarginLeft, put_TileViewLabelMarginRight, put_TileViewLabelMarginTop,
	///     put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewTileHeight(OLE_YSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c TileViewTileWidth property</em>
	///
	/// Retrieves the width (in pixels) of the control's tiles in 'Tiles' and 'Extended Tiles' view. If set
	/// to -1, the tiles' width is set to a value calculated automatically.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property must be set to -1 for the 'Extended Tiles' view.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_TileViewTileWidth, get_TileViewTileHeight, get_TileViewLabelMarginBottom,
	///     get_TileViewLabelMarginLeft, get_TileViewLabelMarginRight, get_TileViewLabelMarginTop,
	///     get_View
	virtual HRESULT STDMETHODCALLTYPE get_TileViewTileWidth(OLE_XSIZE_PIXELS* pValue);
	/// \brief <em>Sets the \c TileViewTileWidth property</em>
	///
	/// Sets the width (in pixels) of the control's tiles in 'Tiles' and 'Extended Tiles' view. If set
	/// to -1, the tiles' width is set to a value calculated automatically.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property must be set to -1 for the 'Extended Tiles' view.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa get_TileViewTileWidth, put_TileViewTileHeight, put_TileViewLabelMarginBottom,
	///     put_TileViewLabelMarginLeft, put_TileViewLabelMarginRight, put_TileViewLabelMarginTop,
	///     put_View
	virtual HRESULT STDMETHODCALLTYPE put_TileViewTileWidth(OLE_XSIZE_PIXELS newValue);
	/// \brief <em>Retrieves the current setting of the \c ToolTips property</em>
	///
	/// Retrieves which kinds of tooltips the control is displaying. Any combination of the values
	/// defined by the \c ToolTipsConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_ToolTips, get_hWndToolTip, Raise_ItemGetInfoTipText, ExLVwLibU::ToolTipsConstants
	/// \else
	///   \sa put_ToolTips, get_hWndToolTip, Raise_ItemGetInfoTipText, ExLVwLibA::ToolTipsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_ToolTips(ToolTipsConstants* pValue);
	/// \brief <em>Sets the \c ToolTips property</em>
	///
	/// Sets which kinds of tooltips the control is displaying. Any combination of the values
	/// defined by the \c ToolTipsConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ToolTips, put_hWndToolTip, Raise_ItemGetInfoTipText, ExLVwLibU::ToolTipsConstants
	/// \else
	///   \sa get_ToolTips, put_hWndToolTip, Raise_ItemGetInfoTipText, ExLVwLibA::ToolTipsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_ToolTips(ToolTipsConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c UnderlinedItems property</em>
	///
	/// Retrieves which items are drawn underlined. Any combination of the values defined by the
	/// \c UnderlinedItemsConstants enumeration is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_UnderlinedItems, get_ItemActivationMode, get_HotTracking,
	///       ExLVwLibU::UnderlinedItemsConstants
	/// \else
	///   \sa put_UnderlinedItems, get_ItemActivationMode, get_HotTracking,
	///       ExLVwLibA::UnderlinedItemsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_UnderlinedItems(UnderlinedItemsConstants* pValue);
	/// \brief <em>Sets the \c UnderlinedItems property</em>
	///
	/// Sets which items are drawn underlined. Any combination of the values defined by the
	/// \c UnderlinedItemsConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_UnderlinedItems, put_ItemActivationMode, put_HotTracking,
	///       ExLVwLibU::UnderlinedItemsConstants
	/// \else
	///   \sa get_UnderlinedItems, put_ItemActivationMode, put_HotTracking,
	///       ExLVwLibA::UnderlinedItemsConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_UnderlinedItems(UnderlinedItemsConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c UseMinColumnWidths property</em>
	///
	/// Retrieves whether the control applies the minimum column widths specified by the
	/// \c IListViewColumn::MinimumWidth property. If set to \c VARIANT_TRUE, the user can't resize a column
	/// to a width smaller than the column's minimum width; otherwise the user can do so.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If this property is set to \c True, it won't be possible to resize any column to a width
	///          of 0. The minimum column width will be 30 pixels then. This is a limitation of the native
	///          list view control.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa put_UseMinColumnWidths, ListViewColumn::get_MinimumWidth, ListViewColumn::get_Width,
	///     ListViewColumn::get_Resizable, get_ResizableColumns
	virtual HRESULT STDMETHODCALLTYPE get_UseMinColumnWidths(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c UseMinColumnWidths property</em>
	///
	/// Sets whether the control applies the minimum column widths specified by the
	/// \c IListViewColumn::MinimumWidth property. If set to \c VARIANT_TRUE, the user can't resize a column
	/// to a width smaller than the column's minimum width; otherwise the user can do so.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If this property is set to \c True, it won't be possible to resize any column to a width
	///          of 0. The minimum column width will be 30 pixels then. This is a limitation of the native
	///          list view control.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_UseMinColumnWidths, ListViewColumn::put_MinimumWidth, ListViewColumn::put_Width,
	///     ListViewColumn::put_Resizable, put_ResizableColumns
	virtual HRESULT STDMETHODCALLTYPE put_UseMinColumnWidths(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c UseSystemFont property</em>
	///
	/// Retrieves whether the control uses the system's default listview font or the font specified by the
	/// \c Font property. If set to \c VARIANT_TRUE, the system font; otherwise the specified font is used.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_UseSystemFont, get_Font
	virtual HRESULT STDMETHODCALLTYPE get_UseSystemFont(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c UseSystemFont property</em>
	///
	/// Sets whether the control uses the system's default listview font or the font specified by the
	/// \c Font property. If set to \c VARIANT_TRUE, the system font; otherwise the specified font is used.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_UseSystemFont, put_Font, putref_Font
	virtual HRESULT STDMETHODCALLTYPE put_UseSystemFont(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c UseWorkAreas property</em>
	///
	/// Retrieves how the control arranges its items, if the \c AutoArrangeItems property is not set to
	/// \c aaiNormal. If \c UseWorkAreas is set to \c VARIANT_TRUE, the items won't be auto-arranged before
	/// at least one working area is defined; otherwise they will be auto-arranged immediately.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_UseWorkAreas, get_AutoArrangeItems, get_WorkAreas
	virtual HRESULT STDMETHODCALLTYPE get_UseWorkAreas(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c UseWorkAreas property</em>
	///
	/// Sets how the control arranges its items, if the \c AutoArrangeItems property is set not to
	/// \c aaiNormal. If \c UseWorkAreas is set to \c VARIANT_TRUE, the items won't be auto-arranged before
	/// at least one working area is defined; otherwise they will be auto-arranged immediately.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_UseWorkAreas, put_AutoArrangeItems, get_WorkAreas
	virtual HRESULT STDMETHODCALLTYPE put_UseWorkAreas(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the control's version</em>
	///
	/// \param[out] pValue The control's version.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This property is read-only.
	virtual HRESULT STDMETHODCALLTYPE get_Version(BSTR* pValue);
	/// \brief <em>Retrieves the current setting of the \c View property</em>
	///
	/// Retrieves the control's view mode. Any of the values defined by the \c ViewConstants enumeration
	/// is valid.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Changing the view mode to 'Extended Tiles' resets any sub-items.
	///
	/// \if UNICODE
	///   \sa put_View, get_FullRowSelect, get_GridLines, get_Columns, get_Groups, get_WorkAreas,
	///       ExLVwLibU::ViewConstants
	/// \else
	///   \sa put_View, get_FullRowSelect, get_GridLines, get_Columns, get_Groups, get_WorkAreas,
	///       ExLVwLibA::ViewConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE get_View(ViewConstants* pValue);
	/// \brief <em>Sets the \c View property</em>
	///
	/// Sets the control's view mode. Any of the values defined by the \c ViewConstants enumeration is valid.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Changing the view mode to 'Extended Tiles' resets any sub-items.
	///
	/// \if UNICODE
	///   \sa get_View, put_FullRowSelect, put_GridLines, ExLVwLibU::ViewConstants
	/// \else
	///   \sa get_View, put_FullRowSelect, put_GridLines, ExLVwLibA::ViewConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE put_View(ViewConstants newValue);
	/// \brief <em>Retrieves the current setting of the \c VirtualItemCount property</em>
	///
	/// Retrieves the number of items in the control if the \c VirtualMode property is set to
	/// \c VARIANT_TRUE.
	///
	/// \param[in] noScroll Ignored.
	/// \param[in] noInvalidateAll Ignored.
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa put_VirtualItemCount, get_VirtualMode
	virtual HRESULT STDMETHODCALLTYPE get_VirtualItemCount(VARIANT_BOOL noScroll = VARIANT_FALSE, VARIANT_BOOL noInvalidateAll = VARIANT_TRUE, LONG* pValue = NULL);
	/// \brief <em>Sets the \c VirtualItemCount property</em>
	///
	/// Sets the number of items in the control if the \c VirtualMode property is set to \c VARIANT_TRUE.
	///
	/// \param[in] noScroll If set to \c VARIANT_TRUE, the control won't change the scrolling position when
	///            changing this property. Otherwise it will reset the scrolling position.
	/// \param[in] noInvalidateAll If set to \c VARIANT_TRUE, the control will repaint only if changing
	///            this property affects the items currently in view. Otherwise it will definitely repaint.
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_VirtualItemCount, put_VirtualMode
	virtual HRESULT STDMETHODCALLTYPE put_VirtualItemCount(VARIANT_BOOL noScroll = VARIANT_FALSE, VARIANT_BOOL noInvalidateAll = VARIANT_TRUE, LONG newValue = 0);
	/// \brief <em>Retrieves the current setting of the \c VirtualMode property</em>
	///
	/// Retrieves whether the data-management for the control is done by the client or by the control itself.
	/// If set to \c VARIANT_TRUE, data-management is done by the client; otherwise it's done by the control.
	///
	/// \param[out] pValue The property's current setting.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Using virtual mode may increase performance, especially if the listview contains many
	///          items. However, virtual listview controls have several limitations:\n
	///          - 'Tiles' view is not fully supported.
	///          - 'Extended Tiles' view is not supported.
	///          - Groups are not supported.
	///          - Working areas are not supported.
	///          - Item sorting is not supported.
	///          - Clicks on state images won't be recognized in 'Icons', 'Small Icons' and 'Tiles' view.
	///          - \c ListViewItem::put_IconIndex is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewSubItem::put_IconIndex is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::get_ID is not supported.
	///          - \c ListViewItem::put_Indent is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::get_ItemData and \c ListViewItem::put_ItemData are not supported.
	///          - \c ListViewItem::put_OverlayIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewSubItem::put_OverlayIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewItem::put_StateImageIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewSubItem::put_StateImageIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewItem::put_Text is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewSubItem::put_Text is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::put_TileViewColumns is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///
	/// \sa put_VirtualMode, get_VirtualItemCount, get_ShowGroups, get_CallBackMask, Raise_CacheItemsHint,
	///     Raise_ItemGetDisplayInfo, Raise_SelectedItemRange, Raise_FindVirtualItem
	virtual HRESULT STDMETHODCALLTYPE get_VirtualMode(VARIANT_BOOL* pValue);
	/// \brief <em>Sets the \c VirtualMode property</em>
	///
	/// Sets whether the data-management for the control is done by the client or by the control itself.
	/// If set to \c VARIANT_TRUE, data-management is done by the client; otherwise it's done by the control.
	///
	/// \param[in] newValue The setting to apply.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Using virtual mode may increase performance, especially if the listview contains many
	///          items. However, virtual listview controls have several limitations:\n
	///          - 'Tiles' view is not fully supported.
	///          - 'Extended Tiles' view is not supported.
	///          - Groups are not supported.
	///          - Working areas are not supported.
	///          - Item sorting is not supported.
	///          - Clicks on state images won't be recognized in 'Icons', 'Small Icons' and 'Tiles' view.
	///          - \c ListViewItem::put_IconIndex is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewSubItem::put_IconIndex is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::get_ID is not supported.
	///          - \c ListViewItem::put_Indent is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::get_ItemData and \c ListViewItem::put_ItemData are not supported.
	///          - \c ListViewItem::put_OverlayIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewSubItem::put_OverlayIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewItem::put_StateImageIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewSubItem::put_StateImageIndex is not supported. The client has to use the
	///            \c CallBackMask property and the \c _IExplorerListViewEvents::ItemGetDisplayInfo event
	///            instead.
	///          - \c ListViewItem::put_Text is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewSubItem::put_Text is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///          - \c ListViewItem::put_TileViewColumns is not supported. The client has to use the
	///            \c _IExplorerListViewEvents::ItemGetDisplayInfo event instead.
	///
	/// \attention Changing this property destroys and recreates the control window.
	///
	/// \sa get_VirtualMode, put_VirtualItemCount, put_ShowGroups, put_CallBackMask, Raise_CacheItemsHint,
	///     Raise_ItemGetDisplayInfo, Raise_SelectedItemRange, Raise_FindVirtualItem
	virtual HRESULT STDMETHODCALLTYPE put_VirtualMode(VARIANT_BOOL newValue);
	/// \brief <em>Retrieves the current setting of the \c WorkAreas property</em>
	///
	/// Retrieves a collection object wrapping the control's working areas.
	///
	/// \param[out] ppWorkAreas Receives the collection object's \c IListViewWorkAreas implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The 'List' and 'Details' views don't support working areas.\n
	///          Working areas can't be used together with groups.\n
	///          This property is read-only.
	///
	/// \sa get_View, get_ShowGroups, get_AutoArrangeItems, get_UseWorkAreas, ListViewWorkAreas,
	///     ListViewItem::get_WorkArea
	virtual HRESULT STDMETHODCALLTYPE get_WorkAreas(IListViewWorkAreas** ppWorkAreas);

	/// \brief <em>Displays the control's credits</em>
	///
	/// Displays some information about this control and its author.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa AboutDlg
	virtual HRESULT STDMETHODCALLTYPE About(void);
	/// \brief <em>Approximates the listview's optimal size</em>
	///
	/// Calculates the control's approximate width and height required to display the specified number of
	/// items. Setting the size of the control based on the dimensions provided by this method can optimize
	/// redraw and reduce flicker.
	///
	/// \param[in] numberOfItems The number of items to be displayed in the control. If set to -1, the
	///            control's total number of items is used.
	/// \param[in,out] pProposedWidth The approximated width (in pixels) needed to display the items. If
	///                set to -1 on entry, the control's current width will be used as base to calculate
	///                the optimal width.
	/// \param[in,out] pProposedHeight The approximated height (in pixels) needed to display the items. If
	///                set to -1 on entry, the control's current height will be used as base to calculate
	///                the optimal height.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetViewRectangle
	virtual HRESULT STDMETHODCALLTYPE ApproximateViewRectangle(LONG numberOfItems = -1, OLE_XSIZE_PIXELS* pProposedWidth = NULL, OLE_YSIZE_PIXELS* pProposedHeight = NULL);
	/// \brief <em>Arranges the listview's items</em>
	///
	/// Arranges the control's items in 'Icons', 'Small Icons', 'Tiles' or 'Extended Tiles' view.
	///
	/// \param[in] arrangementStyle Specifies how the items will be arranged. Any of the values defined by
	///            the \c ArrangementStyleConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_AutoArrangeItems, get_SnapToGrid, get_View, ListViewItem::SetPosition,
	///       ExLVwLibU::ArrangementStyleConstants
	/// \else
	///   \sa get_AutoArrangeItems, get_SnapToGrid, get_View, ListViewItem::SetPosition,
	///       ExLVwLibA::ArrangementStyleConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE ArrangeItems(ArrangementStyleConstants arrangementStyle = astDefault);
	/// \brief <em>Enters drag'n'drop mode</em>
	///
	/// \param[in] pDraggedItems The dragged items collection object's \c IListViewItemContainer
	///            implementation.
	/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
	///            visualize the drag'n'drop operation. If -1, the method creates the drag image itself;
	///            if \c NULL, no drag image is used.
	/// \param[in,out] pXHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
	///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
	///                \c NULL, this parameter is ignored. This parameter will be changed to the value that
	///                finally was used by the method.
	/// \param[in,out] pYHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
	///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
	///                \c NULL, this parameter is ignored. This parameter will be changed to the value that
	///                finally was used by the method.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa OLEDrag, get_DraggedItems, EndDrag, HeaderBeginDrag, get_hDragImageList, Raise_ItemBeginDrag,
	///     Raise_ItemBeginRDrag, ListViewItem::CreateDragImage, ListViewItemContainer::CreateDragImage
	virtual HRESULT STDMETHODCALLTYPE BeginDrag(IListViewItemContainer* pDraggedItems, OLE_HANDLE hDragImageList = NULL, OLE_XPOS_PIXELS* pXHotSpot = NULL, OLE_YPOS_PIXELS* pYHotSpot = NULL);
	/// \brief <em>Calculates the maximum number of entirely visible items in the listview</em>
	///
	/// Retrieves the number of items that fit entirely into the control's client area.
	///
	/// \param[out] pValue The maximum number of simultaneous visible items.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This method is valid for 'List' and 'Details' view only.
	///
	/// \sa ListViewItems::Count, get_View
	virtual HRESULT STDMETHODCALLTYPE CountVisible(LONG* pValue);
	/// \brief <em>Creates a new \c ListViewItemContainer object</em>
	///
	/// Retrieves a new \c ListViewItemContainer object and fills it with the specified items.
	///
	/// \param[in] items The item(s) to add to the collection. May be either \c Empty, an item ID, a
	///            \c ListViewItem object or a \c ListViewItems collection.
	/// \param[out] ppContainer Receives the new collection object's \c IListViewItemContainer
	///             implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa ListViewItemContainer::Clone, ListViewItemContainer::Add
	virtual HRESULT STDMETHODCALLTYPE CreateItemContainer(VARIANT items = _variant_t(DISP_E_PARAMNOTFOUND, VT_ERROR), IListViewItemContainer** ppContainer = NULL);
	/// \brief <em>Exits drag'n'drop mode</em>
	///
	/// \param[in] abort If \c VARIANT_TRUE, the drag'n'drop operation will be treated as aborted;
	///            otherwise it will be treated as a drop.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_DraggedItems, BeginDrag, HeaderEndDrag, Raise_AbortedDrag, Raise_Drop
	virtual HRESULT STDMETHODCALLTYPE EndDrag(VARIANT_BOOL abort);
	/// \brief <em>Ends label-editing</em>
	///
	/// Ends editing the item's text.
	///
	/// \param[in] discard Specifies whether to apply or discard the text contained by the label-edit
	///            control at the time this method is called. If set to \c VARIANT_TRUE, the text is
	///            discarded and the edited item's text remains the same; otherwise the edited item's
	///            text is changed to the text contained by the label-edit control at the time this
	///            method is called.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa ListViewItem::StartLabelEditing, Raise_RenamedItem, Raise_ItemSetText
	virtual HRESULT STDMETHODCALLTYPE EndLabelEdit(VARIANT_BOOL discard);
	/// \brief <em>Finds an item with the specified characteristics</em>
	///
	/// Retrieves an item with the specified characteristics.
	///
	/// \param[in] searchMode A value specifying the meaning of the \c searchFor parameter. Any of the
	///            values defined by the \c SearchModeConstants enumeration is valid.
	/// \param[in] searchFor The criterion that the item must fulfill to be returned by this method. This
	///            parameter's format depends on the \c searchMode parameter:
	///            - \c smItemData An integer value.
	///            - \c smText A string value.
	///            - \c smPartialText A string value.
	///            - \c smNearestPosition An array containing two integer values. The first one specifies the
	///              x-coordinate, the second one the y-coordinate (both in pixels and relative to the
	///              control's upper-left corner).
	/// \param[in] searchDirection A value specifying the direction to search. Any of the values
	///            defined by the \c SearchDirectionConstants enumeration is valid. This parameter is
	///            ignored if the \c searchFor parameter is not set to \c smNearestPosition.
	/// \param[in] wrapAtLastItem If set to \c VARIANT_TRUE, the search will be continued with the first
	///            item if the last item is reached. This parameter is ignored if \c searchMode is set to
	///            \c smNearestPosition.
	/// \param[out] ppFoundItem Receives the matching item's \c IListViewItem implementation. \c NULL
	///             if no matching item was found.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa ListViewItem::FindNextItem, ExLVwLibU::SearchModeConstants,
	///       ExLVwLibU::SearchDirectionConstants, Raise_FindVirtualItem
	/// \else
	///   \sa ListViewItem::FindNextItem, ExLVwLibA::SearchModeConstants,
	///       ExLVwLibA::SearchDirectionConstants, Raise_FindVirtualItem
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE FindItem(SearchModeConstants searchMode, VARIANT searchFor, SearchDirectionConstants searchDirection = sdNoneSpecific, VARIANT_BOOL wrapAtLastItem = VARIANT_TRUE, IListViewItem** ppFoundItem = NULL);
	/// \brief <em>Finishes a pending drop operation</em>
	///
	/// During a drag'n'drop operation the drag image is displayed until the \c OLEDragDrop (or
	/// \c HeaderOLEDragDrop) event has been handled. This order is intended by Microsoft Windows. However,
	/// if a message box is displayed from within the \c OLEDragDrop (\c HeaderOLEDragDrop) event, or the
	/// drop operation cannot be performed asynchronously and takes a long time, it may be desirable to
	/// remove the drag image earlier.\n
	/// This method will break the intended order and finish the drag'n'drop operation (including removal
	/// of the drag image) immediately.
	///
	/// \remarks This method will fail if not called from the \c OLEDragDrop (\c HeaderOLEDragDrop) event
	///          handler or if no drag images are used.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_OLEDragDrop, Raise_HeaderOLEDragDrop, get_SupportOLEDragImages
	virtual HRESULT STDMETHODCALLTYPE FinishOLEDragDrop(void);
	/// \brief <em>Proposes a position for the control's insertion mark</em>
	///
	/// Retrieves the insertion mark position that is closest to the specified point.
	///
	/// \param[in] x The x-coordinate (in pixels) of the point for which to retrieve the closest
	///            insertion mark position. It must be relative to the control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the point for which to retrieve the closest
	///            insertion mark position. It must be relative to the control's upper-left corner.
	/// \param[out] pRelativePosition The insertion mark's position relative to the specified item. The
	///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
	///             valid: \c impBefore, \c impAfter, \c impNowhere.
	/// \param[out] ppListItem Receives the \c IListViewItem implementation of the item, at which
	///             the insertion mark should be displayed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks An insertion mark can be used only if the control is in 'Icons', 'Small Icons', 'Tiles' or
	///          'Extended Tiles' view, is not in group-view mode, and has \c AutoArrangeItems set to
	///          \c aaiNormal.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa SetInsertMarkPosition, GetInsertMarkPosition, get_AutoArrangeItems, get_ShowGroups, get_View,
	///       ExLVwLibU::InsertMarkPositionConstants
	/// \else
	///   \sa SetInsertMarkPosition, GetInsertMarkPosition, get_AutoArrangeItems, get_ShowGroups, get_View,
	///       ExLVwLibA::InsertMarkPositionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE GetClosestInsertMarkPosition(OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, InsertMarkPositionConstants* pRelativePosition, IListViewItem** ppListItem);
	/// \brief <em>Retrieves the bounding rectangle of the control's footer area</em>
	///
	/// Retrieves the bounding rectangle (in pixels relative to the control's client area) of the control's
	/// footer area.
	///
	/// \param[out] xLeft The x-coordinate (in pixels) of the bounding rectangle's left border
	///             relative to the control's upper-left corner.
	/// \param[out] yTop The y-coordinate (in pixels) of the bounding rectangle's top border
	///             relative to the control's upper-left corner.
	/// \param[out] xRight The x-coordinate (in pixels) of the bounding rectangle's right border
	///             relative to the control's upper-left corner.
	/// \param[out] yBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
	///             relative to the control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa ShowFooter, ListViewFooterItem::GetRectangle
	virtual HRESULT STDMETHODCALLTYPE GetFooterRectangle(OLE_XPOS_PIXELS* pXLeft = NULL, OLE_YPOS_PIXELS* pYTop = NULL, OLE_XPOS_PIXELS* pXRight = NULL, OLE_YPOS_PIXELS* pYBottom = NULL);
	/// \brief <em>Retrieves the bounding rectangle of the column header's chevron button</em>
	///
	/// Retrieves the bounding rectangle (in pixels relative to the control's upper-left corner) of the
	/// column header's chevron button which is displayed if the column headers are wider than the control
	/// and therefore can't be displayed all together.
	///
	/// \param[out] pLeft Receives the x-coordinate (in pixels) of the upper-left corner of the chevron
	///             button's bounding rectangle relative to the header control's upper-left corner.
	/// \param[out] pTop Receives the y-coordinate (in pixels) of the upper-left corner of the chevron
	///             button's bounding rectangle relative to the header control's upper-left corner.
	/// \param[out] pRight Receives the x-coordinate (in pixels) of the lower-right corner of the chevron
	///             button's bounding rectangle relative to the header control's upper-left corner.
	/// \param[out] pBottom Receives the y-coordinate (in pixels) of the lower-right corner of the chevron
	///             button's bounding rectangle relative to the header control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_ShowHeaderChevron
	virtual HRESULT STDMETHODCALLTYPE GetHeaderChevronRectangle(OLE_XPOS_PIXELS* pLeft = NULL, OLE_YPOS_PIXELS* pTop = NULL, OLE_XPOS_PIXELS* pRight = NULL, OLE_YPOS_PIXELS* pBottom = NULL);
	/// \brief <em>Determines the spacing between items in 'Icons' or 'Small Icons' view</em>
	///
	/// Determines an item's width and height (including the space beneath it) in 'Icons' or
	/// 'Small Icons' view in pixels.
	///
	/// \param[in] viewMode The view for which to determine the spacing. The following values,
	///            defined by the \c ViewConstants enumeration, are valid: \c vIcons, \c vSmallIcons.
	/// \param[out] pItemWidth The item's width (including the space beneath it) in pixels.
	/// \param[out] pItemHeight The item's height (including the space beneath it) in pixels.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa SetIconSpacing, get_View, ExLVwLibU::ViewConstants
	/// \else
	///   \sa SetIconSpacing, get_View, ExLVwLibA::ViewConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE GetIconSpacing(ViewConstants viewMode, OLE_XSIZE_PIXELS* pItemWidth = NULL, OLE_YSIZE_PIXELS* pItemHeight = NULL);
	/// \brief <em>Retrieves the position of the control's insertion mark</em>
	///
	/// \param[out] pRelativePosition The insertion mark's position relative to the specified item. The
	///             following values, defined by the \c InsertMarkPositionConstants enumeration, are
	///             valid: \c impBefore, \c impAfter, \c impNowhere.
	/// \param[out] ppListItem Receives the \c IListViewItem implementation of the item, at which the
	///             insertion mark is displayed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks An insertion mark can be used only if the control is in 'Icons', 'Small Icons', 'Tiles' or
	///          'Extended Tiles' view, is not in group-view mode, and has \c AutoArrangeItems set to
	///          \c aaiNormal.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, GetInsertMarkRectangle,
	///       get_AutoArrangeItems, get_ShowGroups, get_View, ExLVwLibU::InsertMarkPositionConstants
	/// \else
	///   \sa SetInsertMarkPosition, GetClosestInsertMarkPosition, GetInsertMarkRectangle,
	///       get_AutoArrangeItems, get_ShowGroups, get_View, ExLVwLibA::InsertMarkPositionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE GetInsertMarkPosition(InsertMarkPositionConstants* pRelativePosition, IListViewItem** ppListItem);
	/// \brief <em>Retrieves the bounding rectangle of the control's insertion mark</em>
	///
	/// \param[out] pXLeft The x-coordinate (in pixels) of the bounding rectangle's left border
	///             relative to the control's upper-left corner.
	/// \param[out] pYTop The y-coordinate (in pixels) of the bounding rectangle's top border
	///             relative to the control's upper-left corner.
	/// \param[out] pXRight The x-coordinate (in pixels) of the bounding rectangle's right border
	///             relative to the control's upper-left corner.
	/// \param[out] pYBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
	///             relative to the control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks An insertion mark can be used only if the control is in 'Icons', 'Small Icons', 'Tiles' or
	///          'Extended Tiles' view, is not in group-view mode, and has \c AutoArrangeItems set to
	///          \c aaiNormal.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa GetInsertMarkPosition, SetInsertMarkPosition, get_AutoArrangeItems, get_ShowGroups, get_View
	virtual HRESULT STDMETHODCALLTYPE GetInsertMarkRectangle(OLE_XPOS_PIXELS* pXLeft = NULL, OLE_YPOS_PIXELS* pYTop = NULL, OLE_XPOS_PIXELS* pXRight = NULL, OLE_YPOS_PIXELS* pYBottom = NULL);
	/// \brief <em>Retrieves the control's current view origin</em>
	///
	/// \param[out] pX The x-coordinate (in pixels) of the view origin relative to the control's upper-left
	///             corner.
	/// \param[out] pY The y-coordinate (in pixels) of the view origin relative to the control's upper-left
	///             corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This method will fail if the control is in 'List' or 'Details' view.
	///
	/// \sa Scroll, GetViewRectangle, get_View
	virtual HRESULT STDMETHODCALLTYPE GetOrigin(OLE_XPOS_PIXELS* pX = NULL, OLE_YPOS_PIXELS* pY = NULL);
	/// \brief <em>Determines the width of the specified string using the control's current font</em>
	///
	/// Determines the width (in pixels) of the specified string using the control's current font.
	///
	/// \param[in] stringToTest The string for which to determine the width.
	/// \param[out] pWidth The string's width in pixels.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa ListViewColumn::put_Width, Raise_CustomDraw
	virtual HRESULT STDMETHODCALLTYPE GetStringWidth(BSTR stringToTest, OLE_XSIZE_PIXELS* pWidth);
	/// \brief <em>Retrieves the bounding rectangle of all items in the control</em>
	///
	/// \param[out] pXLeft The x-coordinate (in pixels) of the bounding rectangle's left border
	///             relative to the control's upper-left corner.
	/// \param[out] pYTop The y-coordinate (in pixels) of the bounding rectangle's top border
	///             relative to the control's upper-left corner.
	/// \param[out] pXRight The x-coordinate (in pixels) of the bounding rectangle's right border
	///             relative to the control's upper-left corner.
	/// \param[out] pYBottom The y-coordinate (in pixels) of the bounding rectangle's bottom border
	///             relative to the control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This method will fail if the control is in 'List' or 'Details' view.
	///
	/// \sa GetOrigin, Scroll, get_View
	virtual HRESULT STDMETHODCALLTYPE GetViewRectangle(OLE_XPOS_PIXELS* pXLeft = NULL, OLE_YPOS_PIXELS* pYTop = NULL, OLE_XPOS_PIXELS* pXRight = NULL, OLE_YPOS_PIXELS* pYBottom = NULL);
	/// \brief <em>Enters drag'n'drop mode</em>
	///
	/// Enters drag'n'drop mode for the header control.
	///
	/// \param[in] pDraggedColumn The column header to drag.
	/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
	///            visualize the drag'n'drop operation. If -1, the method creates the drag image
	///            itself; if \c NULL, no drag image is used.
	/// \param[in,out] pXHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
	///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
	///                \c NULL, this parameter is ignored. This parameter will be changed to the value that
	///                finally was used by the method.
	/// \param[in,out] pYHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
	///                drag image's upper-left corner. If the \c hDragImageList parameter is set to -1 or
	///                \c NULL, this parameter is ignored. This parameter will be changed to the value that
	///                finally was used by the method.
	/// \param[in] restrictDragImage If set to \c VARIANT_TRUE, the drag image will move within the header
	///            control along the x-axis only. If set to \c VARIANT_FALSE, the drag image will be attached
	///            to the mouse cursor and move freely.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa HeaderOLEDrag, get_DraggedColumn, HeaderEndDrag, get_hDragImageList, BeginDrag,
	///     Raise_ColumnBeginDrag, ListViewColumn::CreateDragImage
	virtual HRESULT STDMETHODCALLTYPE HeaderBeginDrag(IListViewColumn* pDraggedColumn, OLE_HANDLE hDragImageList = NULL, OLE_XPOS_PIXELS* pXHotSpot = NULL, OLE_YPOS_PIXELS* pYHotSpot = NULL, VARIANT_BOOL restrictDragImage = VARIANT_TRUE);
	/// \brief <em>Exits drag'n'drop mode</em>
	///
	/// \param[in] abort If \c VARIANT_TRUE, the drag'n'drop operation will be treated as aborted;
	///            otherwise it will be treated as a drop.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks You shouldn't call this method if you've chosen to use automatic drag'n'drop in
	///          \c Raise_ColumnBeginDrag.
	///
	/// \sa get_DraggedColumn, HeaderBeginDrag, EndDrag, Raise_HeaderAbortedDrag, Raise_HeaderDrop,
	///     Raise_ColumnBeginDrag
	virtual HRESULT STDMETHODCALLTYPE HeaderEndDrag(VARIANT_BOOL abort);
	/// \brief <em>Hit-tests the specified point</em>
	///
	/// Retrieves the header control's parts that lie below the point ('x'; 'y').
	///
	/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the header
	///            control's upper-left corner.
	/// \param[in,out] pHitTestDetails Receives a value specifying the exact part of the header control
	///                the specified point lies in. Any of the values defined by the
	///                \c HeaderHitTestConstants enumeration is valid.
	/// \param[out] ppHitColumn Receives the "hit" column's \c IListViewColumn implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::HeaderHitTestConstants, HitTest
	/// \else
	///   \sa ExLVwLibA::HeaderHitTestConstants, HitTest
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE HeaderHitTest(OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants* pHitTestDetails, IListViewColumn** ppHitColumn);
	/// \brief <em>Enters OLE drag'n'drop mode</em>
	///
	/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
	///            drag'n'drop. If not specified, the control's own implementation is used.
	/// \param[in] supportedEffects A bit field defining all drop effects the client wants to support.
	///            Any combination of the values defined by the \c OLEDropEffectConstants enumeration
	///            (except \c odeScroll) is valid.
	/// \param[in] hWndToAskForDragImage The handle of the window, that is awaiting the
	///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the method
	///            creates the drag image itself. If \c SupportOLEDragImages is set to \c VARIANT_FALSE,
	///            no drag image is used.
	/// \param[in] pDraggedColumnHeader The column header to drag. It is used to generate the drag image
	///            and is ignored if \c hWndToAskForDragImage is not -1.
	/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
	///            If set to -1, 0 or 1, no item count label is displayed. If set to any value larger than 1,
	///            this value is displayed in the item count label.
	/// \param[out] pPerformedEffects The performed drop effect. Any of the values defined by the
	///             \c OLEDropEffectConstants enumeration (except \c odeScroll) is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa HeaderBeginDrag, OLEDrag, Raise_ColumnBeginDrag, Raise_HeaderOLEStartDrag,
	///       get_SupportOLEDragImages, get_HeaderOLEDragImageStyle, ExLVwLibU::OLEDropEffectConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	/// \else
	///   \sa HeaderBeginDrag, OLEDrag, Raise_ColumnBeginDrag, Raise_HeaderOLEStartDrag,
	///       get_SupportOLEDragImages, get_HeaderOLEDragImageStyle, ExLVwLibA::OLEDropEffectConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE HeaderOLEDrag(LONG* pDataObject = NULL, OLEDropEffectConstants supportedEffects = odeCopyOrMove, OLE_HANDLE hWndToAskForDragImage = -1, IListViewColumn* pDraggedColumnHeader = NULL, LONG itemCountToDisplay = -1, OLEDropEffectConstants* pPerformedEffects = NULL);
	/// \brief <em>Advises the header control to redraw itself</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Refresh
	virtual HRESULT STDMETHODCALLTYPE HeaderRefresh(void);
	/// \brief <em>Hit-tests the specified point</em>
	///
	/// Retrieves the control's parts that lie below the point ('x'; 'y').
	///
	/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the control's
	///            upper-left corner.
	/// \param[in,out] pHitTestDetails Receives a value specifying the exact part of the control the
	///                specified point lies in. Any of the values defined by the \c HitTestConstants
	///                enumeration is valid.
	/// \param[in,out] pHitSubItem Receives the "hit" sub-item's \c IListViewSubItem implementation.
	/// \param[in,out] pHitGroup Receives the "hit" group's \c IListViewGroup implementation.
	/// \param[in,out] pHitFooterItem Receives the "hit" footer item's \c IListViewFooterItem implementation.
	/// \param[out] ppHitItem Receives the "hit" item's \c IListViewItem implementation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_ItemBoundingBoxDefinition, ExLVwLibU::HitTestConstants, HitTest,
	///       HitTestConstants2LVHTFlags, LVHTFlags2HitTestConstants
	/// \else
	///   \sa get_ItemBoundingBoxDefinition, ExLVwLibA::HitTestConstants, HitTest,
	///       HitTestConstants2LVHTFlags, LVHTFlags2HitTestConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE HitTest(OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants* pHitTestDetails, VARIANT* pHitSubItem = NULL, VARIANT* pHitGroup = NULL, VARIANT* pHitFooterItem = NULL, IListViewItem** ppHitItem = NULL);
	/// \brief <em>whether the control's footer area is currently displayed.</em>
	///
	/// \param[out] pVisible \c VARIANT_TRUE if the footer area is visible; otherwise \c VARIANT_FALSE.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa ShowFooter, get_FooterItems
	virtual HRESULT STDMETHODCALLTYPE IsFooterVisible(VARIANT_BOOL* pVisible);
	/// \brief <em>Loads the control's settings from the specified file</em>
	///
	/// \param[in] file The file to read from.
	/// \param[out] pSucceeded Will be set to \c VARIANT_TRUE on success and to \c VARIANT_FALSE otherwise.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa SaveSettingsToFile
	virtual HRESULT STDMETHODCALLTYPE LoadSettingsFromFile(BSTR file, VARIANT_BOOL* pSucceeded);
	/// \brief <em>Enters OLE drag'n'drop mode</em>
	///
	/// \param[in] pDataObject A pointer to the \c IDataObject implementation to use during OLE
	///            drag'n'drop. If not specified, the control's own implementation is used.
	/// \param[in] supportedEffects A bit field defining all drop effects the client wants to support.
	///            Any combination of the values defined by the \c OLEDropEffectConstants enumeration
	///            (except \c odeScroll) is valid.
	/// \param[in] hWndToAskForDragImage The handle of the window, that is awaiting the
	///            \c DI_GETDRAGIMAGE message to specify the drag image to use. If -1, the method
	///            creates the drag image itself. If \c SupportOLEDragImages is set to \c VARIANT_FALSE,
	///            no drag image is used.
	/// \param[in] pDraggedItems The dragged items collection object's \c IListViewItemContainer
	///            implementation. It is used to generate the drag image and is ignored if
	///            \c hWndToAskForDragImage is not -1.
	/// \param[in] itemCountToDisplay The number to display in the item count label of Aero drag images.
	///            If set to 0 or 1, no item count label is displayed. If set to -1, the number of items
	///            contained in the \c pDraggedItems collection is displayed in the item count label. If
	///            set to any value larger than 1, this value is displayed in the item count label.
	/// \param[out] pPerformedEffects The performed drop effect. Any of the values defined by the
	///             \c OLEDropEffectConstants enumeration (except \c odeScroll) is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa BeginDrag, HeaderOLEDrag, Raise_ItemBeginDrag, Raise_ItemBeginRDrag, Raise_OLEStartDrag,
	///       get_SupportOLEDragImages, get_OLEDragImageStyle, ExLVwLibU::OLEDropEffectConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	/// \else
	///   \sa BeginDrag, HeaderOLEDrag, Raise_ItemBeginDrag, Raise_ItemBeginRDrag, Raise_OLEStartDrag,
	///       get_SupportOLEDragImages, get_OLEDragImageStyle, ExLVwLibA::OLEDropEffectConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE OLEDrag(LONG* pDataObject = NULL, OLEDropEffectConstants supportedEffects = odeCopyOrMove, OLE_HANDLE hWndToAskForDragImage = -1, IListViewItemContainer* pDraggedItems = NULL, LONG itemCountToDisplay = -1, OLEDropEffectConstants* pPerformedEffects = NULL);
	/// \brief <em>Redraws a range of items</em>
	///
	/// \param[in] iFirstItem The index of the first item to redraw.
	/// \param[in] iLastItem The index of the last item to redraw.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The specified items are not actually redrawn until the control receives a \c WM_PAINT
	///          message to repaint. To repaint immediately, call the \c Refresh method.
	///
	/// \sa Refresh, ListViewItem::Update
	virtual HRESULT STDMETHODCALLTYPE RedrawItems(LONG iFirstItem = 0, LONG iLastItem = -1);
	/// \brief <em>Advises the control to redraw itself</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa HeaderRefresh, RedrawItems
	virtual HRESULT STDMETHODCALLTYPE Refresh(void);
	/// \brief <em>Saves the control's settings to the specified file</em>
	///
	/// \param[in] file The file to write to.
	/// \param[out] pSucceeded Will be set to \c VARIANT_TRUE on success and to \c VARIANT_FALSE otherwise.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa LoadSettingsFromFile
	virtual HRESULT STDMETHODCALLTYPE SaveSettingsToFile(BSTR file, VARIANT_BOOL* pSucceeded);
	/// \brief <em>Scrolls the control's content</em>
	///
	/// \param[in] horizontalDistance The amount of horizontal scrolling in pixels. If the control
	///            is in 'List' view, this value specifies the number of columns to scroll.
	/// \param[in] verticalDistance The amount of vertical scrolling in pixels. If the control is in
	///            'Details' view, this value will be rounded, so that the control is scrolled in
	///            whole line increments.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_BeforeScroll, Raise_AfterScroll, GetOrigin, GetViewRectangle, get_View
	virtual HRESULT STDMETHODCALLTYPE Scroll(OLE_XSIZE_PIXELS horizontalDistance, OLE_YSIZE_PIXELS verticalDistance);
	/// \brief <em>Sets the keyboard focus to the header control</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_CaretColumn, ListViewColumn::get_Caret
	virtual HRESULT STDMETHODCALLTYPE SetFocusToHeader(void);
	/// \brief <em>Sets the position of the header control's insertion mark</em>
	///
	/// \param[in] position The zero-based index of the column divider to highlight. The column divider
	///            to the left of the first column is the 0th one. If set to -1, the insertion mark is
	///            removed.
	/// \param[in] x The x-coordinate (in pixels) of a point relative to the header control's upper-left
	///            corner. The header control will highlight the column divider nearest to this point.
	/// \param[in] y The y-coordinate (in pixels) of a point relative to the header control's upper-left
	///            corner. The header control will highlight the column divider nearest to this point.
	/// \param[out] pPosition The zero-based index of the column divider that was highlighted.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \sa SetInsertMarkPosition, get_AllowHeaderDragDrop, get_RegisterForOLEDragDrop
	virtual HRESULT STDMETHODCALLTYPE SetHeaderInsertMarkPosition(LONG position = 0, LONG x = 0x80000000, LONG y = 0x80000000, LONG* pPosition = NULL);
	/// \brief <em>Sets the spacing between items in 'Icons' view</em>
	///
	/// Sets an item's width and height (including the space beneath it) in 'Icons' view in pixels.
	///
	/// \param[in] itemWidth The item's width (including the space beneath it) in pixels.
	/// \param[in] itemHeight The item's height (including the space beneath it) in pixels.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Setting both arguments to -1 resets icon spacing to the system defaults.
	///
	/// \sa GetIconSpacing, get_JustifyIconColumns, get_View
	virtual HRESULT STDMETHODCALLTYPE SetIconSpacing(OLE_XSIZE_PIXELS itemWidth, OLE_YSIZE_PIXELS itemHeight);
	/// \brief <em>Sets the position of the control's insertion mark</em>
	///
	/// \param[in] relativePosition The insertion mark's position relative to the specified item. Any of
	///            the values defined by the \c InsertMarkPositionConstants enumeration is valid.
	/// \param[in] pListItem The \c IListViewItem implementation of the item, at which the insertion
	///            mark will be displayed. If set to \c NULL, the insertion mark will be removed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks An insertion mark can be used only if the control is in 'Icons', 'Small Icons', 'Tiles' or
	///          'Extended Tiles' view, is not in group-view mode, and has \c AutoArrangeItems set to
	///          \c aaiNormal.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, SetHeaderInsertMarkPosition,
	///       get_InsertMarkColor, get_AutoArrangeItems, get_ShowGroups, get_View,
	///       get_RegisterForOLEDragDrop, ExLVwLibU::InsertMarkPositionConstants
	/// \else
	///   \sa GetInsertMarkPosition, GetClosestInsertMarkPosition, SetHeaderInsertMarkPosition,
	///       get_InsertMarkColor, get_AutoArrangeItems, get_ShowGroups, get_View,
	///       get_RegisterForOLEDragDrop, ExLVwLibA::InsertMarkPositionConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE SetInsertMarkPosition(InsertMarkPositionConstants relativePosition, IListViewItem* pListItem);
	/// \brief <em>Displays the footer area</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa get_FooterIntroText, get_FooterItems, IsFooterVisible
	virtual HRESULT STDMETHODCALLTYPE ShowFooter(void);
	/// \brief <em>Sorts the control's groups</em>
	///
	/// Sorts the control's groups by up to 3 criteria.
	///
	/// \param[in] firstCriterion The first criterion by which to sort. Some of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] secondCriterion The second criterion by which to sort. It is used if two groups are
	///            equivalent regarding the first criterion. Some of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] thirdCriterion The third criterion by which to sort. It is used if two groups are
	///            equivalent regarding the first 2 criteria. Some of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] caseSensitive If \c VARIANT_TRUE, text comparisons will be case sensitive; otherwise
	///            not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa get_GroupSortOrder, Raise_CompareGroups, SortItems, ExLVwLibU::SortByConstants
	/// \else
	///   \sa get_GroupSortOrder, Raise_CompareGroups, SortItems, ExLVwLibA::SortByConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE SortGroups(SortByConstants firstCriterion = sobShell, SortByConstants secondCriterion = sobText, SortByConstants thirdCriterion = sobNone, VARIANT_BOOL caseSensitive = VARIANT_FALSE);
	/// \brief <em>Sorts the control's items</em>
	///
	/// Sorts the control's items by up to 5 criteria.
	///
	/// \param[in] firstCriterion The first criterion by which to sort. Any of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] secondCriterion The second criterion by which to sort. It is used if two items are
	///            equivalent regarding the first criterion. Any of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] thirdCriterion The third criterion by which to sort. It is used if two items are
	///            equivalent regarding the first 2 criteria. Any of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] fourthCriterion The fourth criterion by which to sort. It is used if two items are
	///            equivalent regarding the first 3 criteria. Any of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] fifthCriterion The fifth criterion by which to sort. It is used if two items are
	///            equivalent regarding the first 4 criteria. Any of the values defined by the
	///            \c SortByConstants enumeration is valid.
	/// \param[in] column The column by which to sort if sorting by (sub-)item text.
	/// \param[in] caseSensitive If \c VARIANT_TRUE, text comparisons will be case sensitive; otherwise
	///            not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_SortOrder, Raise_CompareItems, SortGroups, ExLVwLibU::SortByConstants
	/// \else
	///   \sa get_SortOrder, Raise_CompareItems, SortGroups, ExLVwLibA::SortByConstants
	/// \endif
	virtual HRESULT STDMETHODCALLTYPE SortItems(SortByConstants firstCriterion = sobShell, SortByConstants secondCriterion = sobText, SortByConstants thirdCriterion = sobNone, SortByConstants fourthCriterion = sobNone, SortByConstants fifthCriterion = sobNone, VARIANT column = _variant_t(DISP_E_PARAMNOTFOUND, VT_ERROR), VARIANT_BOOL caseSensitive = VARIANT_FALSE);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Property object changes
	///
	//@{
	/// \brief <em>Will be called after a property object was changed</em>
	///
	/// \param[in] propertyObject The \c DISPID of the property object.
	/// \param[in] objectProperty The \c DISPID of the property that was changed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa PropertyNotifySinkImpl::OnChanged
	HRESULT OnPropertyObjectChanged(DISPID propertyObject, DISPID /*objectProperty*/);
	/// \brief <em>Will be called before a property object is changed</em>
	///
	/// \param[in] propertyObject The \c DISPID of the property object.
	/// \param[in] objectProperty The \c DISPID of the property that is about to be changed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa PropertyNotifySinkImpl::OnRequestEdit
	HRESULT OnPropertyObjectRequestEdit(DISPID /*propertyObject*/, DISPID /*objectProperty*/);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>Called to create the control window</em>
	///
	/// Called to create the control window. This method overrides \c CWindowImpl::Create() and is
	/// used to customize the window styles.
	///
	/// \param[in] hWndParent The control's parent window.
	/// \param[in] rect The control's bounding rectangle.
	/// \param[in] szWindowName The control's window name.
	/// \param[in] dwStyle The control's window style. Will be ignored.
	/// \param[in] dwExStyle The control's extended window style. Will be ignored.
	/// \param[in] MenuOrID The control's ID.
	/// \param[in] lpCreateParam The window creation data. Will be passed to the created window.
	///
	/// \return The created window's handle.
	///
	/// \sa OnCreate, GetStyleBits, GetExStyleBits
	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL);
	/// \brief <em>Called to draw the control</em>
	///
	/// Called to draw the control. This method overrides \c CComControlBase::OnDraw() and is used to prevent
	/// the "ATL 9.0" drawing in user mode and replace it in design mode.
	///
	/// \param[in] drawInfo Contains any details like the device context required for drawing.
	///
	/// \return An \c HRESULT error code.
	virtual HRESULT OnDraw(ATL_DRAWINFO& drawInfo);
	/// \brief <em>Called after receiving the last message (typically \c WM_NCDESTROY)</em>
	///
	/// \param[in] hWnd The window being destroyed.
	///
	/// \sa OnCreate, OnDestroy
	void OnFinalMessage(HWND /*hWnd*/);
	/// \brief <em>Informs an embedded object of its display location within its container</em>
	///
	/// \param[in] pClientSite The \c IOleClientSite implementation of the container application's
	///            client side.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms684013.aspx">IOleObject::SetClientSite</a>
	virtual HRESULT STDMETHODCALLTYPE IOleObject_SetClientSite(LPOLECLIENTSITE pClientSite);
	/// \brief <em>Notifies the control when the container's document window is activated or deactivated</em>
	///
	/// ATL's implementation of \c OnDocWindowActivate calls \c IOleInPlaceObject_UIDeactivate if the control
	/// is deactivated. This causes a bug in MDI apps. If the control sits on a \c MDI child window and has
	/// the focus and the title bar of another top-level window (not the MDI parent window) of the same
	/// process is clicked, the focus is moved from the ATL based ActiveX control to the next control on the
	/// MDI child before it is moved to the other top-level window that was clicked. If the focus is set back
	/// to the MDI child, the ATL based control no longer has the focus.
	///
	/// \param[in] fActivate If \c TRUE, the document window is activated; otherwise deactivated.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/0kz79wfc.aspx">IOleInPlaceActiveObjectImpl::OnDocWindowActivate</a>
	virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL /*fActivate*/);

	/// \brief <em>A keyboard or mouse message needs to be translated</em>
	///
	/// The control's container calls this method if it receives a keyboard or mouse message. It gives
	/// us the chance to customize keystroke translation (i. e. to react to them in a non-default way).
	/// This method overrides \c CComControlBase::PreTranslateAccelerator.
	///
	/// \param[in] pMessage A \c MSG structure containing details about the received window message.
	/// \param[out] hReturnValue A reference parameter of type \c HRESULT which will be set to \c S_OK,
	///             if the message was translated, and to \c S_FALSE otherwise.
	///
	/// \return \c FALSE if the object's container should translate the message; otherwise \c TRUE.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/hxa56938(VS.80).aspx">CComControlBase::PreTranslateAccelerator</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646373.aspx">TranslateAccelerator</a>
	BOOL PreTranslateAccelerator(LPMSG pMessage, HRESULT& hReturnValue);

	//////////////////////////////////////////////////////////////////////
	/// \name Drag image creation
	///
	//@{
	/// \brief <em>Creates a legacy drag image for the specified item</em>
	///
	/// Creates a drag image for the specified item in the style of Windows versions prior to Vista. The
	/// drag image is added to an imagelist which is returned.
	///
	/// \param[in] itemIndex The item for which to create the drag image.
	/// \param[out] pUpperLeftPoint Receives the coordinates (in pixels) of the drag image's upper-left
	///             corner relative to the control's upper-left corner.
	/// \param[out] pBoundingRectangle Receives the drag image's bounding rectangle (in pixels) relative to
	///             the control's upper-left corner.
	///
	/// \return An imagelist containing the drag image.
	///
	/// \remarks The caller is responsible for destroying the imagelist.
	///
	/// \sa CreateLegacyHeaderDragImage, OnCreateDragImage, CreateLegacyOLEDragImage,
	///     ListViewItemContainer::CreateDragImage
	HIMAGELIST CreateLegacyDragImage(LVITEMINDEX& itemIndex, LPPOINT pUpperLeftPoint, LPRECT pBoundingRectangle);
	/// \brief <em>Creates a legacy drag image for the specified column header</em>
	///
	/// Creates a drag image for the specified column header in the style of Windows versions prior to Vista.
	/// The drag image is added to an imagelist which is returned.
	///
	/// \param[in] columnIndex The column header for which to create the drag image.
	/// \param[out] pUpperLeftPoint Receives the coordinates (in pixels) of the drag image's upper-left
	///             corner relative to the control's upper-left corner.
	/// \param[out] pBoundingRectangle Receives the drag image's bounding rectangle (in pixels) relative to
	///             the control's upper-left corner.
	///
	/// \return An imagelist containing the drag image.
	///
	/// \remarks The caller is responsible for destroying the imagelist.
	///
	/// \sa CreateLegacyDragImage, OnCreateHeaderDragImage, CreateLegacyOLEHeaderDragImage,
	///     ListViewColumn::CreateDragImage
	HIMAGELIST CreateLegacyHeaderDragImage(int columnIndex, LPPOINT pUpperLeftPoint, LPRECT pBoundingRectangle);
	/// \brief <em>Creates a legacy OLE drag image for the specified items</em>
	///
	/// Creates an OLE drag image for the specified items in the style of Windows versions prior to Vista.
	///
	/// \param[in] pItems A \c IListViewItemContainer object wrapping the items for which to create the drag
	///            image.
	/// \param[out] pDragImage Receives the drag image including transparency information and the coordinates
	///             (in pixels) of the drag image's upper-left corner relative to the control's upper-left
	///             corner.
	///
	/// \return \c TRUE on success; otherwise \c FALSE.
	///
	/// \sa CreateLegacyOLEHeaderDragImage, OnGetDragImage, CreateVistaOLEDragImage, CreateLegacyDragImage,
	///     ListViewItemContainer,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb759778.aspx">SHDRAGIMAGE</a>
	BOOL CreateLegacyOLEDragImage(IListViewItemContainer* pItems, __in LPSHDRAGIMAGE pDragImage);
	/// \brief <em>Creates a legacy OLE drag image for the specified column header</em>
	///
	/// Creates an OLE drag image for the specified column header in the style of Windows versions prior to
	/// Vista.
	///
	/// \param[in] pColumn A \c IListViewColumn object wrapping the column header for which to create the
	///            drag image.
	/// \param[out] pDragImage Receives the drag image including transparency information and the coordinates
	///             (in pixels) of the drag image's upper-left corner relative to the control's upper-left
	///             corner.
	///
	/// \return \c TRUE on success; otherwise \c FALSE.
	///
	/// \sa CreateLegacyOLEDragImage, OnHeaderGetDragImage, CreateVistaOLEHeaderDragImage,
	///     CreateLegacyHeaderDragImage, ListViewItemColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb759778.aspx">SHDRAGIMAGE</a>
	BOOL CreateLegacyOLEHeaderDragImage(IListViewColumn* pColumn, __in LPSHDRAGIMAGE pDragImage);
	/// \brief <em>Creates a Vista-like OLE drag image for the specified items</em>
	///
	/// Creates an OLE drag image for the specified items in the style of Windows Vista and newer.
	///
	/// \param[in] pItems A \c IListViewItemContainer object wrapping the items for which to create the drag
	///            image.
	/// \param[out] pDragImage Receives the drag image including transparency information and the coordinates
	///             (in pixels) of the drag image's upper-left corner relative to the control's upper-left
	///             corner.
	///
	/// \return \c TRUE on success; otherwise \c FALSE.
	///
	/// \sa CreateVistaOLEHeaderDragImage, OnGetDragImage, CreateLegacyOLEDragImage, CreateLegacyDragImage,
	///     ListViewItemContainer,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb759778.aspx">SHDRAGIMAGE</a>
	BOOL CreateVistaOLEDragImage(IListViewItemContainer* pItems, __in LPSHDRAGIMAGE pDragImage);
	/// \brief <em>Creates a Vista-like OLE drag image for the specified column header</em>
	///
	/// Creates an OLE drag image for the specified column header in the style of Windows Vista and newer.
	///
	/// \param[in] pColumn A \c IListViewColumn object wrapping the column header for which to create the
	///            drag image.
	/// \param[in] columnIndex The column header for which to create the drag image.
	/// \param[out] pDragImage Receives the drag image including transparency information and the coordinates
	///             (in pixels) of the drag image's upper-left corner relative to the control's upper-left
	///             corner.
	///
	/// \return \c TRUE on success; otherwise \c FALSE.
	///
	/// \sa CreateVistaOLEDragImage, OnHeaderGetDragImage, CreateLegacyOLEHeaderDragImage,
	///     CreateLegacyHeaderDragImage, ListViewItemColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb759778.aspx">SHDRAGIMAGE</a>
	BOOL CreateVistaOLEHeaderDragImage(IListViewColumn* pColumn, __in LPSHDRAGIMAGE pDragImage);
	//@}
	//////////////////////////////////////////////////////////////////////

protected:
	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IDropTarget
	///
	//@{
	/// \brief <em>Indicates whether a drop can be accepted, and, if so, the effect of the drop</em>
	///
	/// This method is called by the \c DoDragDrop function to determine the target's preferred drop
	/// effect the first time the user moves the mouse into the control during OLE drag'n'Drop. The
	/// target communicates the \c DoDragDrop function the drop effect it wants to be used on drop.
	///
	/// \param[in] pDataObject The \c IDataObject implementation of the object containing the dragged
	///            data.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, this paramter must be set
	///                to the drop effect that the target wants to be used on drop.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragOver, DragLeave, Drop, Raise_OLEDragEnter, Raise_HeaderOLEDragEnter,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms680106.aspx">IDropTarget::DragEnter</a>
	virtual HRESULT STDMETHODCALLTYPE DragEnter(IDataObject* pDataObject, DWORD keyState, POINTL mousePosition, DWORD* pEffect);
	/// \brief <em>Notifies the target that it no longer is the target of the current OLE drag'n'drop operation</em>
	///
	/// This method is called by the \c DoDragDrop function if the user moves the mouse out of the
	/// control during OLE drag'n'Drop or if the user canceled the operation. The target must release
	/// any references it holds to the data object.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragEnter, DragOver, Drop, Raise_OLEDragLeave, Raise_HeaderOLEDragLeave,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms680110.aspx">IDropTarget::DragLeave</a>
	virtual HRESULT STDMETHODCALLTYPE DragLeave(void);
	/// \brief <em>Communicates the current drop effect to the \c DoDragDrop function</em>
	///
	/// This method is called by the \c DoDragDrop function if the user moves the mouse over the
	/// control during OLE drag'n'Drop. The target communicates the \c DoDragDrop function the drop
	/// effect it wants to be used on drop.
	///
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[in,out] pEffect On entry, the current drop effect (defined by the \c DROPEFFECT
	///                enumeration). On return, this paramter must be set to the drop effect that the
	///                target wants to be used on drop.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragEnter, DragLeave, Drop, Raise_OLEDragMouseMove, Raise_HeaderOLEDragMouseMove,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms680129.aspx">IDropTarget::DragOver</a>
	virtual HRESULT STDMETHODCALLTYPE DragOver(DWORD keyState, POINTL mousePosition, DWORD* pEffect);
	/// \brief <em>Incorporates the source data into the target and completes the drag'n'drop operation</em>
	///
	/// This method is called by the \c DoDragDrop function if the user completes the drag'n'drop
	/// operation. The target must incorporate the dragged data into itself and pass the used drop
	/// effect back to the \c DoDragDrop function. The target must release any references it holds to
	/// the data object.
	///
	/// \param[in] pDataObject The \c IDataObject implementation of the object containing the data
	///            to transfer.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, this paramter must be set
	///                to the drop effect that the target finally executed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragEnter, DragOver, DragLeave, Raise_OLEDragDrop, Raise_HeaderOLEDragDrop,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms687242.aspx">IDropTarget::Drop</a>
	virtual HRESULT STDMETHODCALLTYPE Drop(IDataObject* pDataObject, DWORD keyState, POINTL mousePosition, DWORD* pEffect);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IDropSource
	///
	//@{
	/// \brief <em>Notifies the source of the current drop effect during OLE drag'n'drop</em>
	///
	/// This method is called frequently by the \c DoDragDrop function to notify the source of the
	/// last drop effect that the target has chosen. The source should set an appropriate mouse cursor.
	///
	/// \param[in] effect The drop effect chosen by the target. Any of the values defined by the
	///            \c DROPEFFECT enumeration is valid.
	///
	/// \return \c S_OK if the method has set a custom mouse cursor; \c DRAGDROP_S_USEDEFAULTCURSORS to
	///         use default mouse cursors; or an error code otherwise.
	///
	/// \sa QueryContinueDrag, Raise_OLEGiveFeedback, Raise_HeaderOLEGiveFeedback,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms693723.aspx">IDropSource::GiveFeedback</a>
	virtual HRESULT STDMETHODCALLTYPE GiveFeedback(DWORD effect);
	/// \brief <em>Determines whether a drag'n'drop operation should be continued, canceled or completed</em>
	///
	/// This method is called by the \c DoDragDrop function to determine whether a drag'n'drop
	/// operation should be continued, canceled or completed.
	///
	/// \param[in] pressedEscape Indicates whether the user has pressed the \c ESC key since the
	///            previous call of this method. If \c TRUE, the key has been pressed; otherwise not.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	///
	/// \return \c S_OK if the drag'n'drop operation should continue; \c DRAGDROP_S_DROP if it should
	///         be completed; \c DRAGDROP_S_CANCEL if it should be canceled; or an error code otherwise.
	///
	/// \sa GiveFeedback, Raise_OLEQueryContinueDrag, Raise_HeaderOLEQueryContinueDrag,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms690076.aspx">IDropSource::QueryContinueDrag</a>
	virtual HRESULT STDMETHODCALLTYPE QueryContinueDrag(BOOL pressedEscape, DWORD keyState);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IDropSourceNotify
	///
	//@{
	/// \brief <em>Notifies the source that the user drags the mouse cursor into a potential drop target window</em>
	///
	/// This method is called by the \c DoDragDrop function to notify the source that the user is dragging
	/// the mouse cursor into a potential drop target window.
	///
	/// \param[in] hWndTarget The potential drop target window.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragLeaveTarget, Raise_OLEDragEnterPotentialTarget, Raise_HeaderOLEDragEnterPotentialTarget,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa344050.aspx">IDropSourceNotify::DragEnterTarget</a>
	virtual HRESULT STDMETHODCALLTYPE DragEnterTarget(HWND hWndTarget);
	/// \brief <em>Notifies the source that the user drags the mouse cursor out of a potential drop target window</em>
	///
	/// This method is called by the \c DoDragDrop function to notify the source that the user is dragging
	/// the mouse cursor out of a potential drop target window.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DragEnterTarget, Raise_OLEDragLeavePotentialTarget, Raise_HeaderOLEDragLeavePotentialTarget,
	///     <a href="https://msdn.microsoft.com/en-us/library/aa344050.aspx">IDropSourceNotify::DragLeaveTarget</a>
	virtual HRESULT STDMETHODCALLTYPE DragLeaveTarget(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IListViewFooterCallback
	///
	//@{
	/// \brief <em>Notifies the client that a footer item has been clicked</em>
	///
	/// This method is called by the listview control to notify the client application that the user has
	/// clicked a footer item.
	///
	/// \param[in] itemIndex The zero-based index of the footer item that has been clicked.
	/// \param[in] lParam The application-defined integer value that is associated with the clicked button.
	/// \param[out] pRemoveFooter If set to \c TRUE, the listview control will remove the footer area.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_FooterItemClick, IListViewFooterCallback::OnButtonClicked
	virtual HRESULT STDMETHODCALLTYPE OnButtonClicked(int itemIndex, LPARAM /*lParam*/, PINT pRemoveFooter);
	/// \brief <em>Notifies the client that a footer item has been removed</em>
	///
	/// This method is called by the listview control to notify the client application that it has removed a
	/// footer item.
	///
	/// \param[in] itemIndex The zero-based index of the footer item that has been removed.
	/// \param[in] lParam The application-defined integer value that is associated with the removed button.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_FreeFooterItemData, IListViewFooterCallback::OnDestroyButton
	virtual HRESULT STDMETHODCALLTYPE OnDestroyButton(int itemIndex, LPARAM lParam);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IOwnerDataCallback
	///
	//@{
	/// \brief <em>TODO</em>
	///
	/// TODO
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa TODO, SetItemPosition, IOwnerDataCallback::GetItemPosition
	virtual HRESULT STDMETHODCALLTYPE GetItemPosition(int /*itemIndex*/, LPPOINT /*pPosition*/);
	/// \brief <em>TODO</em>
	///
	/// TODO
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa TODO, GetItemPosition, IOwnerDataCallback::SetItemPosition
	virtual HRESULT STDMETHODCALLTYPE SetItemPosition(int /*itemIndex*/, POINT /*position*/);
	/// \brief <em>Will be called to retrieve an item's zero-based control-wide index</em>
	///
	/// This method is called by the listview control to retrieve an item's zero-based control-wide index.
	/// The item is identified by a zero-based group index, which identifies the listview group in which
	/// the item is displayed, and a zero-based group-wide item index, which identifies the item within its
	/// group.
	///
	/// \param[in] groupIndex The zero-based index of the listview group containing the item.
	/// \param[in] groupWideItemIndex The item's zero-based group-wide index within the listview group
	///            specified by \c groupIndex.
	/// \param[out] pTotalItemIndex Receives the item's zero-based control-wide index.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_MapGroupWideToTotalItemIndex, IOwnerDataCallback::GetItemInGroup
	virtual HRESULT STDMETHODCALLTYPE GetItemInGroup(int groupIndex, int groupWideItemIndex, PINT pTotalItemIndex);
	/// \brief <em>Will be called to retrieve the group containing a specific occurrence of an item</em>
	///
	/// This method is called by the listview control to retrieve the listview group in which the specified
	/// occurrence of the specified item is displayed.
	///
	/// \param[in] itemIndex The item's zero-based (control-wide) index.
	/// \param[in] occurrenceIndex The zero-based index of the item's copy for which the group membership
	///            is retrieved.
	/// \param[out] pGroupIndex Receives the zero-based index of the listview group that shall contain the
	///             specified copy of the specified item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_ItemGetGroup, GetItemGroupCount, IOwnerDataCallback::GetItemGroup
	virtual HRESULT STDMETHODCALLTYPE GetItemGroup(int itemIndex, int occurenceIndex, PINT pGroupIndex);
	/// \brief <em>Will be called to determine how often an item occurs in the listview control</em>
	///
	/// This method is called by the listview control to determine how often the specified item occurs in
	/// the listview control.
	///
	/// \param[in] itemIndex The item's zero-based (control-wide) index.
	/// \param[out] pOccurrencesCount Receives the number of occurrences of the item in the listview
	///             control.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_ItemGetOccurrencesCount, GetItemGroup, IOwnerDataCallback::GetItemGroupCount
	virtual HRESULT STDMETHODCALLTYPE GetItemGroupCount(int itemIndex, PINT pOccurenceCount);
	/// \brief <em>Will be called to prepare the client app that the data for a certain range of items will be required very soon</em>
	///
	/// This method is similar to the \c LVN_ODCACHEHINT notification. It tells the client application that
	/// it should preload the details for a certain range of items because the listview control is about to
	/// request these details. The difference to \c LVN_ODCACHEHINT is that this method identifies the
	/// items by their zero-based group-wide index and the zero-based index of the listview group
	/// containing the item.
	///
	/// \param[in] firstItem The first item to cache.
	/// \param[in] lastItem The last item to cache.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa Raise_CacheItemsHint, OnODCacheHintNotification, GetItemInGroup,
	///     IOwnerDataCallback::OnCacheHint
	virtual HRESULT STDMETHODCALLTYPE OnCacheHint(LVITEMINDEX firstItem, LVITEMINDEX lastItem);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of ISubItemCallback
	///
	//@{
	/// \brief <em>Retrieves the title of the specified sub-item</em>
	///
	/// Retrieves the title of the specified sub-item. This title is displayed in extended tile view mode
	/// in front of the sub-item's value.
	///
	/// \param[in] subItemIndex The one-based index of the sub-item for which to retrieve the title.
	/// \param[out] pBuffer Receives the sub-item's title.
	/// \param[in] bufferSize The size of the buffer (in characters) specified by the \c pBuffer parameter.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa get_View
	virtual HRESULT STDMETHODCALLTYPE GetSubItemTitle(int subItemIndex, LPWSTR pBuffer, int bufferSize);
	/// \brief <em>Retrieves the control representing the specified sub-item</em>
	///
	/// Retrieves the control representing the specified sub-item. The control is used for drawing the
	/// sub-item.\n
	/// Starting with comctl32.dll version 6.10, sub-items can be represented by objects that implement
	/// the \c IPropertyControlBase interface. Representation means drawing the sub-item (by implementing the
	/// \c IDrawPropertyControl interface) and/or editing the sub-item in-place (by implementing the
	/// \c IPropertyControl interface, which allows in-place editing with a complex user interface). The
	/// object that represents the sub-item is retrieved dynamically.\n
	/// This method retrieves the sub-item control that is used for drawing the sub-item.
	///
	/// \param[in] itemIndex The zero-based index of the item for which to retrieve the sub-item control.
	/// \param[in] subItemIndex The one-based index of the sub-item for which to retrieve the sub-item
	///            control.
	/// \param[in] requiredInterface The IID of the interface of which the sub-item control's implementation
	///            will be returned.
	/// \param[out] ppObject Receives the sub-item control's implementation of the interface identified by
	///             \c requiredInterface.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With current versions of comctl32.dll, providing a sub-item control is the only way to
	///          custom-draw sub-items in Tiles view mode.
	///
	/// \sa BeginSubItemEdit, Raise_GetSubItemControl, Raise_ConfigureSubItemControl, Raise_CustomDraw,
	///     get_View, IPropertyControlBase, IPropertyControl, IDrawPropertyControl
	virtual HRESULT STDMETHODCALLTYPE GetSubItemControl(int itemIndex, int subItemIndex, REFIID requiredInterface, LPVOID* ppObject);
	/// \brief <em>Retrieves the control used to edit the specified sub-item</em>
	///
	/// Retrieves the control that will be used to edit the specified sub-item. The control is used for
	/// editing the sub-item.\n
	/// Starting with comctl32.dll version 6.10, sub-items can be represented by objects that implement
	/// the \c IPropertyControlBase interface. Representation means drawing the sub-item (by implementing the
	/// \c IDrawPropertyControl interface) and/or editing the sub-item in-place (by implementing the
	/// \c IPropertyControl interface, which allows in-place editing with a complex user interface). The
	/// object that represents the sub-item is retrieved dynamically.\n
	/// This method retrieves the sub-item control that is used for editing the sub-item.
	///
	/// \param[in] itemIndex The zero-based index of the item for which to retrieve the sub-item control.
	/// \param[in] subItemIndex The one-based index of the sub-item for which to retrieve the sub-item
	///            control.
	/// \param[in] mode If set to 0, the edit mode has been entered by moving the mouse over the sub-item.
	///            If set to 1, the edit mode has been entered by calling \c IListView::EditSubItem or by
	///            clicking on the sub-item.
	/// \param[in] requiredInterface The IID of the interface of which the sub-item control's implementation
	///            will be returned.
	/// \param[out] ppObject Receives the sub-item control's implementation of the interface identified by
	///             \c requiredInterface.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa EndSubItemEdit, GetSubItemControl, IListView_WINVISTA::EditSubItem, IListView_WIN7::EditSubItem,
	///     Raise_GetSubItemControl, Raise_ConfigureSubItemControl, get_View, IPropertyControlBase,
	///     IPropertyControl, IDrawPropertyControl
	virtual HRESULT STDMETHODCALLTYPE BeginSubItemEdit(int itemIndex, int subItemIndex, int /*mode*/, REFIID requiredInterface, LPVOID* ppObject);
	/// \brief <em>Notifies the control that editing the specified sub-item has ended</em>
	///
	/// Notifies the control that editing the specified sub-item using the specified sub-item control has
	/// been finished.\n
	/// Starting with comctl32.dll version 6.10, sub-items can be represented by objects that implement
	/// the \c IPropertyControlBase interface. Representation means drawing the sub-item (by implementing the
	/// \c IDrawPropertyControl interface) and/or editing the sub-item in-place (by implementing the
	/// \c IPropertyControl interface, which allows in-place editing with a complex user interface). The
	/// object that represents the sub-item is retrieved dynamically.
	///
	/// \param[in] itemIndex The zero-based index of the item whose sub-item has been edited.
	/// \param[in] subItemIndex The one-based index of the sub-item that has been edited.
	/// \param[in] mode If set to 0, the edit mode has been entered by moving the mouse over the sub-item.
	///            If set to 1, the edit mode has been entered by calling \c IListView::EditSubItem or by
	///            clicking on the sub-item.
	/// \param[in] pPropertyControl The property control that has been used to edit the sub-item. This
	///            property control has to be destroyed by this method.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Call \c IPropertyControl::IsModified to retrieve whether editing the sub-item has been
	///          completed or canceled.
	///
	/// \sa BeginSubItemEdit, IListView_WINVISTA::EditSubItem, IListView_WIN7::EditSubItem,
	///     Raise_EndSubItemEdit, Raise_CancelSubItemEdit, IPropertyControlBase, IPropertyControl,
	///     IDrawPropertyControl, IPropertyControlBase::Destroy, IPropertyControl::IsModified
	virtual HRESULT STDMETHODCALLTYPE EndSubItemEdit(int itemIndex, int subItemIndex, int /*mode*/, IPropertyControl* pPropertyControl);
	/// \brief <em>Retrieves the control used to edit the specified group header</em>
	///
	/// Retrieves the control that will be used to edit the specified group header. The control is used for
	/// editing the group header.\n
	/// Starting with comctl32.dll version 6.10, group headers can be represented by objects that implement
	/// the \c IPropertyControlBase interface. Representation means editing the group header in-place (by
	/// implementing the \c IPropertyControl interface, which allows in-place editing with a complex user
	/// interface). The object that represents the group header is retrieved dynamically.\n
	/// This method retrieves the edit control that is used for editing the group header.
	///
	/// \param[in] groupIndex The zero-based index of the group for which to retrieve the edit control.
	/// \param[in] requiredInterface The IID of the interface of which the edit control's implementation will
	///            be returned.
	/// \param[out] ppObject Receives the edit control's implementation of the interface identified by
	///             \c requiredInterface.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa EndGroupEdit, IListView_WINVISTA::EditGroupLabel, IListView_WIN7::EditGroupLabel, IPropertyControlBase,
	///     IPropertyControl
	virtual HRESULT STDMETHODCALLTYPE BeginGroupEdit(int /*groupIndex*/, REFIID /*requiredInterface*/, LPVOID* ppObject);
	/// \brief <em>Notifies the control that editing the specified group header has ended</em>
	///
	/// Notifies the control that editing the specified group header using the specified edit control has
	/// been finished.\n
	/// Starting with comctl32.dll version 6.10, group headers can be represented by objects that implement
	/// the \c IPropertyControlBase interface. Representation means editing the group header in-place (by
	/// implementing the \c IPropertyControl interface, which allows in-place editing with a complex user
	/// interface). The object that represents the group header is retrieved dynamically.
	///
	/// \param[in] groupIndex The zero-based index of the group whose header has been edited.
	/// \param[in] mode If set to 0, the edit mode has been entered by moving the mouse over the group
	///            header. If set to 1, the edit mode has been entered by calling
	///            \c IListView::EditGroupLabel or by clicking on the group header.
	/// \param[in] pPropertyControl The property control that has been used to edit the group header. This
	///            property control has to be destroyed by this method.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Call \c IPropertyControl::IsModified to retrieve whether editing the group header has been
	///          completed or canceled.
	///
	/// \sa BeginGroupEdit, IListView_WINVISTA::EditGroupLabel, IListView_WIN7::EditGroupLabel,
	///     IPropertyControlBase, IPropertyControl, IPropertyControlBase::Destroy,
	///     IPropertyControl::IsModified
	virtual HRESULT STDMETHODCALLTYPE EndGroupEdit(int /*groupIndex*/, int /*mode*/, IPropertyControl* pPropertyControl);
	/// \brief <em>Notifies the control that the specified verb has been invoked on the specified item</em>
	///
	/// Notifies the control that an action identified by the specified verb has been invoked on the
	/// specified item. The action usually is generated by the user. The sub-item control translates the
	/// action into a verb which it invokes.\n
	/// For the hyperlink sub-item control the action is clicking the link and the verb is the string that
	/// has been specified as the \c id attribute of the hyperlink markup
	/// (&lt;a id=&quot;<i>verb</i>&quot;&gt;<i>text</i>&lt;/a&gt;).
	///
	/// \param[in] itemIndex The zero-based index of the item on which the verb is being invoked.
	/// \param[in] pVerb The verb identifying the action.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetSubItemControl, IPropertyControlBase::InvokeDefaultAction, Raise_InvokeVerbFromSubItemControl
	virtual HRESULT STDMETHODCALLTYPE OnInvokeVerb(int itemIndex, LPCWSTR pVerb);
	//@}
	//////////////////////////////////////////////////////////////////////

	#ifdef INCLUDESHELLBROWSERINTERFACE
		//////////////////////////////////////////////////////////////////////
		/// \name Implementation of IInternalMessageListener
		///
		//@{
		/// \brief <em>Processes the messages sent by the attached \c ShellBrowser control</em>
		///
		/// \param[in] message The message to process.
		/// \param[in] wParam Used to transfer data with the message.
		/// \param[in] lParam Used to transfer data with the message.
		///
		/// \return An \c HRESULT error code.
		virtual HRESULT ProcessMessage(UINT message, WPARAM wParam, LPARAM lParam);
		//@}
		//////////////////////////////////////////////////////////////////////
	#endif

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of ICategorizeProperties
	///
	//@{
	/// \brief <em>Retrieves a category's name</em>
	///
	/// \param[in] category The ID of the category whose name is requested.
	/// \param[in] languageID The locale identifier identifying the language in which name should be
	///            provided.
	/// \param[out] pName The category's name.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa ICategorizeProperties::GetCategoryName
	virtual HRESULT STDMETHODCALLTYPE GetCategoryName(PROPCAT category, LCID /*languageID*/, BSTR* pName);
	/// \brief <em>Maps a property to a category</em>
	///
	/// \param[in] property The ID of the property whose category is requested.
	/// \param[out] pCategory The category's ID.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa ICategorizeProperties::MapPropertyToCategory
	virtual HRESULT STDMETHODCALLTYPE MapPropertyToCategory(DISPID property, PROPCAT* pCategory);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of ICreditsProvider
	///
	//@{
	/// \brief <em>Retrieves the name of the control's authors</em>
	///
	/// \return A string containing the names of all authors.
	CAtlString GetAuthors(void);
	/// \brief <em>Retrieves the URL of the website that has information about the control</em>
	///
	/// \return A string containing the URL.
	CAtlString GetHomepage(void);
	/// \brief <em>Retrieves the URL of the website where users can donate via Paypal</em>
	///
	/// \return A string containing the URL.
	CAtlString GetPaypalLink(void);
	/// \brief <em>Retrieves persons, websites, organizations we want to thank especially</em>
	///
	/// \return A string containing the special thanks.
	CAtlString GetSpecialThanks(void);
	/// \brief <em>Retrieves persons, websites, organizations we want to thank</em>
	///
	/// \return A string containing the thanks.
	CAtlString GetThanks(void);
	/// \brief <em>Retrieves the control's version</em>
	///
	/// \return A string containing the version.
	CAtlString GetVersion(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IGroupComparator
	///
	//@{
	/// \brief <em>Two groups must be compared by ID</em>
	///
	/// This method compares two groups by their IDs.
	///
	/// \param[in] groupID1 The unique ID of the first group to compare.
	/// \param[in] groupID2 The unique ID of the second group to compare.
	///
	/// \return -1 if the first group should precede the second; 0 if the groups are equal; 1 if the
	///         second group should precede the first.
	///
	/// \sa sortingSettings, SortGroups, ::CompareGroups
	int CompareGroups(int groupID1, int groupID2);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IItemComparator
	///
	//@{
	/// \brief <em>Two items must be compared by ID</em>
	///
	/// This method compares two listview items by their IDs.
	///
	/// \param[in] itemID1 The unique ID of the first item to compare.
	/// \param[in] itemID2 The unique ID of the second item to compare.
	///
	/// \return -1 if the first item should precede the second; 0 if the items are equal; 1 if the
	///         second item should precede the first.
	///
	/// \sa CompareItemsEx, sortingSettings, SortItems, ::CompareItems
	int CompareItems(LONG itemID1, LONG itemID2);
	/// \brief <em>Two items must be compared by index</em>
	///
	/// This method compares two listview items by their indexes.
	///
	/// \param[in] itemIndex1 The index of the first item to compare.
	/// \param[in] itemIndex2 The index of the second item to compare.
	///
	/// \return -1 if the first item should precede the second; 0 if the items are equal; 1 if the
	///         second item should precede the first.
	///
	/// \sa CompareItems, sortingSettings, SortItems, ::CompareItemsEx
	int CompareItemsEx(int itemIndex1, int itemIndex2);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IPerPropertyBrowsing
	///
	//@{
	/// \brief <em>A displayable string for a property's current value is required</em>
	///
	/// This method is called if the caller's user interface requests a user-friendly description of the
	/// specified property's current value that may be displayed instead of the value itself.
	/// We use this method for enumeration-type properties to display strings like "0 - Icons" instead
	/// of "0 - vIcons".
	///
	/// \param[in] property The ID of the property whose display name is requested.
	/// \param[out] pDescription The setting's display name.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetPredefinedStrings, GetDisplayStringForSetting,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms688734.aspx">IPerPropertyBrowsing::GetDisplayString</a>
	virtual HRESULT STDMETHODCALLTYPE GetDisplayString(DISPID property, BSTR* pDescription);
	/// \brief <em>Displayable strings for a property's predefined values are required</em>
	///
	/// This method is called if the caller's user interface requests user-friendly descriptions of the
	/// specified property's predefined values that may be displayed instead of the values itself.
	/// We use this method for enumeration-type properties to display strings like "0 - Icons" instead
	/// of "0 - vIcons".
	///
	/// \param[in] property The ID of the property whose display names are requested.
	/// \param[in,out] pDescriptions A caller-allocated, counted array structure containing the element
	///                count and address of a callee-allocated array of strings. This array will be
	///                filled with the display name strings.
	/// \param[in,out] pCookies A caller-allocated, counted array structure containing the element
	///                count and address of a callee-allocated array of \c DWORD values. Each \c DWORD
	///                value identifies a predefined value of the property.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetDisplayString, GetPredefinedValue, GetDisplayStringForSetting,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms679724.aspx">IPerPropertyBrowsing::GetPredefinedStrings</a>
	virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings(DISPID property, CALPOLESTR* pDescriptions, CADWORD* pCookies);
	/// \brief <em>A property's predefined value identified by a token is required</em>
	///
	/// This method is called if the caller's user interface requires a property's predefined value that
	/// it has the token of. The token was returned by the \c GetPredefinedStrings method.
	/// We use this method for enumeration-type properties to transform strings like "0 - Icons"
	/// back to the underlying enumeration value (here: \c vIcons).
	///
	/// \param[in] property The ID of the property for which a predefined value is requested.
	/// \param[in] cookie Token identifying which value to return. The token was previously returned
	///            in the \c pCookies array filled by \c IPerPropertyBrowsing::GetPredefinedStrings.
	/// \param[out] pPropertyValue A \c VARIANT that will receive the predefined value.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetPredefinedStrings,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms690401.aspx">IPerPropertyBrowsing::GetPredefinedValue</a>
	virtual HRESULT STDMETHODCALLTYPE GetPredefinedValue(DISPID property, DWORD cookie, VARIANT* pPropertyValue);
	/// \brief <em>A property's property page is required</em>
	///
	/// This method is called to request the \c CLSID of the property page used to edit the specified
	/// property.
	///
	/// \param[in] property The ID of the property whose property page is requested.
	/// \param[out] pPropertyPage The property page's \c CLSID.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms694476.aspx">IPerPropertyBrowsing::MapPropertyToPage</a>
	virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage(DISPID property, CLSID* pPropertyPage);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>Retrieves a displayable string for a specified setting of a specified property</em>
	///
	/// Retrieves a user-friendly description of the specified property's specified setting. This
	/// description may be displayed by the caller's user interface instead of the setting itself.
	/// We use this method for enumeration-type properties to display strings like "1 - At Root" instead
	/// of "1 - lsLinesAtRoot".
	///
	/// \param[in] property The ID of the property for which to retrieve the display name.
	/// \param[in] cookie Token identifying the setting for which to retrieve a description.
	/// \param[out] description The setting's display name.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa GetDisplayString, GetPredefinedStrings, GetResStringWithNumber
	HRESULT GetDisplayStringForSetting(DISPID property, DWORD cookie, CComBSTR& description);

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of ISpecifyPropertyPages
	///
	//@{
	/// \brief <em>The property pages to show are required</em>
	///
	/// This method is called if the property pages, that may be displayed for this object, are required.
	///
	/// \param[out] pPropertyPages A caller-allocated, counted array structure containing the element
	///             count and address of a callee-allocated array of \c GUID structures. Each \c GUID
	///             structure identifies a property page to display.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa CommonProperties, StringProperties,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms687276.aspx">ISpecifyPropertyPages::GetPages</a>
	virtual HRESULT STDMETHODCALLTYPE GetPages(CAUUID* pPropertyPages);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Message handlers
	///
	//@{
	/// \brief <em>\c WM_CHAR handler</em>
	///
	/// Will be called if a \c WM_KEYDOWN message was translated by \c TranslateMessage.
	/// We use this handler to raise the \c KeyPress event.
	///
	/// \sa OnKeyDown, OnEditChar, OnHeaderChar, Raise_KeyPress,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms644955.aspx">TranslateMessage</a>
	LRESULT OnChar(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_CONTEXTMENU handler</em>
	///
	/// Will be called if the control's context menu should be displayed.
	/// We use this handler to raise the \c ContextMenu event.
	///
	/// \sa OnRButtonDown, OnEditContextMenu, OnHeaderContextMenu, Raise_ContextMenu,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms647592.aspx">WM_CONTEXTMENU</a>
	LRESULT OnContextMenu(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_CREATE handler</em>
	///
	/// Will be called right after the control was created.
	/// We use this handler to subclass the parent window, to configure the control window and to raise the
	/// \c RecreatedControlWindow event.
	///
	/// \sa OnDestroy, OnFinalMessage, Raise_RecreatedControlWindow,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632619.aspx">WM_CREATE</a>
	LRESULT OnCreate(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_CTLCOLOREDIT handler</em>
	///
	/// Will be called if an edit control is about to be drawn.
	/// We use this handler to set the colors (background and text) for the contained edit control.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms672119.aspx">WM_CTLCOLOREDIT</a>
	LRESULT OnCtlColorEdit(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_DESTROY handler</em>
	///
	/// Will be called while the control is being destroyed.
	/// We use this handler to tidy up and to raise the \c DestroyedControlWindow event.
	///
	/// \sa OnCreate, OnFinalMessage, Raise_DestroyedControlWindow, OnEditDestroy, OnHeaderDestroy,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632620.aspx">WM_DESTROY</a>
	LRESULT OnDestroy(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_DRAWITEM handler</em>
	///
	/// Will be called if the control is asked to draw a column header.
	/// We use this handler to raise the \c HeaderOwnerDrawItem event.
	///
	/// \sa OnReflectedDrawItem, ListViewColumn::get_OwnerDrawn, Raise_HeaderOwnerDrawItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms673316.aspx">WM_DRAWITEM</a>
	LRESULT OnDrawItem(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_INPUTLANGCHANGE handler</em>
	///
	/// Will be called after an application's input language has been changed.
	/// We use this handler to update the IME mode of the control itself and the contained edit control.
	///
	/// \sa get_IMEMode, get_EditIMEMode,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632629.aspx">WM_INPUTLANGCHANGE</a>
	LRESULT OnInputLangChange(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_KEYDOWN handler</em>
	///
	/// Will be called if a nonsystem key is pressed while the control has the keyboard focus.
	/// We use this handler mainly for the \c MultiSelect and \c SingleExpand features and to raise the
	/// \c KeyDown event.
	///
	/// \sa OnKeyUp, OnChar, OnEditKeyDown, OnHeaderKeyDown, Raise_KeyDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646280.aspx">WM_KEYDOWN</a>
	LRESULT OnKeyDown(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_KEYUP handler</em>
	///
	/// Will be called if a nonsystem key is released while the control has the keyboard focus.
	/// We use this handler to raise the \c KeyUp event.
	///
	/// \sa OnKeyDown, OnChar, OnEditKeyUp, OnHeaderKeyUp, Raise_KeyUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646281.aspx">WM_KEYUP</a>
	LRESULT OnKeyUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_LBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the control's client area using the left mouse
	/// button.
	/// We use this handler to raise the \c DblClick event.
	///
	/// \sa OnDblClkNotification, OnMButtonDblClk, OnRDblClkNotification, OnXButtonDblClk,
	///     OnEditLButtonDblClk, OnHeaderLButtonDblClk, Raise_DblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645606.aspx">WM_LBUTTONDBLCLK</a>
	LRESULT OnLButtonDblClk(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the left mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler mainly for the \c MultiSelect and \c SingleExpand features and to raise the
	/// \c MouseDown event.
	///
	/// \sa OnClickNotification, OnMButtonDown, OnRButtonDown, OnXButtonDown, OnEditLButtonDown,
	///     OnHeaderLButtonDown, Raise_MouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645607.aspx">WM_LBUTTONDOWN</a>
	LRESULT OnLButtonDown(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_LBUTTONUP handler</em>
	///
	/// Will be called if the user releases the left mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler to raise the \c MouseUp event.
	///
	/// \sa OnMButtonUp, OnRButtonUp, OnXButtonUp, OnEditLButtonUp, OnHeaderLButtonUp, Raise_MouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645608.aspx">WM_LBUTTONUP</a>
	LRESULT OnLButtonUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the control's client area using the middle mouse
	/// button.
	/// We use this handler to raise the \c MDblClick event.
	///
	/// \sa OnDblClkNotification, OnLButtonDblClk, OnRDblClkNotification, OnXButtonDblClk,
	///     OnEditMButtonDblClk, OnHeaderMButtonDblClk, Raise_MDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645609.aspx">WM_MBUTTONDBLCLK</a>
	LRESULT OnMButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the middle mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler to raise the \c MouseDown event.
	///
	/// \sa OnLButtonDown, OnRButtonDown, OnXButtonDown, OnEditMButtonDown, OnHeaderMButtonDown,
	///     Raise_MouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645610.aspx">WM_MBUTTONDOWN</a>
	LRESULT OnMButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONUP handler</em>
	///
	/// Will be called if the user releases the middle mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler to raise the \c MouseUp event.
	///
	/// \sa OnLButtonUp, OnRButtonUp, OnXButtonUp, OnEditMButtonUp, OnHeaderMButtonUp, Raise_MouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645611.aspx">WM_MBUTTONUP</a>
	LRESULT OnMButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEACTIVATE handler</em>
	///
	/// Will be called if the control is inactive and the user clicked in its client area.
	/// We use this handler to hide the message from \c CComControl, so that activating the control by
	/// clicking on its caret item doesn't start label-editing mode.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms645612.aspx">WM_MOUSEACTIVATE</a>
	LRESULT OnMouseActivate(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_MOUSEHOVER handler</em>
	///
	/// Will be called if the mouse cursor has been located over the control's client area for a previously
	/// specified number of milliseconds.
	/// We use this handler to raise the \c MouseHover event.
	///
	/// \sa OnEditMouseHover, OnHeaderMouseHover, Raise_MouseHover,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645613.aspx">WM_MOUSEHOVER</a>
	LRESULT OnMouseHover(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSELEAVE handler</em>
	///
	/// Will be called if the user moves the mouse cursor out of the control's client area.
	/// We use this handler to raise the \c MouseLeave event.
	///
	/// \sa OnEditMouseLeave, OnHeaderMouseLeave, Raise_MouseLeave,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645615.aspx">WM_MOUSELEAVE</a>
	LRESULT OnMouseLeave(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEMOVE handler</em>
	///
	/// Will be called if the user moves the mouse while the mouse cursor is located over the control's
	/// client area.
	/// We use this handler to raise the \c MouseMove event.
	///
	/// \sa OnLButtonDown, OnLButtonUp, OnEditMouseMove, OnHeaderMouseMove, OnMouseWheel, Raise_MouseMove,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645616.aspx">WM_MOUSEMOVE</a>
	LRESULT OnMouseMove(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_MOUSEWHEEL and \c WM_MOUSEHWHEEL handler</em>
	///
	/// Will be called if the user rotates the mouse wheel while the mouse cursor is located over the
	/// control's client area.
	/// We use this handler to raise the \c MouseWheel event.
	///
	/// \sa OnEditMouseWheel, OnHeaderMouseWheel, OnMouseMove, Raise_MouseWheel,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645617.aspx">WM_MOUSEWHEEL</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645614.aspx">WM_MOUSEHWHEEL</a>
	LRESULT OnMouseWheel(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_NOTIFY handler</em>
	///
	/// Will be called if the control receives a notification from a child-window (probably the tooltip
	/// control).
	/// We use this handler to allow the user to cancel info tip popups.
	///
	/// \sa OnToolTipGetDispInfoNotificationW,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms672614.aspx">WM_NOTIFY</a>
	LRESULT OnNotify(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_PAINT and \c WM_PRINTCLIENT handler</em>
	///
	/// Will be called if the control needs to be drawn.
	/// We use this handler to avoid the control being drawn by \c CComControl. This makes Vista's graphic
	/// effects work.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms534901.aspx">WM_PAINT</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms534913.aspx">WM_PRINTCLIENT</a>
	LRESULT OnPaint(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_PARENTNOTIFY handler</em>
	///
	/// Will be called if the contained edit or header control is created or destroyed.
	/// We use this handler to raise the \c CreatedEditControlWindow and \c CreatedHeaderControl events.
	///
	/// \remarks We also use this handler for the filter edit control whose parent is the header control.
	///
	/// \sa OnBeginLabelEditNotification, Raise_CreatedEditControlWindow, Raise_CreatedHeaderControlWindow,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632638.aspx">WM_PARENTNOTIFY</a>
	LRESULT OnParentNotify(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the right mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler mainly for the \c MultiSelect feature and to raise the \c MouseDown event.
	///
	/// \sa OnRClickNotification, OnLButtonDown, OnMButtonDown, OnXButtonDown, OnEditRButtonDown,
	///     OnHeaderRButtonDown, Raise_MouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646242.aspx">WM_RBUTTONDOWN</a>
	LRESULT OnRButtonDown(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_RBUTTONUP handler</em>
	///
	/// Will be called if the user releases the right mouse button while the mouse cursor is located over
	/// the control's client area.
	/// We use this handler to raise the \c MouseUp event.
	///
	/// \sa OnLButtonUp, OnMButtonUp, OnXButtonUp, OnEditRButtonUp, OnHeaderRButtonUp, Raise_MouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646243.aspx">WM_RBUTTONUP</a>
	LRESULT OnRButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_SETCURSOR handler</em>
	///
	/// Will be called if the mouse cursor type is required that shall be used while the mouse cursor is
	/// located over the control's client area.
	/// We use this handler to set the mouse cursor type.
	///
	/// \sa get_MouseIcon, get_MousePointer,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms648382.aspx">WM_SETCURSOR</a>
	LRESULT OnSetCursor(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_SETFOCUS handler</em>
	///
	/// Will be called after the control gained the keyboard focus.
	/// We use this handler to work around the problem, that custom draw doesn't work in the first redraw
	/// cycle after the control gained the keyboard focus.
	///
	/// \sa OnEditSetFocus, OnSetFocusNotification, OnEditSetFocus,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646283.aspx">WM_SETFOCUS</a>
	LRESULT OnSetFocus(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_SETFONT handler</em>
	///
	/// Will be called if the control's font shall be set.
	/// We use this handler to synchronize our font settings with the new font.
	///
	/// \sa get_Font,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632642.aspx">WM_SETFONT</a>
	LRESULT OnSetFont(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_SETREDRAW handler</em>
	///
	/// Will be called if the control's redraw state shall be changed.
	/// We use this handler for proper handling of the \c DontRedraw property.
	///
	/// \sa get_DontRedraw,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms534853.aspx">WM_SETREDRAW</a>
	LRESULT OnSetRedraw(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_SETTINGCHANGE handler</em>
	///
	/// Will be called if a system setting was changed.
	/// We use this handler to update our appearance.
	///
	/// \attention This message is posted to top-level windows only, so actually we'll never receive it.
	///
	/// \sa OnThemeChanged,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms725497.aspx">WM_SETTINGCHANGE</a>
	LRESULT OnSettingChange(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_THEMECHANGED handler</em>
	///
	/// Will be called on themable systems if the theme was changed.
	/// We use this handler to update our appearance.
	///
	/// \sa OnSettingChange, Flags::usingThemes,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632650.aspx">WM_THEMECHANGED</a>
	LRESULT OnThemeChanged(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_TIMER handler</em>
	///
	/// Will be called when a timer expires that's associated with the control.
	/// We use this handler for various things, e. g. for the auto-scroll feature.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms644902.aspx">WM_TIMER</a>
	LRESULT OnTimer(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_WINDOWPOSCHANGED handler</em>
	///
	/// Will be called if the control was moved.
	/// We use this handler to resize the control on COM level and to raise the \c ResizedControlWindow
	/// event.
	///
	/// \sa Raise_ResizedControlWindow,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632652.aspx">WM_WINDOWPOSCHANGED</a>
	LRESULT OnWindowPosChanged(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the control's client area using one of the extended
	/// mouse buttons.
	/// We use this handler to raise the \c XDblClick event.
	///
	/// \sa OnDblClkNotification, OnLButtonDblClk, OnMButtonDblClk, OnRDblClkNotification,
	///     OnEditXButtonDblClk, OnHeaderXButtonDblClk, Raise_XDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646244.aspx">WM_XBUTTONDBLCLK</a>
	LRESULT OnXButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses one of the extended mouse buttons while the mouse cursor is
	/// located over the control's client area.
	/// We use this handler to raise the \c MouseDown event.
	///
	/// \sa OnLButtonDown, OnMButtonDown, OnRButtonDown, OnEditXButtonDown, OnHeaderXButtonDown,
	///     Raise_MouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646245.aspx">WM_XBUTTONDOWN</a>
	LRESULT OnXButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONUP handler</em>
	///
	/// Will be called if the user releases one of the extended mouse buttons while the mouse cursor is
	/// located over the control's client area.
	/// We use this handler to raise the \c MouseUp event.
	///
	/// \sa OnLButtonUp, OnMButtonUp, OnRButtonUp, OnEditXButtonUp, OnHeaderXButtonUp, Raise_MouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646246.aspx">WM_XBUTTONUP</a>
	LRESULT OnXButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_DRAWITEM handler</em>
	///
	/// Will be called if the control's parent window is asked to draw a listview item.
	/// We use this handler to raise the \c OwnerDrawItem event.
	///
	/// \sa OnDrawItem, get_OwnerDrawn, Raise_OwnerDrawItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms673316.aspx">WM_DRAWITEM</a>
	LRESULT OnReflectedDrawItem(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MEASUREITEM handler</em>
	///
	/// Will be called if the control's parent window is asked for a listview item's height.
	/// We use this handler for the \c ItemHeight property.
	///
	/// \sa get_ItemHeight,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms673318.aspx">WM_MEASUREITEM</a>
	LRESULT OnReflectedMeasureItem(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_NOTIFY handler</em>
	///
	/// Will be called if the control's parent window receives a notification from the control.
	/// We use this handler for the custom draw support.
	///
	/// \sa OnCustomDrawNotification, OnReflectedNotifyFormat,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775583.aspx">WM_NOTIFY</a>
	LRESULT OnReflectedNotify(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_NOTIFYFORMAT handler</em>
	///
	/// Will be called if the control asks its parent window which format (Unicode/ANSI) the \c WM_NOTIFY
	/// notifications should have.
	/// We use this handler for proper Unicode support.
	///
	/// \sa OnReflectedNotify,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775584.aspx">WM_NOTIFYFORMAT</a>
	LRESULT OnReflectedNotifyFormat(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	#ifdef INCLUDESHELLBROWSERINTERFACE
		/// \brief <em>\c SHBM_HANDSHAKE handler</em>
		///
		/// Will be called if a \c ShellListView control wants to attach to us.
		///
		/// \sa IMessageListener, IInternalMessageListener, IExplorerListView, SHBM_HANDSHAKE
		LRESULT OnHandshake(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*wasHandled*/);
	#endif
	/// \brief <em>\c DI_GETDRAGIMAGE handler</em>
	///
	/// Will be called during OLE drag'n'drop if the control is queried for a drag image.
	///
	/// \sa OLEDrag, OnHeaderGetDragImage, CreateLegacyOLEDragImage, CreateVistaOLEDragImage,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	LRESULT OnGetDragImage(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_CREATEDRAGIMAGE handler</em>
	///
	/// Will be called if the control shall create a drag image.
	/// We use this handler to work-around a bug in \c SysListView32's implementation of
	/// \c LVM_CREATEDRAGIMAGE, which causes the drag image to contain only the icon if the icon's color
	/// depth is 32bpp.
	///
	/// \sa CreateLegacyDragImage,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670623.aspx">LVM_CREATEDRAGIMAGE</a>
	LRESULT OnCreateDragImage(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_DELETECOLUMN handler</em>
	///
	/// Will be called if a column shall be removed from the control.
	/// We use this handler mainly to raise the \c RemovingColumn and \c RemovedColumn events.
	///
	/// \sa OnInsertColumn, OnHeaderInsertItem, Raise_RemovingColumn, Raise_RemovedColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670626.aspx">LVM_DELETECOLUMN</a>
	LRESULT OnDeleteColumn(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_DELETEALLITEMS handler</em>
	///
	/// Will be called if all listview items shall be removed from the control.
	/// We use this handler mainly to raise the \c RemovingItem and \c RemovedItem events.
	///
	/// \sa OnDeleteAllItemsNotification, OnDeleteItem, OnInsertItem, Raise_RemovingItem, Raise_RemovedItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670624.aspx">LVM_DELETEALLITEMS</a>
	LRESULT OnDeleteAllItems(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_DELETEITEM handler</em>
	///
	/// Will be called if a listview item shall be removed from the control.
	/// We use this handler mainly to raise the \c RemovingItem and \c RemovedItem events.
	///
	/// \sa OnDeleteItemNotification, OnDeleteAllItems, OnInsertItem, Raise_RemovingItem, Raise_RemovedItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670627.aspx">LVM_DELETEITEM</a>
	LRESULT OnDeleteItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_FINDITEM handler</em>
	///
	/// Will be called if the control shall search for a listview item.
	/// We use this handler to handle \c LVFI_PARAM for the case that we stored the items' IDs as their
	/// associated data.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms670740.aspx">LVM_FINDITEM</a>
	LRESULT OnFindItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_GETITEM handler</em>
	///
	/// Will be called if some or all of a listview item's attributes are requested from the control.
	/// We use this handler to hide the item's unique ID from the caller and return the item's
	/// associated data out of the \c itemParams list instead.
	///
	/// \sa itemParams, OnSetItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670761.aspx">LVM_GETITEM</a>
	LRESULT OnGetItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_INSERTCOLUMN handler</em>
	///
	/// Will be called if a new listview column shall be inserted into the control.
	/// We use this handler to buffer the column data for the \c VirtualListViewColumn object that will
	/// be created.
	///
	/// \sa OnHeaderInsertItem, OnDeleteColumn, VirtualListViewColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670790.aspx">LVM_INSERTCOLUMN</a>
	LRESULT OnInsertColumn(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_INSERTGROUP handler</em>
	///
	/// Will be called if a new listview group shall be inserted into the control.
	/// We use this handler mainly to raise the \c InsertingGroup and \c InsertedGroup events.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnInsertGroupSorted, OnRemoveGroup, Raise_InsertingGroup, Raise_InsertedGroup,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670791.aspx">LVM_INSERTGROUP</a>
	LRESULT OnInsertGroup(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_INSERTGROUPSORTED handler</em>
	///
	/// Will be called if a new listview group shall be inserted into the control.
	/// We use this handler mainly to raise the \c InsertingGroup and \c InsertedGroup events.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnInsertGroup, OnRemoveGroup, OnSortGroups, Raise_InsertingGroup, Raise_InsertedGroup,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670792.aspx">LVM_INSERTGROUPSORTED</a>
	LRESULT OnInsertGroupSorted(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_INSERTITEM handler</em>
	///
	/// Will be called if a new listview item shall be inserted into the control.
	/// We use this handler mainly to raise the \c InsertingItem and \c InsertedItem events.
	///
	/// \sa OnDeleteItem, OnHeaderInsertItem, Raise_InsertingItem, Raise_InsertedItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670793.aspx">LVM_INSERTITEM</a>
	LRESULT OnInsertItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_REMOVEALLGROUPS handler</em>
	///
	/// Will be called if all listview groups shall be removed from the control.
	/// We use this handler mainly to raise the \c RemovingGroup and \c RemovedGroup events.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnRemoveGroup, OnInsertGroup, OnInsertGroupSorted, Raise_RemovingGroup, Raise_RemovedGroup,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670808.aspx">LVM_REMOVEALLGROUPS</a>
	LRESULT OnRemoveAllGroups(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_REMOVEGROUP handler</em>
	///
	/// Will be called if a listview group shall be removed from the control.
	/// We use this handler mainly to raise the \c RemovingGroup and \c RemovedGroup events.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnRemoveAllGroups, OnInsertGroup, OnInsertGroupSorted, Raise_RemovingGroup, Raise_RemovedGroup,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670809.aspx">LVM_REMOVEGROUP</a>
	LRESULT OnRemoveGroup(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETBKIMAGE handler</em>
	///
	/// Will be called if the control's background image shall be changed.
	/// We use this handler to synchronize our settings.
	///
	/// \sa get_BkImage, get_BkImageStyle, get_BkImagePositionX, get_BkImagePositionY,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670814.aspx">LVM_SETBKIMAGE</a>
	LRESULT OnSetBkImage(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETEXTENDEDLISTVIEWSTYLE handler</em>
	///
	/// Will be called if one of the control's extended styles shall be changed.
	/// We use this handler to synchronize our cached settings.
	///
	/// \sa cachedSettings, get_HotTracking, OnMouseHover,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670821.aspx">LVM_SETEXTENDEDLISTVIEWSTYLE</a>
	LRESULT OnSetExtendedListViewStyle(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_SETGROUPINFO handler</em>
	///
	/// Will be called if a listview group shall be updated.
	/// We use this handler mainly to update the \c groups vector.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa groups,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670823.aspx">LVM_SETGROUPINFO</a>
	LRESULT OnSetGroupInfo(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETHOTCURSOR handler</em>
	///
	/// Will be called if the control's hot cursor shall be set.
	/// We use this handler to synchronize our picture object with the new hot cursor.
	///
	/// \sa get_HotMouseIcon,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670828.aspx">LVM_SETHOTCURSOR</a>
	LRESULT OnSetHotCursor(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETHOTITEM handler</em>
	///
	/// Will be called if the control's hot item shall be changed.
	/// We use this handler to synchronize our cached settings and to raise the \c HotItemChanging
	/// and \c HotItemChanged events.
	///
	/// \sa cachedSettings, get_HotItem, Raise_HotItemChanging, Raise_HotItemChanged,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670832.aspx">LVM_SETHOTITEM</a>
	LRESULT OnSetHotItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETIMAGELIST handler</em>
	///
	/// Will be called if one of the control's imagelists shall be changed.
	/// We use this handler to synchronize our cached settings.
	///
	/// \sa cachedSettings, get_hImageList,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670836.aspx">LVM_SETIMAGELIST</a>
	LRESULT OnSetImageList(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETINFOTIP handler</em>
	///
	/// Will be called if an item's info tip text shall be set.
	/// We use this handler to raise the \c SettingItemInfoTipText event.
	///
	/// \sa Raise_SettingItemInfoTipText,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb761180.aspx">LVM_SETINFOTIP</a>
	LRESULT OnSetInfoTip(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_SETITEM handler</em>
	///
	/// Will be called if the control is requested to update some or all of a listview item's attributes.
	/// We use this handler to avoid the item's unique ID is overwritten and store the item's
	/// associated data in the \c itemParams list instead.
	///
	/// \sa itemParams, OnGetItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670845.aspx">LVM_SETITEM</a>
	LRESULT OnSetItem(UINT message, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_SETITEMCOUNT handler</em>
	///
	/// Will be called if the number of listview items in the virtual listview shall be changed.
	/// We use this handler to synchronize the \c VirtualItemCount property.
	///
	/// \sa get_VirtualItemCount,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670847.aspx">LVM_SETITEMCOUNT</a>
	LRESULT OnSetItemCount(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETVIEW handler</em>
	///
	/// Will be called if the control's view mode shall be changed.
	/// We use this handler to set the correct large imagelist.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa put_View, get_hImageList,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670909.aspx">LVM_SETVIEW</a>
	LRESULT OnSetView(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SETWORKAREAS handler</em>
	///
	/// Will be called if the control's working areas shall be redefined.
	/// We use this handler to raise the \c ChangingWorkAreas and \c ChangedWorkAreas events.
	///
	/// \sa Raise_ChangingWorkAreas, Raise_ChangedWorkAreas,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms671038.aspx">LVM_SETWORKAREAS</a>
	LRESULT OnSetWorkAreas(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SORTGROUPS handler</em>
	///
	/// Will be called if the control's listview groups shall be sorted.
	/// We use this handler to synchronize the groups' positions with the \c groups vector.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa groups, OnInsertGroupSorted, OnSortItems, OnSortItemsEx,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms671039.aspx">LVM_SORTGROUPS</a>
	LRESULT OnSortGroups(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVM_SORTITEMS handler</em>
	///
	/// Will be called if the control's listview items shall be sorted.
	/// We use this handler to synchronize the \c itemIDs map.
	///
	/// \sa OnSortItemsEx, OnSortGroups, itemIDs,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms671042.aspx">LVM_SORTITEMS</a>
	LRESULT OnSortItems(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c LVM_SORTITEMSEX handler</em>
	///
	/// Will be called if the control's listview items shall be sorted.
	/// We use this handler to synchronize the \c itemIDs map.
	///
	/// \remarks Requires comctl32.dll version 5.80 or higher.
	///
	/// \sa OnSortItems, OnSortGroups, itemIDs,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms671044.aspx">LVM_SORTITEMSEX</a>
	LRESULT OnSortItemsEx(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_CHAR handler</em>
	///
	/// Will be called if a \c WM_KEYDOWN message was translated by \c TranslateMessage.
	/// We use this handler to raise the \c EditKeyPress event.
	///
	/// \sa OnEditChange, OnEditKeyDown, OnChar, OnHeaderChar, Raise_EditKeyPress,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms644955.aspx">TranslateMessage</a>
	LRESULT OnEditChar(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_CONTEXTMENU handler</em>
	///
	/// Will be called if the contained edit control's context menu should be displayed.
	/// We use this handler to raise the \c EditContextMenu event.
	///
	/// \sa OnEditRButtonDown, OnContextMenu, OnHeaderContextMenu, Raise_EditContextMenu,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms647592.aspx">WM_CONTEXTMENU</a>
	LRESULT OnEditContextMenu(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_DESTROY handler</em>
	///
	/// Will be called while the contained edit control is being destroyed.
	/// We use this handler to raise the \c DestroyedEditControlWindow event.
	///
	/// \sa OnEndLabelEditNotification, OnDestroy, OnHeaderDestroy, Raise_DestroyedEditControlWindow,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632620.aspx">WM_DESTROY</a>
	LRESULT OnEditDestroy(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_KEYDOWN handler</em>
	///
	/// Will be called if a nonsystem key is pressed while the contained edit control has the keyboard focus.
	/// We use this handler to raise the \c EditKeyDown event.
	///
	/// \sa OnEditKeyUp, OnEditChar, OnKeyDown, OnHeaderKeyDown, Raise_EditKeyDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646280.aspx">WM_KEYDOWN</a>
	LRESULT OnEditKeyDown(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_KEYUP handler</em>
	///
	/// Will be called if a nonsystem key is released while the contained edit control has the keyboard
	/// focus.
	/// We use this handler to raise the \c EditKeyUp event.
	///
	/// \sa OnEditKeyDown, OnEditChar, OnKeyUp, OnHeaderKeyUp, Raise_EditKeyUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646281.aspx">WM_KEYUP</a>
	LRESULT OnEditKeyUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_KILLFOCUS handler</em>
	///
	/// Will be called immediately before the contained edit control loses the keyboard focus.
	/// We use this handler to raise the \c EditLostFocus event.
	///
	/// \sa OnEditSetFocus, Raise_EditLostFocus,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646282.aspx">WM_KILLFOCUS</a>
	LRESULT OnEditKillFocus(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the contained edit control's client area using the
	/// left mouse button.
	/// We use this handler to raise the \c EditDblClick event.
	///
	/// \sa OnEditMButtonDblClk, OnEditRButtonDblClk, OnEditXButtonDblClk, OnDblClkNotification,
	///     OnHeaderItemDblClkNotification, Raise_EditDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645606.aspx">WM_LBUTTONDBLCLK</a>
	LRESULT OnEditLButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the left mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseDown event.
	///
	/// \sa OnEditMButtonDown, OnEditRButtonDown, OnEditXButtonDown, OnLButtonDown, OnHeaderLButtonDown,
	///     Raise_EditMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645607.aspx">WM_LBUTTONDOWN</a>
	LRESULT OnEditLButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONUP handler</em>
	///
	/// Will be called if the user releases the left mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseUp event.
	///
	/// \sa OnEditMButtonUp, OnEditRButtonUp, OnEditXButtonUp, OnLButtonUp, OnHeaderLButtonUp,
	///     Raise_EditMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645608.aspx">WM_LBUTTONUP</a>
	LRESULT OnEditLButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the contained edit control's client area using the
	/// middle mouse button.
	/// We use this handler to raise the \c EditMDblClick event.
	///
	/// \sa OnEditLButtonDblClk, OnEditRButtonDblClk, OnEditXButtonDblClk, OnMButtonDblClk,
	///     OnHeaderMButtonDblClk, Raise_EditMDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645609.aspx">WM_MBUTTONDBLCLK</a>
	LRESULT OnEditMButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the middle mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseDown event.
	///
	/// \sa OnEditLButtonDown, OnEditRButtonDown, OnEditXButtonDown, OnMButtonDown, OnHeaderMButtonDown,
	///     Raise_EditMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645610.aspx">WM_MBUTTONDOWN</a>
	LRESULT OnEditMButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONUP handler</em>
	///
	/// Will be called if the user releases the middle mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseUp event.
	///
	/// \sa OnEditLButtonUp, OnEditRButtonUp, OnEditXButtonUp, OnMButtonUp, OnHeaderMButtonUp,
	///     Raise_EditMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645611.aspx">WM_MBUTTONUP</a>
	LRESULT OnEditMButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEHOVER handler</em>
	///
	/// Will be called if the mouse cursor has been located over the contained edit control's client area
	/// for a previously specified number of milliseconds.
	/// We use this handler to raise the \c EditMouseHover event.
	///
	/// \sa OnMouseHover, OnHeaderMouseHover, Raise_EditMouseHover,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645613.aspx">WM_MOUSEHOVER</a>
	LRESULT OnEditMouseHover(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSELEAVE handler</em>
	///
	/// Will be called if the user moves the mouse cursor out of the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseLeave event.
	///
	/// \sa OnMouseLeave, OnHeaderMouseLeave, Raise_EditMouseLeave,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645615.aspx">WM_MOUSELEAVE</a>
	LRESULT OnEditMouseLeave(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEMOVE handler</em>
	///
	/// Will be called if the user moves the mouse while the mouse cursor is located over the contained edit
	/// control's client area.
	/// We use this handler to raise the \c EditMouseMove event.
	///
	/// \sa OnEditLButtonDown, OnEditLButtonUp, OnMouseMove, OnHeaderMouseMove, OnEditMouseWheel,
	///     Raise_EditMouseMove,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645616.aspx">WM_MOUSEMOVE</a>
	LRESULT OnEditMouseMove(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEWHEEL and \c WM_MOUSEHWHEEL handler</em>
	///
	/// Will be called if the user rotates the mouse wheel while the mouse cursor is located over the
	/// contained edit control's client area.
	/// We use this handler to raise the \c EditMouseWheel event.
	///
	/// \sa OnMouseWheel, OnHeaderMouseWheel, OnEditMouseMove, Raise_EditMouseWheel,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645617.aspx">WM_MOUSEWHEEL</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645614.aspx">WM_MOUSEHWHEEL</a>
	LRESULT OnEditMouseWheel(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the contained edit control's client area using the
	/// right mouse button.
	/// We use this handler to raise the \c EditRDblClick event.
	///
	/// \sa OnEditLButtonDblClk, OnEditMButtonDblClk, OnEditXButtonDblClk, OnRDblClkNotification,
	///     OnHeaderRButtonDblClk, Raise_EditRDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646241.aspx">WM_RBUTTONDBLCLK</a>
	LRESULT OnEditRButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the right mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseDown event.
	///
	/// \sa OnEditLButtonDown, OnEditMButtonDown, OnEditXButtonDown, OnRButtonDown, OnHeaderRButtonDown,
	///     Raise_EditMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646242.aspx">WM_RBUTTONDOWN</a>
	LRESULT OnEditRButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONUP handler</em>
	///
	/// Will be called if the user releases the right mouse button while the mouse cursor is located over
	/// the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseUp event.
	///
	/// \sa OnEditLButtonUp, OnEditMButtonUp, OnEditXButtonUp, OnRButtonUp, OnHeaderRButtonUp,
	///     Raise_EditMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646243.aspx">WM_RBUTTONUP</a>
	LRESULT OnEditRButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_SETFOCUS handler</em>
	///
	/// Will be called after the contained edit control gained the keyboard focus.
	/// We use this handler to raise the \c EditGotFocus event and to initialize IME for the edit control.
	///
	/// \sa OnEditKillFocus, OnSetFocusNotification, get_EditIMEMode, Raise_EditGotFocus,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646283.aspx">WM_SETFOCUS</a>
	LRESULT OnEditSetFocus(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the contained edit control's client area using one of
	/// the extended mouse buttons.
	/// We use this handler to raise the \c EditXDblClick event.
	///
	/// \sa OnEditLButtonDblClk, OnEditMButtonDblClk, OnEditRButtonDblClk, OnHeaderXButtonDblClk,
	///     Raise_EditXDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646244.aspx">WM_XBUTTONDBLCLK</a>
	LRESULT OnEditXButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses one of the extended mouse buttons while the mouse cursor is
	/// located over the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseDown event.
	///
	/// \sa OnEditLButtonDown, OnEditMButtonDown, OnEditRButtonDown, OnXButtonDown, OnHeaderXButtonDown,
	///     Raise_EditMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646245.aspx">WM_XBUTTONDOWN</a>
	LRESULT OnEditXButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONUP handler</em>
	///
	/// Will be called if the user releases one of the extended mouse buttons while the mouse cursor is
	/// located over the contained edit control's client area.
	/// We use this handler to raise the \c EditMouseUp event.
	///
	/// \sa OnEditLButtonUp, OnEditMButtonUp, OnEditRButtonUp, OnXButtonUp, OnHeaderXButtonUp,
	///     Raise_EditMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646246.aspx">WM_XBUTTONUP</a>
	LRESULT OnEditXButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_CHAR handler</em>
	///
	/// Will be called if a \c WM_KEYDOWN message was translated by \c TranslateMessage.
	/// We use this handler to raise the \c HeaderKeyPress event.
	///
	/// \sa OnHeaderKeyDown, OnChar, OnHeaderChar, Raise_HeaderKeyPress,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646276.aspx">WM_CHAR</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms644955.aspx">TranslateMessage</a>
	LRESULT OnHeaderChar(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_CONTEXTMENU handler</em>
	///
	/// Will be called if the header control's context menu should be displayed.
	/// We use this handler to raise the \c HeaderContextMenu event.
	///
	/// \sa OnHeaderRButtonDown, OnContextMenu, OnEditContextMenu, Raise_HeaderContextMenu,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms647592.aspx">WM_CONTEXTMENU</a>
	LRESULT OnHeaderContextMenu(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_DESTROY handler</em>
	///
	/// Will be called while the header control is being destroyed.
	/// We use this handler to raise the \c DestroyedHeaderControlWindow event.
	///
	/// \sa OnDestroy, OnEditDestroy, Raise_DestroyedHeaderControlWindow,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms632620.aspx">WM_DESTROY</a>
	LRESULT OnHeaderDestroy(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_KEYDOWN handler</em>
	///
	/// Will be called if a nonsystem key is pressed while the contained header control has the keyboard
	/// focus.
	/// We use this handler to raise the \c HeaderKeyDown event.
	///
	/// \sa OnHeaderKeyUp, OnHeaderChar, OnKeyDown, OnEditKeyDown, Raise_HeaderKeyDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646280.aspx">WM_KEYDOWN</a>
	LRESULT OnHeaderKeyDown(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_KEYUP handler</em>
	///
	/// Will be called if a nonsystem key is released while the contained header control has the keyboard
	/// focus.
	/// We use this handler to raise the \c HeaderKeyUp event.
	///
	/// \sa OnHeaderKeyDown, OnHeaderChar, OnKeyUp, OnEditKeyUp, Raise_HeaderKeyUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646281.aspx">WM_KEYUP</a>
	LRESULT OnHeaderKeyUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_KILLFOCUS handler</em>
	///
	/// Will be called immediately before the contained header control loses the keyboard focus.
	/// We use this handler to raise the \c HeaderLostFocus event.
	///
	/// \sa OnHeaderSetFocus, Raise_HeaderLostFocus,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646282.aspx">WM_KILLFOCUS</a>
	LRESULT OnHeaderKillFocus(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the header control's client area using the left
	/// mouse button.
	/// We use this handler to raise the \c HeaderDblClick event.
	///
	/// \sa OnHeaderItemDblClkNotification, OnHeaderMButtonDblClk, OnHeaderRButtonDblClk,
	///     OnHeaderXButtonDblClk, OnLButtonDblClk, OnEditLButtonDblClk, Raise_HeaderDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645606.aspx">WM_LBUTTONDBLCLK</a>
	LRESULT OnHeaderLButtonDblClk(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_LBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the left mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseDown event.
	///
	/// \sa OnColumnClickNotification, OnHeaderMButtonDown, OnHeaderRButtonDown, OnHeaderXButtonDown,
	///     OnLButtonDown, OnEditLButtonDown, Raise_HeaderMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645607.aspx">WM_LBUTTONDOWN</a>
	LRESULT OnHeaderLButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_LBUTTONUP handler</em>
	///
	/// Will be called if the user releases the left mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseUp event.
	///
	/// \sa OnHeaderMButtonUp, OnHeaderRButtonUp, OnHeaderXButtonUp, OnLButtonUp, OnEditLButtonUp,
	///     Raise_HeaderMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645608.aspx">WM_LBUTTONUP</a>
	LRESULT OnHeaderLButtonUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_MBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the header control's client area using the middle
	/// mouse button.
	/// We use this handler to raise the \c HeaderMDblClick event.
	///
	/// \sa OnHeaderItemDblClkNotification, OnHeaderLButtonDblClk, OnHeaderRButtonDblClk,
	///     OnHeaderXButtonDblClk, OnMButtonDblClk, OnEditMButtonDblClk, Raise_HeaderMDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645609.aspx">WM_MBUTTONDBLCLK</a>
	LRESULT OnHeaderMButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the middle mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseDown event.
	///
	/// \sa OnHeaderLButtonDown, OnHeaderRButtonDown, OnHeaderXButtonDown, OnMButtonDown, OnEditMButtonDown,
	///     Raise_HeaderMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645610.aspx">WM_MBUTTONDOWN</a>
	LRESULT OnHeaderMButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MBUTTONUP handler</em>
	///
	/// Will be called if the user releases the middle mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseUp event.
	///
	/// \sa OnHeaderLButtonUp, OnHeaderRButtonUp, OnHeaderXButtonUp, OnMButtonUp, OnEditMButtonUp,
	///     Raise_HeaderMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645611.aspx">WM_MBUTTONUP</a>
	LRESULT OnHeaderMButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEHOVER handler</em>
	///
	/// Will be called if the mouse cursor has been located over the header control's client area for a
	/// previously specified number of milliseconds.
	/// We use this handler to raise the \c HeaderMouseHover event.
	///
	/// \sa OnMouseHover, OnEditMouseHover, Raise_HeaderMouseHover,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645613.aspx">WM_MOUSEHOVER</a>
	LRESULT OnHeaderMouseHover(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_MOUSELEAVE handler</em>
	///
	/// Will be called if the user moves the mouse cursor out of the header control's client area.
	/// We use this handler to raise the \c HeaderMouseLeave event.
	///
	/// \sa OnMouseLeave, OnEditMouseLeave, Raise_HeaderMouseLeave,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645615.aspx">WM_MOUSELEAVE</a>
	LRESULT OnHeaderMouseLeave(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEMOVE handler</em>
	///
	/// Will be called if the user moves the mouse while the mouse cursor is located over the header
	/// control's client area.
	/// We use this handler to raise the \c HeaderMouseMove event.
	///
	/// \sa OnHeaderLButtonDown, OnHeaderLButtonUp, OnMouseMove, OnEditMouseMove, OnHeaderMouseWheel,
	///     Raise_HeaderMouseMove,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645616.aspx">WM_MOUSEMOVE</a>
	LRESULT OnHeaderMouseMove(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_MOUSEWHEEL and \c WM_MOUSEHWHEEL handler</em>
	///
	/// Will be called if the user rotates the mouse wheel while the mouse cursor is located over the
	/// header control's client area.
	/// We use this handler to raise the \c HeaderMouseWheel event.
	///
	/// \sa OnMouseWheel, OnEditMouseWheel, OnHeaderMouseMove, Raise_HeaderMouseWheel,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645617.aspx">WM_MOUSEWHEEL</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms645614.aspx">WM_MOUSEHWHEEL</a>
	LRESULT OnHeaderMouseWheel(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the header control's client area using the right
	/// mouse button.
	/// We use this handler to raise the \c HeaderRDblClick event.
	///
	/// \sa OnHeaderItemDblClkNotification, OnHeaderLButtonDblClk, OnHeaderMButtonDblClk,
	///     OnHeaderXButtonDblClk, OnRDblClkNotification, OnEditRButtonDblClk, Raise_HeaderRDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646241.aspx">WM_RBUTTONDBLCLK</a>
	LRESULT OnHeaderRButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses the right mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseDown event.
	///
	/// \sa OnHeaderLButtonDown, OnHeaderMButtonDown, OnHeaderXButtonDown, OnRButtonDown, OnEditRButtonDown,
	///     Raise_HeaderMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646242.aspx">WM_RBUTTONDOWN</a>
	LRESULT OnHeaderRButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_RBUTTONUP handler</em>
	///
	/// Will be called if the user releases the right mouse button while the mouse cursor is located over
	/// the header control's client area.
	/// We use this handler to raise the \c HeaderMouseUp event.
	///
	/// \sa OnHeaderLButtonUp, OnHeaderMButtonUp, OnHeaderXButtonUp, OnRButtonUp, OnEditRButtonUp,
	///     Raise_HeaderMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646243.aspx">WM_RBUTTONUP</a>
	LRESULT OnHeaderRButtonUp(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c WM_SETFOCUS handler</em>
	///
	/// Will be called after the contained header control gained the keyboard focus.
	/// We use this handler to raise the \c HeaderGotFocus event.
	///
	/// \sa OnHeaderKillFocus, Raise_HeaderGotFocus,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646283.aspx">WM_SETFOCUS</a>
	LRESULT OnHeaderSetFocus(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDBLCLK handler</em>
	///
	/// Will be called if the user double-clicked into the header control's client area using one of the
	/// extended mouse buttons.
	/// We use this handler to raise the \c HeaderXDblClick event.
	///
	/// \sa OnHeaderItemDblClkNotification, OnHeaderLButtonDblClk, OnHeaderMButtonDblClk,
	///     OnHeaderRButtonDblClk, OnXButtonDblClk, OnEditXButtonDblClk, Raise_HeaderXDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646244.aspx">WM_XBUTTONDBLCLK</a>
	LRESULT OnHeaderXButtonDblClk(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONDOWN handler</em>
	///
	/// Will be called if the user presses one of the extended mouse buttons while the mouse cursor is
	/// located over the header control's client area.
	/// We use this handler to raise the \c HeaderMouseDown event.
	///
	/// \sa OnHeaderLButtonDown, OnHeaderMButtonDown, OnHeaderRButtonDown, OnXButtonDown, OnEditXButtonDown,
	///     Raise_HeaderMouseDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646245.aspx">WM_XBUTTONDOWN</a>
	LRESULT OnHeaderXButtonDown(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c WM_XBUTTONUP handler</em>
	///
	/// Will be called if the user releases one of the extended mouse buttons while the mouse cursor is
	/// located over the header control's client area.
	/// We use this handler to raise the \c HeaderMouseUp event.
	///
	/// \sa OnHeaderLButtonUp, OnHeaderMButtonUp, OnHeaderRButtonUp, OnXButtonUp, OnEditXButtonUp,
	///     Raise_HeaderMouseUp,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646246.aspx">WM_XBUTTONUP</a>
	LRESULT OnHeaderXButtonUp(UINT /*message*/, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c DI_GETDRAGIMAGE handler</em>
	///
	/// Will be called during OLE drag'n'drop if the header control is queried for a drag image.
	///
	/// \sa HeaderOLEDrag, OnGetDragImage, CreateLegacyOLEHeaderDragImage, CreateVistaOLEHeaderDragImage,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms646443.aspx">DI_GETDRAGIMAGE</a>
	LRESULT OnHeaderGetDragImage(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c HDM_GETITEM handler</em>
	///
	/// Will be called if some or all of a listview column's attributes are requested from the header
	/// control.
	/// We use this handler to hide the column's unique ID from the caller and return the column's
	/// associated data out of the \c columnParams list instead.
	///
	/// \sa columnParams, OnHeaderSetItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775335.aspx">HDM_GETITEM</a>
	LRESULT OnHeaderGetItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDM_INSERTITEM handler</em>
	///
	/// Will be called if a new column header shall be inserted into the header control.
	/// We use this handler mainly to raise the \c InsertingColumn and \c InsertedColumn events.
	///
	/// \sa OnDeleteColumn, OnInsertItem, Raise_InsertingColumn, Raise_InsertedColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms672008.aspx">HDM_INSERTITEM</a>
	LRESULT OnHeaderInsertItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDM_SETFILTERCHANGETIMEOUT handler</em>
	///
	/// Will be called if the number of milliseconds, that will pass before the \c FilterChanged event is
	/// fired, shall be changed.
	/// We use this handler to synchronize our \c properties member.
	///
	/// \sa get_FilterChangedTimeout, put_FilterChangedTimeout,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms672012.aspx">HDM_SETFILTERCHANGETIMEOUT</a>
	LRESULT OnHeaderSetFilterChangeTimeout(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& wasHandled);
	/// \brief <em>\c HDM_SETIMAGELIST handler</em>
	///
	/// Will be called if one of the contained header control's imagelists shall be changed.
	/// We use this handler to synchronize our cached settings.
	///
	/// \sa cachedSettings, get_hImageList,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms672014.aspx">HDM_SETIMAGELIST</a>
	LRESULT OnHeaderSetImageList(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDM_SETITEM handler</em>
	///
	/// Will be called if the control is requested to update some or all of a listview column's attributes.
	/// We use this handler to avoid the column's unique ID is overwritten and store the column's
	/// associated data in the \c columnParams list instead.
	///
	/// \sa columnParams, OnHeaderGetItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775367.aspx">HDM_SETITEM</a>
	LRESULT OnHeaderSetItem(UINT message, WPARAM wParam, LPARAM lParam, BOOL& wasHandled);
	//@}
	//////////////////////////////////////////////////////////////////////

	#ifdef INCLUDESHELLBROWSERINTERFACE
		//////////////////////////////////////////////////////////////////////
		/// \name Internal message handlers
		///
		//@{
		/// \brief <em>Handles the \c EXLVM_ADDCOLUMN message</em>
		///
		/// \sa EXLVM_ADDCOLUMN
		HRESULT OnInternalAddColumn(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_COLUMNIDTOINDEX message</em>
		///
		/// \sa EXLVM_COLUMNIDTOINDEX
		HRESULT OnInternalColumnIDToIndex(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_COLUMNINDEXTOID message</em>
		///
		/// \sa EXLVM_COLUMNINDEXTOID
		HRESULT OnInternalColumnIndexToID(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETCOLUMNBYID message</em>
		///
		/// \sa EXLVM_GETCOLUMNBYID
		HRESULT OnInternalGetColumnByID(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETSORTARROW message</em>
		///
		/// \sa EXLVM_SETSORTARROW
		HRESULT OnInternalSetSortArrow(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETCOLUMNBITMAP message</em>
		///
		/// \sa EXLVM_GETCOLUMNBITMAP
		HRESULT OnInternalGetColumnBitmap(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETCOLUMNBITMAP message</em>
		///
		/// \sa EXLVM_SETCOLUMNBITMAP
		HRESULT OnInternalSetColumnBitmap(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_ADDITEM message</em>
		///
		/// \sa EXLVM_ADDITEM
		HRESULT OnInternalAddItem(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_ITEMIDTOINDEX message</em>
		///
		/// \sa EXLVM_ITEMIDTOINDEX
		HRESULT OnInternalItemIDToIndex(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_ITEMINDEXTOID message</em>
		///
		/// \sa EXLVM_ITEMINDEXTOID
		HRESULT OnInternalItemIndexToID(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETITEMBYID message</em>
		///
		/// \sa EXLVM_GETITEMBYID
		HRESULT OnInternalGetItemByID(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_CREATEITEMCONTAINER message</em>
		///
		/// \sa EXLVM_CREATEITEMCONTAINER
		HRESULT OnInternalCreateItemContainer(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETITEMIDSFROMVARIANT message</em>
		///
		/// \sa EXLVM_GETITEMIDSFROMVARIANT
		HRESULT OnInternalGetItemIDsFromVariant(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETITEMICONINDEX message</em>
		///
		/// \sa EXLVM_SETITEMICONINDEX
		HRESULT OnInternalSetItemIconIndex(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETITEMPOSITION message</em>
		///
		/// \sa EXLVM_GETITEMPOSITION
		HRESULT OnInternalGetItemPosition(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETITEMPOSITION message</em>
		///
		/// \sa EXLVM_SETITEMPOSITION
		HRESULT OnInternalSetItemPosition(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_MOVEDRAGGEDITEMS message</em>
		///
		/// \sa EXLVM_MOVEDRAGGEDITEMS
		HRESULT OnInternalMoveDraggedItems(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_HITTEST message</em>
		///
		/// \sa EXLVM_HITTEST
		HRESULT OnInternalHitTest(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SORTITEMS message</em>
		///
		/// \sa EXLVM_SORTITEMS
		HRESULT OnInternalSortItems(UINT /*message*/, WPARAM wParam, LPARAM /*lParam*/);
		/// \brief <em>Handles the \c EXLVM_GETSORTORDER message</em>
		///
		/// \sa EXLVM_GETSORTORDER
		HRESULT OnInternalGetSortOrder(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETSORTORDER message</em>
		///
		/// \sa EXLVM_SETSORTORDER
		HRESULT OnInternalSetSortOrder(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETCLOSESTINSERTMARKPOSITION message</em>
		///
		/// \sa EXLVM_GETCLOSESTINSERTMARKPOSITION
		HRESULT OnInternalGetClosestInsertMarkPosition(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETINSERTMARK message</em>
		///
		/// \sa EXLVM_SETINSERTMARK
		HRESULT OnInternalSetInsertMark(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETDROPHILITEDITEM message</em>
		///
		/// \sa EXLVM_SETDROPHILITEDITEM
		HRESULT OnInternalSetDropHilitedItem(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_CONTROLISDRAGSOURCE message</em>
		///
		/// \sa EXLVM_CONTROLISDRAGSOURCE
		HRESULT OnInternalControlIsDragSource(UINT /*message*/, WPARAM /*wParam*/, LPARAM /*lParam*/);
		/// \brief <em>Handles the \c EXLVM_FIREDRAGDROPEVENT message</em>
		///
		/// \sa EXLVM_FIREDRAGDROPEVENT
		HRESULT OnInternalFireDragDropEvent(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_OLEDRAG message</em>
		///
		/// \sa EXLVM_OLEDRAG
		HRESULT OnInternalOLEDrag(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETIMAGELIST message</em>
		///
		/// \sa EXLVM_GETIMAGELIST
		HRESULT OnInternalGetImageList(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_SETIMAGELIST message</em>
		///
		/// \sa EXLVM_SETIMAGELIST
		HRESULT OnInternalSetImageList(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETVIEWMODE message</em>
		///
		/// \sa EXLVM_GETVIEWMODE
		HRESULT OnInternalGetViewMode(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETTILEVIEWITEMLINES message</em>
		///
		/// \sa EXLVM_GETTILEVIEWITEMLINES
		HRESULT OnInternalGetTileViewItemLines(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_GETCOLUMNHEADERVISIBILITY message</em>
		///
		/// \sa EXLVM_GETCOLUMNHEADERVISIBILITY
		HRESULT OnInternalGetColumnHeaderVisibility(UINT /*message*/, WPARAM /*wParam*/, LPARAM lParam);
		/// \brief <em>Handles the \c EXLVM_ISITEMVISIBLE message</em>
		///
		/// \sa EXLVM_ISITEMVISIBLE
		HRESULT OnInternalIsItemVisible(UINT /*message*/, WPARAM wParam, LPARAM lParam);
		//@}
		//////////////////////////////////////////////////////////////////////
	#endif

	//////////////////////////////////////////////////////////////////////
	/// \name Notification handlers
	///
	//@{
	/// \brief <em>\c NM_CLICK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user clicked into the control's
	/// client area using the left mouse button.
	/// We use this handler to raise the \c Click event.
	///
	/// \sa OnLButtonDown, OnRClickNotification, Raise_Click,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774863.aspx">NM_CLICK (list view)</a>
	LRESULT OnClickNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c NM_DBLCLK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user double-clicked into the
	/// control's client area using the left mouse button.
	/// We use this handler to raise the \c DblClick event.
	///
	/// \sa OnLButtonDblClk, OnMButtonDblClk, OnRDblClkNotification, OnXButtonDblClk, OnEditLButtonDblClk,
	///     OnHeaderItemDblClkNotification, Raise_DblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774867.aspx">NM_DBLCLK (list view)</a>
	LRESULT OnDblClkNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c NM_RCLICK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user clicked into the control's
	/// client area using the right mouse button.
	/// We use this handler to raise the \c RClick event.
	///
	/// \sa OnRButtonDown, OnClickNotification, Raise_RClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774873.aspx">NM_RCLICK (list view)</a>
	LRESULT OnRClickNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c NM_RDBLCLK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user double-clicked into the
	/// control's client area using the right mouse button.
	/// We use this handler to raise the \c RDblClick event.
	///
	/// \sa OnLButtonDblClk, OnDblClkNotification, OnMButtonDblClk, OnXButtonDblClk, OnEditRButtonDblClk,
	///     Raise_RDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774875.aspx">NM_RDBLCLK (list view)</a>
	LRESULT OnRDblClkNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c NM_SETFOCUS handler</em>
	///
	/// Will be called if the control's parent window is notified, that the control has gained the keyboard
	/// focus.
	/// We use this handler to initialize IME.
	///
	/// \sa OnSetFocus, OnEditSetFocus, get_IMEMode,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774881.aspx">NM_SETFOCUS (list view)</a>
	LRESULT OnSetFocusNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c LVN_ASYNCDRAWN handler</em>
	///
	/// Will be called if the control's parent window is notified, that drawing a listview group's or item's
	/// associated image has failed.
	/// We use this handler to raise the \c ItemAsynchronousDrawFailed and \c GroupAsynchronousDrawFailed
	/// events.
	///
	/// \sa Raise_ItemAsynchronousDrawFailed, Raise_GroupAsynchronousDrawFailed, LVN_ASYNCDRAWN
	LRESULT OnAsyncDrawnNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_BEGINDRAG handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user wants to drag a listview
	/// item using the left mouse button.
	/// We use this handler to raise the \c ItemBeginDrag event.
	///
	/// \sa OnBeginRDragNotification, Raise_ItemBeginDrag,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774796.aspx">LVN_BEGINDRAG</a>
	LRESULT OnBeginDragNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_BEGINLABELEDIT handler</em>
	///
	/// Will be called if the control's parent window is notified, that label-edit mode is about to be
	/// entered.
	/// We use this handler to raise the \c StartingLabelEditing event.
	///
	/// \sa OnEndLabelEditNotification, OnParentNotify, Raise_StartingLabelEditing,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774798.aspx">LVN_BEGINLABELEDIT</a>
	LRESULT OnBeginLabelEditNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c LVN_BEGINRDRAG handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user wants to drag a listview
	/// item using the right mouse button.
	/// We use this handler to raise the \c ItemBeginRDrag event.
	///
	/// \sa OnBeginDragNotification, Raise_ItemBeginRDrag,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774800.aspx">LVN_BEGINRDRAG</a>
	LRESULT OnBeginRDragNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_BEGINSCROLL handler</em>
	///
	/// Will be called if the control's parent window is notified, that the control window has started
	/// being scrolled.
	/// We use this handler to raise the \c BeforeScroll event.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnEndScrollNotification, Raise_BeforeScroll,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774802.aspx">LVN_BEGINSCROLL</a>
	LRESULT OnBeginScrollNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_COLUMNCLICK handler</em>
	///
	/// Will be called if the control's parent window is notified, that a column header was clicked
	/// using the left mouse button.
	/// We use this handler to raise the \c ColumnClick event.
	///
	/// \sa OnHeaderLButtonDown, OnHeaderItemDblClkNotification, OnColumnOverflowClickNotification,
	///     Raise_ColumnClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774804.aspx">LVN_COLUMNCLICK</a>
	LRESULT OnColumnClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_COLUMNDROPDOWN handler</em>
	///
	/// Will be called if the control's parent window is notified, that a column header's drop-down menu
	/// should be displayed.
	/// We use this handler to raise the \c ColumnDropDown event.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa OnColumnClickNotification, Raise_ColumnDropDown,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774806.aspx">LVN_COLUMNDROPDOWN</a>
	LRESULT OnColumnDropDownNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_COLUMNOVERFLOWCLICK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user clicked onto the header
	/// control's chevron button using the left mouse button.
	/// We use this handler to raise the \c HeaderChevronClick event.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa OnColumnClickNotification, Raise_HeaderChevronClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774808.aspx">LVN_COLUMNOVERFLOWCLICK</a>
	LRESULT OnColumnOverflowClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_DELETEALLITEMS handler</em>
	///
	/// Will be called if the control's parent window is notified, that all listview items are being removed.
	/// We use this handler to raise the \c FreeItemData event.
	///
	/// \sa OnDeleteAllItems, Raise_FreeItemData,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774810.aspx">LVN_DELETEALLITEMS</a>
	LRESULT OnDeleteAllItemsNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_DELETEITEM handler</em>
	///
	/// Will be called if the control's parent window is notified, that a listview item is being removed.
	/// We use this handler to raise the \c FreeItemData event.
	///
	/// \sa OnDeleteItem, Raise_FreeItemData,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774812.aspx">LVN_DELETEITEM</a>
	LRESULT OnDeleteItemNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ENDLABELEDIT handler</em>
	///
	/// Will be called if the control's parent window is notified, that label-edit mode was left.
	/// We use this handler to raise the \c RenamingItem event.
	///
	/// \sa OnBeginLabelEditNotification, Raise_RenamingItem,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774814.aspx">LVN_ENDLABELEDIT</a>
	LRESULT OnEndLabelEditNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ENDSCROLL handler</em>
	///
	/// Will be called if the control's parent window is notified, that the control window has stopped
	/// being scrolled.
	/// We use this handler to raise the \c AfterScroll event.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.
	///
	/// \sa OnBeginScrollNotification, Raise_AfterScroll,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774816.aspx">LVN_ENDSCROLL</a>
	LRESULT OnEndScrollNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_GETDISPINFO handler</em>
	///
	/// Will be called if the control requests display information about a listview item from its parent
	/// window.
	/// We use this handler to raise the \c ItemGetDisplayInfo event.
	///
	/// \sa OnSetDispInfoNotification, OnODCacheHintNotification, OnHeaderGetDispInfoNotification,
	///     Raise_ItemGetDisplayInfo,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774818.aspx">LVN_GETDISPINFO</a>
	LRESULT OnGetDispInfoNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_GETEMPTYMARKUP handler</em>
	///
	/// Will be called if the control requests the text, that it shall display if it doesn't contain any
	/// items, from its parent window.
	/// We use this handler for the \c EmptyMarkupText property.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa OnGetEmptyTextNotification, get_EmptyMarkupText, get_EmptyMarkupTextAlignment,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774833.aspx">LVN_GETEMPTYMARKUP</a>
	LRESULT OnGetEmptyMarkupNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_GETEMPTYTEXT handler</em>
	///
	/// Will be called if the control requests the text, that it shall display if it doesn't contain any
	/// items, from its parent window.
	/// We use this handler for the \c EmptyMarkupText property.
	///
	/// \sa OnGetEmptyMarkupNotification, get_EmptyMarkupText, LVN_GETEMPTYTEXTA
	LRESULT OnGetEmptyTextNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_GETINFOTIP handler</em>
	///
	/// Will be called if the control requests a listview item's tooltip text from its parent window.
	/// We use this handler to raise the \c ItemGetInfoTipText event.
	///
	/// \sa Raise_ItemGetInfoTipText,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774835.aspx">LVN_GETINFOTIP</a>
	LRESULT OnGetInfoTipNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_GROUPINFO handler</em>
	///
	/// Will be called if the control's parent window is notified, that a group's state has changed.
	/// We use this handler to raise the \c CollapsedGroup, \c ExpandedGroup \c GroupGotFocus,
	/// \c GroupLostFocus and \c GroupSelectionChanged events.
	///
	/// \sa Raise_CollapsedGroup, Raise_ExpandedGroup, Raise_GroupGotFocus, Raise_GroupLostFocus,
	///     Raise_GroupSelectionChanged,
	///     LVN_GROUPINFO
	LRESULT OnGroupInfoNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_HOTTRACK handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user moved the mouse cursor over
	/// the control's client area.
	/// We use this handler to raise the \c HotItemChanging event.
	///
	/// \remarks This notification is sent only if the control has the \c LVS_EX_TRACKSELECT style being set.
	///
	/// \sa put_HotTracking, Raise_HotItemChanging, OnMouseMove,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774837.aspx">LVN_HOTTRACK</a>
	LRESULT OnHotTrackNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_INCREMENTALSEARCH handler</em>
	///
	/// Will be called if the control's parent window is notified, that the control's incremental item search
	/// is about to start.
	/// We use this handler to raise the \c IncrementalSearching event.
	///
	/// \sa get_IncrementalSearchString, Raise_IncrementalSearching,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774839.aspx">LVN_INCREMENTALSEARCH</a>
	LRESULT OnIncrementalSearchNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ITEMACTIVATE handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user is activating a listview
	/// item.
	/// We use this handler to raise the \c ItemActivate event.
	///
	/// \sa put_ItemActivationMode, Raise_ItemActivate,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774843.aspx">LVN_ITEMACTIVATE</a>
	LRESULT OnItemActivateNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ITEMCHANGED handler</em>
	///
	/// Will be called if the control's parent window is notified, that some of the attributes of the
	/// specified listview item have been changed.
	/// We use this handler to raise the \c CaretChanged and \c ItemSelectionChanged events.
	///
	/// \sa OnODStateChangedNotification, OnHeaderItemChangingNotification, Raise_CaretChanged,
	///     Raise_ItemSelectionChanged,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774845.aspx">LVN_ITEMCHANGED</a>
	LRESULT OnItemChangedNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_KEYDOWN handler</em>
	///
	/// Will be called if the control's parent window is notified, that the user pressed a key while the
	/// control had the keyboard focus.
	/// We use this handler to raise the \c IncrementalSearchStringChanging event.
	///
	/// \sa OnKeyDown, Raise_IncrementalSearchStringChanging,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774849.aspx">LVN_KEYDOWN</a>
	LRESULT OnKeyDownNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_LINKCLICK handler</em>
	///
	/// Will be called if the control's parent window is notified, that a group's task link was clicked
	/// using the left mouse button.
	/// We use this handler to raise the \c EmptyMarkupTextLinkClick and \c GroupTaskLinkClick events.
	///
	/// \sa Raise_EmptyMarkupTextLinkClick, Raise_GroupTaskLinkClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774851.aspx">LVN_LINKCLICK</a>
	LRESULT OnLinkClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_MARQUEEBEGIN handler</em>
	///
	/// Will be called if the control's parent window is notified, that a bounding box (marquee) selection
	/// has begun.
	/// We use this handler to raise the \c BeginMarqueeSelection event.
	///
	/// \sa Raise_BeginMarqueeSelection, get_MultiSelect,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774853.aspx">LVN_MARQUEEBEGIN</a>
	LRESULT OnMarqueeBeginNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ODCACHEHINT handler</em>
	///
	/// Will be called if the (virtual) listview notifies its parent window, that it probably will send
	/// \c LVN_GETDISPINFO notifications for a range of items soon, so the client should cache those items
	/// to increase performance.
	/// We use this handler to raise the \c CacheItemsHint event.
	///
	/// \sa OnGetDispInfoNotification, OnCacheHint, Raise_CacheItemsHint, get_VirtualMode,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774855.aspx">LVN_ODCACHEHINT</a>
	LRESULT OnODCacheHintNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ODFINDITEM handler</em>
	///
	/// Will be called if the (virtual) listview asks its parent window to search for a particular item.
	/// We use this handler to raise the \c FindVirtualItem event.
	///
	/// \sa Raise_FindVirtualItem, get_VirtualMode,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774857.aspx">LVN_ODFINDITEM</a>
	LRESULT OnODFindItemNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_ODSTATECHANGED handler</em>
	///
	/// Will be called if the (virtual) listview notifies its parent window, that a listview item range's
	/// state has changed.
	/// We use this handler to raise the \c SelectedItemRange event.
	///
	/// \sa OnItemChangedNotification, Raise_SelectedItemRange, get_VirtualMode,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774859.aspx">LVN_ODSTATECHANGED</a>
	LRESULT OnODStateChangedNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c LVN_SETDISPINFO handler</em>
	///
	/// Will be called if the control's parent window is notified, that it should update the information it
	/// maintains about the specified listview item.
	/// We use this handler to raise the \c ItemSetText event.
	///
	/// \sa OnGetDispInfoNotification, Raise_ItemSetText,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774861.aspx">LVN_SETDISPINFO</a>
	LRESULT OnSetDispInfoNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDN_BEGINDRAG handler</em>
	///
	/// Will be called if the control is notified, that the user wants to drag a column header using the left
	/// mouse button.
	/// We use this handler to raise the \c ColumnBeginDrag event.
	///
	/// \sa OnHeaderEndDragNotification, OnBeginDragNotification, Raise_ColumnBeginDrag,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775259.aspx">HDN_BEGINDRAG</a>
	LRESULT OnHeaderBeginDragNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDN_BEGINTRACK handler</em>
	///
	/// Will be called if the control is notified, that the user has begun resizing a column.
	/// We use this handler to raise the \c BeginColumnResizing event.
	///
	/// \sa OnHeaderTrackNotification, OnHeaderEndTrackNotification, Raise_BeginColumnResizing,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775263.aspx">HDN_BEGINTRACK</a>
	LRESULT OnHeaderBeginTrackNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_DIVIDERDBLCLICK handler</em>
	///
	/// Will be called if the control is notified, that the user has double-clicked a column divider.
	/// We use this handler to raise the \c HeaderDividerDblClick event.
	///
	/// \sa OnHeaderTrackNotification, Raise_HeaderDividerDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775265.aspx">HDN_DIVIDERDBLCLICK</a>
	LRESULT OnHeaderDividerDblClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_ENDDRAG handler</em>
	///
	/// Will be called if the control is notified, that a drag'n'drop operation has ended.
	/// We use this handler to raise the \c ColumnEndAutoDragDrop event.
	///
	/// \sa OnHeaderBeginDragNotification, Raise_ColumnEndAutoDragDrop,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775269.aspx">HDN_ENDDRAG</a>
	LRESULT OnHeaderEndDragNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_ENDTRACK handler</em>
	///
	/// Will be called if the control is notified, that the user has finished resizing a column.
	/// We use this handler to raise the \c EndColumnResizing event.
	///
	/// \sa OnHeaderBeginTrackNotification, OnHeaderTrackNotification, Raise_EndColumnResizing,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775273.aspx">HDN_ENDTRACK</a>
	LRESULT OnHeaderEndTrackNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_FILTERBTNCLICK handler</em>
	///
	/// Will be called if the control is notified, that the user has clicked an 'Apply Filter' button.
	/// We use this handler to raise the \c FilterButtonClick event.
	///
	/// \sa OnHeaderFilterChangeNotification, Raise_FilterButtonClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775275.aspx">HDN_FILTERBTNCLICK</a>
	LRESULT OnHeaderFilterBtnClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_FILTERCHANGE handler</em>
	///
	/// Will be called if the control is notified, that a column's filter was changed.
	/// We use this handler to raise the \c FilterChanged event.
	///
	/// \sa OnHeaderFilterBtnClickNotification, Raise_FilterChanged,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775277.aspx">HDN_FILTERCHANGE</a>
	LRESULT OnHeaderFilterChangeNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_GETDISPINFO handler</em>
	///
	/// Will be called if the header control requests display information about a column header from its
	/// parent window (the control window itself).
	/// We use this handler to raise the \c HeaderItemGetDisplayInfo event.
	///
	/// \sa OnGetDispInfoNotification, Raise_HeaderItemGetDisplayInfo,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775280.aspx">HDN_GETDISPINFO</a>
	LRESULT OnHeaderGetDispInfoNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDN_ITEMCHANGING handler</em>
	///
	/// Will be called if the control is notified, that some of the attributes of the specified column header
	/// are changing.
	/// We use this handler to raise the \c ResizingColumn event.
	///
	/// \sa OnItemChangedNotification, Raise_ResizingColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775284.aspx">HDN_ITEMCHANGING</a>
	LRESULT OnHeaderItemChangingNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	/// \brief <em>\c HDN_ITEMDBLCLICK handler</em>
	///
	/// Will be called if the control is notified, that the user double-clicked into the header control's
	/// client area using the left mouse button.
	/// We use this handler to raise the \c HeaderDblClick event.
	///
	/// \sa OnHeaderLButtonDblClk, OnHeaderMButtonDblClk, OnHeaderRButtonDblClk, OnHeaderXButtonDblClk,
	///     OnLButtonDblClk, OnEditLButtonDblClk, Raise_HeaderDblClick,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775290.aspx">HDN_ITEMDBLCLICK</a>
	LRESULT OnHeaderItemDblClkNotification(int /*controlID*/, LPNMHDR /*pNotificationDetails*/, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDN_ITEMSTATEICONCLICK handler</em>
	///
	/// Will be called if the control is notified, that the user toggled a column header's state image.
	/// We use this handler to raise the \c ColumnStateImageChanging and \c ColumnStateImageChanged events.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \sa Raise_ColumnStateImageChanging, Raise_ColumnStateImageChanged,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775294.aspx">HDN_ITEMSTATEICONCLICK</a>
	LRESULT OnHeaderStateIconClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	// \brief <em>\c HDN_OVERFLOWCLICK handler</em>
	//
	// Will be called if the control is notified, that the user clicked onto the header control's chevron
	// button using the left mouse button.
	// We use this handler to raise the \c HeaderChevronClick event.
	//
	// \remarks Requires comctl32.dll version 6.10 or higher.
	//
	// \sa OnColumnClickNotification, Raise_HeaderChevronClick,
	//     <a href="https://msdn.microsoft.com/en-us/library/bb775296.aspx">HDN_OVERFLOWCLICK</a>
	//LRESULT OnHeaderOverflowClickNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& /*wasHandled*/);
	/// \brief <em>\c HDN_TRACK handler</em>
	///
	/// Will be called if the control is notified, that the user is resizing a column.
	/// We use this handler to raise the \c ResizingColumn event.
	///
	/// \sa OnHeaderBeginTrackNotification, OnHeaderEndTrackNotification, Raise_ResizingColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775298.aspx">HDN_TRACK</a>
	LRESULT OnHeaderTrackNotification(int /*controlID*/, LPNMHDR pNotificationDetails, BOOL& wasHandled);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Command handlers
	///
	//@{
	/// \brief <em>\c EN_CHANGE handler</em>
	///
	/// Will be called if the control is notified, that the contained edit control's text was changed.
	/// We use this handler to raise the \c EditChange event.
	///
	/// \sa OnEditChar, Raise_ItemSetText,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb761676.aspx">EN_CHANGE</a>
	LRESULT OnEditChange(WORD /*notifyCode*/, WORD /*controlID*/, HWND /*hWnd*/, BOOL& wasHandled);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>\c NM_CUSTOMDRAW handler</em>
	///
	/// Will be called by the \c OnReflectedNotify method if a custom draw notification was received for
	/// the listview.
	/// We use this handler to raise the \c CustomDraw and \c GroupCustomDraw events.
	///
	/// \sa OnReflectedNotify, Raise_CustomDraw, Raise_GroupCustomDraw,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb774865.aspx">NM_CUSTOMDRAW (list view)</a>
	LRESULT OnCustomDrawNotification(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c NM_CUSTOMDRAW handler (header)</em>
	///
	/// Will be called by the \c OnReflectedNotify method if a custom draw notification was received for the
	/// header control.
	/// We use this handler to raise the \c HeaderCustomDraw event.
	///
	/// \sa OnNotify, Raise_HeaderCustomDraw,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb775300.aspx">NM_CUSTOMDRAW (header)</a>
	LRESULT OnHeaderCustomDrawNotification(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c TTN_GETDISPINFOA handler</em>
	///
	/// Will be called by the \c OnNotify method if the \c TTN_GETDISPINFO notification was received.
	/// We use this handler to allow the user to cancel info tip popups.
	///
	/// \sa OnToolTipGetDispInfoNotificationW, OnNotify,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb760269.aspx">TTN_GETDISPINFO</a>
	LRESULT OnToolTipGetDispInfoNotificationA(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);
	/// \brief <em>\c TTN_GETDISPINFOW handler</em>
	///
	/// Will be called by the \c OnNotify method if the \c TTN_GETDISPINFO notification was received.
	/// We use this handler to allow the user to cancel info tip popups.
	///
	/// \sa OnToolTipGetDispInfoNotificationA, OnNotify,
	///     <a href="https://msdn.microsoft.com/en-us/library/bb760269.aspx">TTN_GETDISPINFO</a>
	LRESULT OnToolTipGetDispInfoNotificationW(UINT message, WPARAM wParam, LPARAM lParam, BOOL& /*wasHandled*/);

	//////////////////////////////////////////////////////////////////////
	/// \name Event raisers
	///
	//@{
	/// \brief <em>Raises the \c AbortedDrag event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa EndDrag, Proxy_IExplorerListViewEvents::Fire_AbortedDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::AbortedDrag, Raise_Drop, Raise_HeaderAbortedDrag
	/// \else
	///   \sa EndDrag, Proxy_IExplorerListViewEvents::Fire_AbortedDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::AbortedDrag, Raise_Drop, Raise_HeaderAbortedDrag
	/// \endif
	inline HRESULT Raise_AbortedDrag(void);
	/// \brief <em>Raises the \c AfterScroll event</em>
	///
	/// \param[in] dx The number of steps that the control was scrolled horizontally.
	/// \param[in] dy The number of steps that the control was scrolled vertically.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event is raised only if the scrolling operation is invoked using the mouse.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_AfterScroll,
	///       ExLVwLibU::_IExplorerListViewEvents::AfterScroll, Raise_BeforeScroll, get_ScrollBars, Scroll
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_AfterScroll,
	///       ExLVwLibA::_IExplorerListViewEvents::AfterScroll, Raise_BeforeScroll, get_ScrollBars, Scroll
	/// \endif
	inline HRESULT Raise_AfterScroll(LONG dx, LONG dy);
	/// \brief <em>Raises the \c BeforeScroll event</em>
	///
	/// \param[in] dx The number of steps that the control is about to be scroll horizontally.
	/// \param[in] dy The number of steps that the control is about to be scroll vertically.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event is raised only if the scrolling operation is invoked using the mouse.\n
	///          Requires comctl32.dll version 6.0 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeforeScroll,
	///       ExLVwLibU::_IExplorerListViewEvents::BeforeScroll, Raise_AfterScroll, get_ScrollBars, Scroll
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeforeScroll,
	///       ExLVwLibA::_IExplorerListViewEvents::BeforeScroll, Raise_AfterScroll, get_ScrollBars, Scroll
	/// \endif
	inline HRESULT Raise_BeforeScroll(LONG dx, LONG dy);
	/// \brief <em>Raises the \c BeginColumnResizing event</em>
	///
	/// \param[in] pColumn The column being resized.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort column resizing; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeginColumnResizing,
	///       ExLVwLibU::_IExplorerListViewEvents::BeginColumnResizing, Raise_ResizingColumn,
	///       Raise_EndColumnResizing, get_ResizableColumns, ListViewColumn::get_Resizable,
	///       ListViewColumn::get_Width
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeginColumnResizing,
	///       ExLVwLibA::_IExplorerListViewEvents::BeginColumnResizing, Raise_ResizingColumn,
	///       Raise_EndColumnResizing, get_ResizableColumns, ListViewColumn::get_Resizable,
	///       ListViewColumn::get_Width
	/// \endif
	inline HRESULT Raise_BeginColumnResizing(IListViewColumn* pColumn, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c BeginMarqueeSelection event</em>
	///
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort marquee selection; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeginMarqueeSelection,
	///       ExLVwLibU::_IExplorerListViewEvents::BeginMarqueeSelection, Raise_ItemSelectionChanged,
	///       Raise_SelectedItemRange, get_MultiSelect
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_BeginMarqueeSelection,
	///       ExLVwLibA::_IExplorerListViewEvents::BeginMarqueeSelection, Raise_ItemSelectionChanged,
	///       Raise_SelectedItemRange, get_MultiSelect
	/// \endif
	inline HRESULT Raise_BeginMarqueeSelection(VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c CacheItemsHint event</em>
	///
	/// \param[in] pFirstItem The first item to cache.
	/// \param[in] pLastItem The last item to cache.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CacheItemsHint,
	///       ExLVwLibU::_IExplorerListViewEvents::CacheItemsHint, Raise_ItemGetDisplayInfo, get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CacheItemsHint,
	///       ExLVwLibA::_IExplorerListViewEvents::CacheItemsHint, Raise_ItemGetDisplayInfo, get_VirtualMode
	/// \endif
	inline HRESULT Raise_CacheItemsHint(IListViewItem* pFirstItem, IListViewItem* pLastItem);
	/// \brief <em>Raises the \c CancelSubItemEdit event</em>
	///
	/// \param[in] pListSubItem The sub-item that has been edited.
	/// \param[in] editMode Specifies how the label-edit mode has been entered. Any of the values defined by
	///            the \c SubItemEditModeConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CancelSubItemEdit,
	///       ExLVwLibU::_IExplorerListViewEvents::CancelSubItemEdit, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, Raise_EndSubItemEdit, ExLVwLibU::SubItemEditModeConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CancelSubItemEdit,
	///       ExLVwLibA::_IExplorerListViewEvents::CancelSubItemEdit, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, Raise_EndSubItemEdit, ExLVwLibA::SubItemEditModeConstants
	/// \endif
	inline HRESULT Raise_CancelSubItemEdit(IListViewSubItem* pListSubItem, SubItemEditModeConstants editMode);
	/// \brief <em>Raises the \c CaretChanged event</em>
	///
	/// \param[in] previousCaretItem The previous caret item.
	/// \param[in] newCaretItem The new caret item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CaretChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::CaretChanged, Raise_ItemSelectionChanged, get_CaretItem
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CaretChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::CaretChanged, Raise_ItemSelectionChanged, get_CaretItem
	/// \endif
	inline HRESULT Raise_CaretChanged(LVITEMINDEX previousCaretItem, LVITEMINDEX newCaretItem);
	/// \brief <em>Raises the \c ChangedSortOrder event</em>
	///
	/// \param[in] previousSortOrder The control's old sort order. Any of the values defined by the
	///            \c SortOrderConstants enumeration is valid.
	/// \param[in] newSortOrder The control's new sort order. Any of the values defined by the
	///            \c SortOrderConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangedSortOrder,
	///       ExLVwLibU::_IExplorerListViewEvents::ChangedSortOrder, Raise_ChangingSortOrder,
	///       ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangedSortOrder,
	///       ExLVwLibA::_IExplorerListViewEvents::ChangedSortOrder, Raise_ChangingSortOrder,
	///       ExLVwLibA::SortOrderConstants
	/// \endif
	inline HRESULT Raise_ChangedSortOrder(SortOrderConstants previousSortOrder, SortOrderConstants newSortOrder);
	/// \brief <em>Raises the \c ChangedWorkAreas event</em>
	///
	/// \param[in] pWorkAreas A collection of the new working areas.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangedWorkAreas,
	///       ExLVwLibU::_IExplorerListViewEvents::ChangedWorkAreas, Raise_ChangingWorkAreas
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangedWorkAreas,
	///       ExLVwLibA::_IExplorerListViewEvents::ChangedWorkAreas, Raise_ChangingWorkAreas
	/// \endif
	inline HRESULT Raise_ChangedWorkAreas(IListViewWorkAreas* pWorkAreas);
	/// \brief <em>Raises the \c ChangingSortOrder event</em>
	///
	/// \param[in] previousSortOrder The control's old sort order. Any of the values defined by the
	///            \c SortOrderConstants enumeration is valid.
	/// \param[in] newSortOrder The control's new sort order. Any of the values defined by the
	///            \c SortOrderConstants enumeration is valid.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort redefining; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangingSortOrder,
	///       ExLVwLibU::_IExplorerListViewEvents::ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibU::SortOrderConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangingSortOrder,
	///       ExLVwLibA::_IExplorerListViewEvents::ChangingSortOrder, Raise_ChangedSortOrder,
	///       ExLVwLibA::SortOrderConstants
	/// \endif
	inline HRESULT Raise_ChangingSortOrder(SortOrderConstants previousSortOrder, SortOrderConstants newSortOrder, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c ChangingWorkAreas event</em>
	///
	/// \param[in] pWorkAreas A collection of the new working areas.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort redefining; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangingWorkAreas,
	///       ExLVwLibU::_IExplorerListViewEvents::ChangingWorkAreas, Raise_ChangedWorkAreas
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ChangingWorkAreas,
	///       ExLVwLibA::_IExplorerListViewEvents::ChangingWorkAreas, Raise_ChangedWorkAreas
	/// \endif
	inline HRESULT Raise_ChangingWorkAreas(IVirtualListViewWorkAreas* pWorkAreas, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c Click event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_Click,
	///       ExLVwLibU::_IExplorerListViewEvents::Click, Raise_DblClick, Raise_MClick, Raise_RClick,
	///       Raise_XClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_Click,
	///       ExLVwLibA::_IExplorerListViewEvents::Click, Raise_DblClick, Raise_MClick, Raise_RClick,
	///       Raise_XClick
	/// \endif
	inline HRESULT Raise_Click(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c CollapsedGroup event</em>
	///
	/// \param[in] pGroup The group that was collapsed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CollapsedGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::CollapsedGroup, Raise_ExpandedGroup,
	///       ListViewGroup::get_Collapsible, ListViewGroup::get_Collapsed
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CollapsedGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::CollapsedGroup, Raise_ExpandedGroup,
	///       ListViewGroup::get_Collapsible, ListViewGroup::get_Collapsed
	/// \endif
	inline HRESULT Raise_CollapsedGroup(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c ColumnBeginDrag event</em>
	///
	/// \param[in] pColumn The column header that the user wants to drag.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid, but usually it should be just
	///            \c vbLeftButton.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] hitTestDetails The exact part of the header control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HeaderHitTestConstants enumeration are valid.
	/// \param[in,out] pDoAutomaticDragDrop If set to \c VARIANT_TRUE, the header control should handle
	///                column drag'n'drop itself; otherwise the client is responsible.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnBeginDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnBeginDrag, HeaderBeginDrag, HeaderOLEDrag,
	///       get_AllowHeaderDragDrop, Raise_ColumnEndAutoDragDrop, Raise_ItemBeginDrag,
	///       ExLVwLibU::HeaderHitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnBeginDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnBeginDrag, HeaderBeginDrag, HeaderOLEDrag,
	///       get_AllowHeaderDragDrop, Raise_ColumnEndAutoDragDrop, Raise_ItemBeginDrag,
	///       ExLVwLibA::HeaderHitTestConstants
	/// \endif
	inline HRESULT Raise_ColumnBeginDrag(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants hitTestDetails, VARIANT_BOOL* pDoAutomaticDragDrop);
	/// \brief <em>Raises the \c ColumnClick event</em>
	///
	/// \param[in] pColumn The clicked column header.
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the header control that the mouse cursor's position lies
	///            in. Some of the values defined by the \c HeaderHitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnClick,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnClick, Raise_HeaderClick,
	///       ExLVwLibU::HeaderHitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnClick,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnClick, Raise_HeaderClick,
	///       ExLVwLibA::HeaderHitTestConstants
	/// \endif
	inline HRESULT Raise_ColumnClick(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ColumnDropDown event</em>
	///
	/// \param[in] pColumn The column header whose drop-down menu should be displayed.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the drop-down menu's proposed position relative to the
	///            header control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the drop-down menu's proposed position relative to the
	///            header control's upper-left corner.
	/// \param[in,out] pShowDefaultMenu If \c VARIANT_FALSE, the caller should prevent the \c ShellListView
	///                control from showing the default drop-down menu; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnDropDown,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnDropDown, Raise_ColumnClick,
	///       ListViewColumn::get_ShowDropDownButton
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnDropDown,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnDropDown, Raise_ColumnClick,
	///       ListViewColumn::get_ShowDropDownButton
	/// \endif
	inline HRESULT Raise_ColumnDropDown(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* pShowDefaultMenu);
	/// \brief <em>Raises the \c ColumnEndAutoDragDrop event</em>
	///
	/// \param[in] pColumn The column header that was dragged.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid, but usually it should be just
	///            \c vbLeftButton.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] hitTestDetails The exact part of the header control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HeaderHitTestConstants enumeration are valid.
	/// \param[in,out] pDoAutomaticDrop If set to \c VARIANT_TRUE, the header control should handle the
	///                column header drop itself; otherwise the client is responsible.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnEndAutoDragDrop,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnEndAutoDragDrop, get_AllowHeaderDragDrop,
	///       Raise_ColumnBeginDrag, ExLVwLibU::HeaderHitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnEndAutoDragDrop,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnEndAutoDragDrop, get_AllowHeaderDragDrop,
	///       Raise_ColumnBeginDrag, ExLVwLibA::HeaderHitTestConstants
	/// \endif
	inline HRESULT Raise_ColumnEndAutoDragDrop(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants hitTestDetails, VARIANT_BOOL* pDoAutomaticDrop);
	/// \brief <em>Raises the \c ColumnMouseEnter event</em>
	///
	/// \param[in] pColumn The column header that was entered.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] hitTestDetails The exact part of the header control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HeaderHitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnMouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnMouseEnter, Raise_ColumnMouseLeave,
	///       Raise_HeaderMouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HeaderHitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnMouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnMouseEnter, Raise_ColumnMouseLeave,
	///       Raise_HeaderMouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HeaderHitTestConstants
	/// \endif
	inline HRESULT Raise_ColumnMouseEnter(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ColumnMouseLeave event</em>
	///
	/// \param[in] pColumn The column header that was left.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] hitTestDetails The exact part of the header control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HeaderHitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnMouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnMouseLeave, Raise_ColumnMouseEnter,
	///       Raise_HeaderMouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HeaderHitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnMouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnMouseLeave, Raise_ColumnMouseEnter,
	///       Raise_HeaderMouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HeaderHitTestConstants
	/// \endif
	inline HRESULT Raise_ColumnMouseLeave(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HeaderHitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ColumnStateImageChanged event</em>
	///
	/// \param[in] pColumn The column whose state image was changed.
	/// \param[in] previousStateImageIndex The one-based index of the column's previous state image.
	/// \param[in] newStateImageIndex The one-based index of the column's new state image.
	/// \param[in] causedBy The reason for the state image change. Any of the values defined by the
	///            \c StateImageChangeCausedByConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnStateImageChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnStateImageChanged, Raise_ColumnStateImageChanging,
	///       Raise_ItemStateImageChanged, ListViewColumn::get_StateImageIndex,
	///       ExLVwLibU::StateImageChangeCausedByConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnStateImageChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnStateImageChanged, Raise_ColumnStateImageChanging,
	///       Raise_ItemStateImageChanged, ListViewColumn::get_StateImageIndex,
	///       ExLVwLibA::StateImageChangeCausedByConstants
	/// \endif
	inline HRESULT Raise_ColumnStateImageChanged(IListViewColumn* pColumn, LONG previousStateImageIndex, LONG newStateImageIndex, StateImageChangeCausedByConstants causedBy);
	/// \brief <em>Raises the \c ColumnStateImageChanging event</em>
	///
	/// \param[in] pColumn The column whose state image shall be changed.
	/// \param[in] previousStateImageIndex The one-based index of the column's previous state image.
	/// \param[in,out] pNewStateImageIndex The one-based index of the column's new state image. The client
	///                may change this value.
	/// \param[in] causedBy The reason for the state image change. Any of the values defined by the
	///            \c StateImageChangeCausedByConstants enumeration is valid.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should prevent the state image from changing;
	///                otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnStateImageChanging,
	///       ExLVwLibU::_IExplorerListViewEvents::ColumnStateImageChanging, Raise_ColumnStateImageChanged,
	///       Raise_ItemStateImageChanging, ListViewColumn::get_StateImageIndex,
	///       ExLVwLibU::StateImageChangeCausedByConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ColumnStateImageChanging,
	///       ExLVwLibA::_IExplorerListViewEvents::ColumnStateImageChanging, Raise_ColumnStateImageChanged,
	///       Raise_ItemStateImageChanging, ListViewColumn::get_StateImageIndex,
	///       ExLVwLibA::StateImageChangeCausedByConstants
	/// \endif
	inline HRESULT Raise_ColumnStateImageChanging(IListViewColumn* pColumn, LONG previousStateImageIndex, LONG* pNewStateImageIndex, StateImageChangeCausedByConstants causedBy, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c CompareGroups event</em>
	///
	/// \param[in] pFirstGroup The first group to compare.
	/// \param[in] pSecondGroup The second group to compare.
	/// \param[out] pResult Receives one of the values defined by the \c CompareResultConstants enumeration.
	///             If \c GroupSortOrder is set to \c soDescending, the caller should invert this value.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_GroupSortOrder, SortGroups, Proxy_IExplorerListViewEvents::Fire_CompareGroups,
	///       ExLVwLibU::_IExplorerListViewEvents::CompareGroups, ExLVwLibU::CompareResultConstants
	/// \else
	///   \sa get_GroupSortOrder, SortGroups, Proxy_IExplorerListViewEvents::Fire_CompareGroups,
	///       ExLVwLibA::_IExplorerListViewEvents::CompareGroups, ExLVwLibA::CompareResultConstants
	/// \endif
	inline HRESULT Raise_CompareGroups(IListViewGroup* pFirstGroup, IListViewGroup* pSecondGroup, CompareResultConstants* pResult);
	/// \brief <em>Raises the \c CompareItems event</em>
	///
	/// \param[in] pFirstItem The first item to compare.
	/// \param[in] pSecondItem The second item to compare.
	/// \param[out] pResult Receives one of the values defined by the \c CompareResultConstants enumeration.
	///             If \c SortOrder is set to \c soDescending, the caller should invert this value.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa get_SortOrder, SortItems, Proxy_IExplorerListViewEvents::Fire_CompareItems,
	///       ExLVwLibU::_IExplorerListViewEvents::CompareItems, ExLVwLibU::CompareResultConstants
	/// \else
	///   \sa get_SortOrder, SortItems, Proxy_IExplorerListViewEvents::Fire_CompareItems,
	///       ExLVwLibA::_IExplorerListViewEvents::CompareItems, ExLVwLibA::CompareResultConstants
	/// \endif
	inline HRESULT Raise_CompareItems(IListViewItem* pFirstItem, IListViewItem* pSecondItem, CompareResultConstants* pResult);
	/// \brief <em>Raises the \c ConfigureSubItemControl event</em>
	///
	/// \param[in] pListSubItem The sub-item that the representation control needs to be configured for.
	/// \param[in] controlKind The kind of representation control being configured. Any of the values
	///            defined by the \c SubItemControlKindConstants enumeration are valid.
	/// \param[in] editMode Specifies how the label-edit mode is being entered. Any of the values defined by
	///            the \c SubItemEditModeConstants enumeration is valid.
	/// \param[in] subItemControl The representation control that needs to be configured. Any of the
	///            values defined by the \c SubItemControlConstants enumeration are valid.
	/// \param[in,out] pThemeAppName Specifies the application name of the theme to apply when drawing
	///                the sub-item control. For instance this value can be set to "explorer" to make
	///                the sub-item control be drawn like in Windows Explorer.
	/// \param[in,out] pThemeIDList Specifies a semicolon-separated list of CLSID names to use in place
	///                of the names specified by the window's class. This value is used to refine the
	///                search for a visual style to apply. For instance there might be different visual
	///                styles available for different usages of the same window class.
	/// \param[in,out] phFont Specifies the font to apply to the sub-item control.
	/// \param[in,out] pTextColor Specifies the text color to apply to the sub-item control.
	/// \param[in,out] ppPropertyDescription An object that implements the \c IPropertyDescription interface.
	///                This object is used for a more detailed configuration of the sub-item control.
	///                Some built-in sub-item controls like the \c sicDropList control won't work without
	///                specifying an \c IPropertyDescription implementation.
	/// \param[in,out] pPropertyValue Specifies the address of a \c PROPVARIANT structure that holds the
	///                sub-item's current value. Sub-items can be thought of as representing various
	///                properties of the item that they belong to. These properties can be of any type,
	///                not only strings. The \c PROPVARIANT type is similar to Visual Basic's \c Variant
	///                type and can hold any other type, for instance integer numbers, floating-point
	///                numbers and objects.\n
	///                Use the <a href="https://msdn.microsoft.com/en-us/library/bb762286.aspx">PROPVARIANT
	///                and VARIANT API functions</a> to work with the \c PROPVARIANT data.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With current versions of comctl32.dll, providing a sub-item control is the only way to
	///          custom-draw sub-items in Tiles view mode.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ConfigureSubItemControl,
	///       ExLVwLibU::_IExplorerListViewEvents::ConfigureSubItemControl, Raise_GetSubItemControl,
	///       Raise_EndSubItemEdit, Raise_CancelSubItemEdit, Raise_CustomDraw,
	///       ExLVwLibU::SubItemControlKindConstants, ExLVwLibU::SubItemEditModeConstants,
	///       ExLVwLibU::SubItemControlConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ConfigureSubItemControl,
	///       ExLVwLibA::_IExplorerListViewEvents::ConfigureSubItemControl, Raise_GetSubItemControl,
	///       Raise_EndSubItemEdit, Raise_CancelSubItemEdit, Raise_CustomDraw,
	///       ExLVwLibA::SubItemControlKindConstants, ExLVwLibA::SubItemEditModeConstants,
	///       ExLVwLibA::SubItemControlConstants
	/// \endif
	inline HRESULT Raise_ConfigureSubItemControl(IListViewSubItem* pListSubItem, SubItemControlKindConstants controlKind, SubItemEditModeConstants editMode, SubItemControlConstants subItemControl, BSTR* pThemeAppName, BSTR* pThemeIDList, HFONT* phFont, COLORREF* pTextColor, IUnknown** ppPropertyDescription, PROPVARIANT* pPropertyValue);
	/// \brief <em>Raises the \c ContextMenu event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the menu's proposed position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the menu's proposed position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ContextMenu,
	///       ExLVwLibU::_IExplorerListViewEvents::ContextMenu, Raise_RClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ContextMenu,
	///       ExLVwLibA::_IExplorerListViewEvents::ContextMenu, Raise_RClick
	/// \endif
	inline HRESULT Raise_ContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c CreatedEditControlWindow event</em>
	///
	/// \param[in] hWndEdit The edit control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CreatedEditControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::CreatedEditControlWindow,
	///       Raise_DestroyedEditControlWindow, Raise_StartingLabelEditing, get_hWndEdit
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CreatedEditControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::CreatedEditControlWindow,
	///       Raise_DestroyedEditControlWindow, Raise_StartingLabelEditing, get_hWndEdit
	/// \endif
	inline HRESULT Raise_CreatedEditControlWindow(HWND hWndEdit);
	/// \brief <em>Raises the \c CreatedHeaderControlWindow event</em>
	///
	/// \param[in] hWndHeader The header control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CreatedHeaderControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::CreatedHeaderControlWindow,
	///       Raise_DestroyedHeaderControlWindow, get_hWndHeader
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CreatedHeaderControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::CreatedHeaderControlWindow,
	///       Raise_DestroyedHeaderControlWindow, get_hWndHeader
	/// \endif
	inline HRESULT Raise_CreatedHeaderControlWindow(HWND hWndHeader);
	/// \brief <em>Raises the \c CustomDraw event</em>
	///
	/// \param[in] pListItem The item that the notification refers to. May be \c NULL.
	/// \param[in] pListSubItem The sub-item that the notification refers to. May be \c NULL.
	/// \param[in] drawAllItems If \c VARIANT_TRUE, all items are to be drawn.
	/// \param[in,out] pTextColor An \c OLE_COLOR value specifying the color to draw the item's text in.
	///                The client may change this value.
	/// \param[in,out] pTextBackColor An \c OLE_COLOR value specifying the color to fill the item's
	///                text background with. The client may change this value.
	/// \param[in] drawStage The stage of custom drawing this event is raised for. Any of the values
	///            defined by the \c CustomDrawStageConstants enumeration is valid.
	/// \param[in] itemState The item's current state (focused, selected etc.). Most of the values
	///            defined by the \c CustomDrawItemStateConstants enumeration are valid.
	/// \param[in] hDC The handle of the device context in which all drawing shall take place.
	/// \param[in] pDrawingRectangle A \c RECTANGLE structure specifying the bounding rectangle of the
	///            area that needs to be drawn.
	/// \param[in,out] pFurtherProcessing A value controlling further drawing. Most of the values defined
	///                by the \c CustomDrawReturnValuesConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks The \c drawAllItems parameter is meaningful on Windows 7 and newer only.\n
	///          The text's background color can't be customized if a background bitmap is used.\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_CustomDraw,
	///       ExLVwLibU::_IExplorerListViewEvents::CustomDraw, Raise_GroupCustomDraw, Raise_HeaderCustomDraw,
	///       get_ForeColor, get_TextBackColor, get_BkImage, ExLVwLibU::RECTANGLE,
	///       ExLVwLibU::CustomDrawStageConstants, ExLVwLibU::CustomDrawItemStateConstants,
	///       ExLVwLibU::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb774865.aspx">NM_CUSTOMDRAW (list view)</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_CustomDraw,
	///       ExLVwLibA::_IExplorerListViewEvents::CustomDraw, Raise_GroupCustomDraw, Raise_HeaderCustomDraw,
	///       get_ForeColor, get_TextBackColor, get_BkImage, ExLVwLibA::RECTANGLE,
	///       ExLVwLibA::CustomDrawStageConstants, ExLVwLibA::CustomDrawItemStateConstants,
	///       ExLVwLibA::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb774865.aspx">NM_CUSTOMDRAW (list view)</a>
	/// \endif
	inline HRESULT Raise_CustomDraw(IListViewItem* pListItem, IListViewSubItem* pListSubItem, VARIANT_BOOL drawAllItems, OLE_COLOR* pTextColor, OLE_COLOR* pTextBackColor, CustomDrawStageConstants drawStage, CustomDrawItemStateConstants itemState, LONG hDC, RECTANGLE* pDrawingRectangle, CustomDrawReturnValuesConstants* pFurtherProcessing);
	/// \brief <em>Raises the \c DblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_DblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::DblClick, Raise_Click, Raise_MDblClick,
	///       Raise_RDblClick, Raise_XDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_DblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::DblClick, Raise_Click, Raise_MDblClick,
	///       Raise_RDblClick, Raise_XDblClick
	/// \endif
	inline HRESULT Raise_DblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c DestroyedControlWindow event</em>
	///
	/// \param[in] hWnd The control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::DestroyedControlWindow,
	///       Raise_RecreatedControlWindow, get_hWnd
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::DestroyedControlWindow,
	///       Raise_RecreatedControlWindow, get_hWnd
	/// \endif
	inline HRESULT Raise_DestroyedControlWindow(HWND hWnd);
	/// \brief <em>Raises the \c DestroyedEditControlWindow event</em>
	///
	/// \param[in] hWndEdit The edit control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedEditControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::DestroyedEditControlWindow,
	///       Raise_CreatedEditControlWindow, Raise_StartingLabelEditing, get_hWndEdit, EndLabelEdit
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedEditControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::DestroyedEditControlWindow,
	///       Raise_CreatedEditControlWindow, Raise_StartingLabelEditing, get_hWndEdit, EndLabelEdit
	/// \endif
	inline HRESULT Raise_DestroyedEditControlWindow(HWND hWndEdit);
	/// \brief <em>Raises the \c DestroyedHeaderControlWindow event</em>
	///
	/// \param[in] hWndHeader The header control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedHeaderControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::DestroyedHeaderControlWindow,
	///       Raise_CreatedHeaderControlWindow, get_hWndHeader
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_DestroyedHeaderControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::DestroyedHeaderControlWindow,
	///       Raise_CreatedHeaderControlWindow, get_hWndHeader
	/// \endif
	inline HRESULT Raise_DestroyedHeaderControlWindow(HWND hWndHeader);
	/// \brief <em>Raises the \c DragMouseMove event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_DragMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::DragMouseMove, Raise_MouseMove,
	///       Raise_OLEDragMouseMove, Raise_HeaderDragMouseMove, BeginDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_DragMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::DragMouseMove, Raise_MouseMove,
	///       Raise_OLEDragMouseMove, Raise_HeaderDragMouseMove, BeginDrag
	/// \endif
	inline HRESULT Raise_DragMouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c Drop event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa EndDrag, Proxy_IExplorerListViewEvents::Fire_Drop,
	///       ExLVwLibU::_IExplorerListViewEvents::Drop, Raise_AbortedDrag, Raise_HeaderDrop
	/// \else
	///   \sa EndDrag, Proxy_IExplorerListViewEvents::Fire_Drop,
	///       ExLVwLibA::_IExplorerListViewEvents::Drop, Raise_AbortedDrag, Raise_HeaderDrop
	/// \endif
	inline HRESULT Raise_Drop(void);
	/// \brief <em>Raises the \c EditChange event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditChange,
	///       ExLVwLibU::_IExplorerListViewEvents::EditChange, Raise_EditKeyPress, get_EditText
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditChange,
	///       ExLVwLibA::_IExplorerListViewEvents::EditChange, Raise_EditKeyPress, get_EditText
	/// \endif
	inline HRESULT Raise_EditChange(void);
	/// \brief <em>Raises the \c EditClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditClick, Raise_EditDblClick, Raise_EditMClick,
	///       Raise_EditRClick, Raise_EditXClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditClick, Raise_EditDblClick, Raise_EditMClick,
	///       Raise_EditRClick, Raise_EditXClick
	/// \endif
	inline HRESULT Raise_EditClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditContextMenu event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the menu's proposed position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the menu's proposed position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in,out] pShowDefaultMenu If \c VARIANT_FALSE, the caller should prevent the contained edit
	///                control from showing the default context menu; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditContextMenu,
	///       ExLVwLibU::_IExplorerListViewEvents::EditContextMenu, Raise_EditRClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditContextMenu,
	///       ExLVwLibA::_IExplorerListViewEvents::EditContextMenu, Raise_EditRClick
	/// \endif
	inline HRESULT Raise_EditContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* pShowDefaultMenu);
	/// \brief <em>Raises the \c EditDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditDblClick, Raise_EditClick, Raise_EditMDblClick,
	///       Raise_EditRDblClick, Raise_EditXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditDblClick, Raise_EditClick, Raise_EditMDblClick,
	///       Raise_EditRDblClick, Raise_EditXDblClick
	/// \endif
	inline HRESULT Raise_EditDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditGotFocus event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditGotFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::EditGotFocus, Raise_EditLostFocus
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditGotFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::EditGotFocus, Raise_EditLostFocus
	/// \endif
	inline HRESULT Raise_EditGotFocus(void);
	/// \brief <em>Raises the \c EditKeyDown event</em>
	///
	/// \param[in,out] pKeyCode The pressed key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYDOWN
	///                message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyDown,
	///       ExLVwLibU::_IExplorerListViewEvents::EditKeyDown, Raise_EditKeyUp, Raise_EditKeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyDown,
	///       ExLVwLibA::_IExplorerListViewEvents::EditKeyDown, Raise_EditKeyUp, Raise_EditKeyPress
	/// \endif
	inline HRESULT Raise_EditKeyDown(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c EditKeyPress event</em>
	///
	/// \param[in,out] pKeyAscii The pressed key's ASCII code. If set to 0, the caller should eat the
	///                \c WM_CHAR message.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyPress,
	///       ExLVwLibU::_IExplorerListViewEvents::EditKeyPress, Raise_EditKeyDown, Raise_EditKeyUp
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyPress,
	///       ExLVwLibA::_IExplorerListViewEvents::EditKeyPress, Raise_EditKeyDown, Raise_EditKeyUp
	/// \endif
	inline HRESULT Raise_EditKeyPress(SHORT* pKeyAscii);
	/// \brief <em>Raises the \c EditKeyUp event</em>
	///
	/// \param[in,out] pKeyCode The released key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYUP message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyUp,
	///       ExLVwLibU::_IExplorerListViewEvents::EditKeyUp, Raise_EditKeyDown, Raise_EditKeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditKeyUp,
	///       ExLVwLibA::_IExplorerListViewEvents::EditKeyUp, Raise_EditKeyDown, Raise_EditKeyPress
	/// \endif
	inline HRESULT Raise_EditKeyUp(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c EditLostFocus event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditLostFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::EditLostFocus, Raise_EditGotFocus
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditLostFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::EditLostFocus, Raise_EditGotFocus
	/// \endif
	inline HRESULT Raise_EditLostFocus(void);
	/// \brief <em>Raises the \c EditMClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMClick, Raise_EditMDblClick, Raise_EditClick,
	///       Raise_EditRClick, Raise_EditXClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMClick, Raise_EditMDblClick, Raise_EditClick,
	///       Raise_EditRClick, Raise_EditXClick
	/// \endif
	inline HRESULT Raise_EditMClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMDblClick, Raise_EditMClick, Raise_EditDblClick,
	///       Raise_EditRDblClick, Raise_EditXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMDblClick, Raise_EditMClick, Raise_EditDblClick,
	///       Raise_EditRDblClick, Raise_EditXDblClick
	/// \endif
	inline HRESULT Raise_EditMDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseDown event</em>
	///
	/// \param[in] button The pressed mouse button. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseDown,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseDown, Raise_EditMouseUp, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, Raise_EditXClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseDown,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseDown, Raise_EditMouseUp, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, Raise_EditXClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseEnter event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseEnter, Raise_EditMouseLeave,
	///       Raise_EditMouseHover, Raise_EditMouseMove, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseEnter, Raise_EditMouseLeave,
	///       Raise_EditMouseHover, Raise_EditMouseMove, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseHover event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseHover,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseHover, Raise_EditMouseEnter,
	///       Raise_EditMouseLeave, Raise_EditMouseMove, put_EditHoverTime,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseHover,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseHover, Raise_EditMouseEnter,
	///       Raise_EditMouseLeave, Raise_EditMouseMove, put_EditHoverTime,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseLeave event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseLeave, Raise_EditMouseEnter,
	///       Raise_EditMouseHover, Raise_EditMouseMove, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseLeave, Raise_EditMouseEnter,
	///       Raise_EditMouseHover, Raise_EditMouseMove, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseMove event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseMove, Raise_EditMouseEnter,
	///       Raise_EditMouseLeave, Raise_EditMouseDown, Raise_EditMouseUp, Raise_EditMouseWheel,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseMove, Raise_EditMouseEnter,
	///       Raise_EditMouseLeave, Raise_EditMouseDown, Raise_EditMouseUp, Raise_EditMouseWheel,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseUp event</em>
	///
	/// \param[in] button The released mouse button. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseUp,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseUp, Raise_EditMouseDown, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, Raise_EditXClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseUp,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseUp, Raise_EditMouseDown, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, Raise_EditXClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditMouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditMouseWheel event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
	///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
	/// \param[in] wheelDelta The distance the wheel has been rotated.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseWheel,
	///       ExLVwLibU::_IExplorerListViewEvents::EditMouseWheel, Raise_EditMouseMove, Raise_MouseWheel,
	///       Raise_HeaderMouseWheel, ExLVwLibU::ExtendedMouseButtonConstants, ExLVwLibU::ScrollAxisConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditMouseWheel,
	///       ExLVwLibA::_IExplorerListViewEvents::EditMouseWheel, Raise_EditMouseMove, Raise_MouseWheel,
	///       Raise_HeaderMouseWheel, ExLVwLibA::ExtendedMouseButtonConstants, ExLVwLibA::ScrollAxisConstants
	/// \endif
	inline HRESULT Raise_EditMouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
	/// \brief <em>Raises the \c EditRClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditRClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditRClick, Raise_EditContextMenu,
	///       Raise_EditRDblClick, Raise_EditClick, Raise_EditMClick, Raise_EditXClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RClick,
	///       ExLVwLibA::_IExplorerListViewEvents::Fire_RClick, Raise_EditContextMenu,
	///       Raise_EditRDblClick, Raise_EditClick, Raise_EditMClick, Raise_EditXClick
	/// \endif
	inline HRESULT Raise_EditRClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditRDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditRDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditRDblClick, Raise_EditRClick, Raise_EditDblClick,
	///       Raise_EditMDblClick, Raise_EditXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditRDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditRDblClick, Raise_EditRClick, Raise_EditDblClick,
	///       Raise_EditMDblClick, Raise_EditXDblClick
	/// \endif
	inline HRESULT Raise_EditRDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditXClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the contained edit
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditXClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditXClick, Raise_EditXDblClick, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditXClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditXClick, Raise_EditXDblClick, Raise_EditClick,
	///       Raise_EditMClick, Raise_EditRClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditXClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EditXDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the contained
	///            edit control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditXDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EditXDblClick, Raise_EditXClick, Raise_EditDblClick,
	///       Raise_EditMDblClick, Raise_EditRDblClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EditXDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EditXDblClick, Raise_EditXClick, Raise_EditDblClick,
	///       Raise_EditMDblClick, Raise_EditRDblClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_EditXDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c EmptyMarkupTextLinkClick event</em>
	///
	/// \param[in] linkIndex The zero-based index of the link that was clicked.
	/// \param[in] button The mouse button that was pressed during the click. Any of the values defined
	///            by VB's \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The part of the control that was clicked. Any of the values defined by the
	///            \c HitTestConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EmptyMarkupTextLinkClick,
	///       ExLVwLibU::_IExplorerListViewEvents::EmptyMarkupTextLinkClick, get_EmptyMarkupText,
	///       Raise_Click, ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EmptyMarkupTextLinkClick,
	///       ExLVwLibA::_IExplorerListViewEvents::EmptyMarkupTextLinkClick, get_EmptyMarkupText,
	///       Raise_Click, ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_EmptyMarkupTextLinkClick(LONG linkIndex, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c EndColumnResizing event</em>
	///
	/// \param[in] pColumn The column that was resized.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EndColumnResizing,
	///       ExLVwLibU::_IExplorerListViewEvents::EndColumnResizing, Raise_BeginColumnResizing,
	///       Raise_ResizingColumn, ListViewColumn::get_Width
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EndColumnResizing,
	///       ExLVwLibA::_IExplorerListViewEvents::EndColumnResizing, Raise_BeginColumnResizing,
	///       Raise_ResizingColumn, ListViewColumn::get_Width
	/// \endif
	inline HRESULT Raise_EndColumnResizing(IListViewColumn* pColumn);
	/// \brief <em>Raises the \c EndSubItemEdit event</em>
	///
	/// \param[in] pListSubItem The sub-item that has been edited.
	/// \param[in] editMode Specifies how the label-edit mode has been entered. Any of the values defined by
	///            the \c SubItemEditModeConstants enumeration is valid.
	/// \param[in] pPropertyKey Specifies the address of a \c PROPERTYKEY structure that identifies the
	///            property that the secified sub-item is representing. This is the \c PROPERTYKEY
	///            structure that has been retrieved by the \c GetPropertyKey method of the
	///            \c IPropertyDescription object that previously has been provided by the
	///            \c ConfigureSubItemControl event handler.
	/// \param[in] pPropertyValue Specifies the address of a \c PROPVARIANT structure that holds the
	///            sub-item's new value. Sub-items can be thought of as representing various properties
	///            of the item that they belong to. These properties can be of any type, not only
	///            strings. The \c PROPVARIANT type is similar to Visual Basic's \c Variant type and can
	///            hold any other type, for instance integer numbers, floating-point numbers and
	///            objects.\n
	///            Use the <a href="https://msdn.microsoft.com/en-us/library/bb762286.aspx">PROPVARIANT
	///            and VARIANT API functions</a> to work with the \c PROPVARIANT data.
	/// \param[in,out] pCancel If set to \c VARIANT_TRUE, the editing of the sub-item should not be processed
	///                any further.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_EndSubItemEdit,
	///       ExLVwLibU::_IExplorerListViewEvents::EndSubItemEdit, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, Raise_CancelSubItemEdit, ExLVwLibU::SubItemEditModeConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_EndSubItemEdit,
	///       ExLVwLibA::_IExplorerListViewEvents::EndSubItemEdit, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, Raise_CancelSubItemEdit, ExLVwLibA::SubItemEditModeConstants
	/// \endif
	inline HRESULT Raise_EndSubItemEdit(IListViewSubItem* pListSubItem, SubItemEditModeConstants editMode, PROPERTYKEY* pPropertyKey, PROPVARIANT* pPropertyValue, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c ExpandedGroup event</em>
	///
	/// \param[in] pGroup The group that was expanded.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ExpandedGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::ExpandedGroup, Raise_CollapsedGroup,
	///       ListViewGroup::get_Collapsible, ListViewGroup::get_Collapsed
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ExpandedGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::ExpandedGroup, Raise_CollapsedGroup,
	///       ListViewGroup::get_Collapsible, ListViewGroup::get_Collapsed
	/// \endif
	inline HRESULT Raise_ExpandedGroup(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c FilterButtonClick event</em>
	///
	/// \param[in] pColumn The column header whose 'Apply Filter' button was clicked.
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] pFilterButtonRectangle The bounding rectangle of the clicked button's client area
	///            (in pixels).
	/// \param[in,out] pRaiseFilterChanged If \c VARIANT_TRUE, the caller should raise the \c FilterChanged
	///                event; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          Requires comctl32.dll version 5.80 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FilterButtonClick,
	///       ExLVwLibU::_IExplorerListViewEvents::FilterButtonClick, Raise_FilterChanged, Raise_HeaderClick,
	///       ExLVwLibU::RECTANGLE, get_ShowFilterBar
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FilterButtonClick,
	///       ExLVwLibA::_IExplorerListViewEvents::FilterButtonClick, Raise_FilterChanged, Raise_HeaderClick,
	///       ExLVwLibA::RECTANGLE, get_ShowFilterBar
	/// \endif
	inline HRESULT Raise_FilterButtonClick(IListViewColumn* pColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, RECTANGLE* pFilterButtonRectangle, VARIANT_BOOL* pRaiseFilterChanged);
	/// \brief <em>Raises the \c FilterChanged event</em>
	///
	/// \param[in] pColumn The column header whose filter was changed. If \c NULL, all columns' filters
	///            were changed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 5.80 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FilterChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::FilterChanged, Raise_FilterButtonClick, Raise_EditChange,
	///       get_ShowFilterBar, get_FilterChangedTimeout
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FilterChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::FilterChanged, Raise_FilterButtonClick, Raise_EditChange,
	///       get_ShowFilterBar, get_FilterChangedTimeout
	/// \endif
	inline HRESULT Raise_FilterChanged(IListViewColumn* pColumn);
	/// \brief <em>Raises the \c FindVirtualItem event</em>
	///
	/// \param[in] pItemToStartWith The item at which the search should start.
	/// \param[in] searchMode A value specifying the meaning of the \c pSearchFor parameter. Any of the
	///            values defined by the \c SearchModeConstants enumeration is valid.
	/// \param[in] pSearchFor The criterion that the returned item should fulfill. This parameter's
	///            format depends on the \c searchMode parameter:
	///            - \c smItemData An integer value.
	///            - \c smText A string value.
	///            - \c smPartialText A string value.
	///            - \c smNearestPosition An array containing two integer values. The first one specifies the
	///              x-coordinate, the second one the y-coordinate (both in pixels and relative to the
	///              control's upper-left corner).
	/// \param[in] searchDirection A value specifying the direction to search. Any of the values
	///            defined by the \c SearchDirectionConstants enumeration is valid. The client should ignore
	///            this parameter if the \c searchMode parameter is not set to \c smNearestPosition.
	/// \param[in] wrapAtLastItem If set to \c VARIANT_TRUE, the search should be continued with the first
	///            item if the last item is reached. The client should ignore this parameter if \c searchMode
	///            is set to \c smNearestPosition.
	/// \param[out] ppFoundItem Receives an item matching the specified characteristics. May receive \c NULL.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FindVirtualItem,
	///       ExLVwLibU::_IExplorerListViewEvents::FindVirtualItem, FindItem, ListViewItem::FindNextItem,
	///       ExLVwLibU::SearchModeConstants, ExLVwLibU::SearchDirectionConstants, get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FindVirtualItem,
	///       ExLVwLibA::_IExplorerListViewEvents::FindVirtualItem, FindItem, ListViewItem::FindNextItem,
	///       ExLVwLibA::SearchModeConstants, ExLVwLibA::SearchDirectionConstants, get_VirtualMode
	/// \endif
	inline HRESULT Raise_FindVirtualItem(IListViewItem* pItemToStartWith, SearchModeConstants searchMode, VARIANT* pSearchFor, SearchDirectionConstants searchDirection, VARIANT_BOOL wrapAtLastItem, IListViewItem** ppFoundItem);
	/// \brief <em>Raises the \c FooterItemClick event</em>
	///
	/// \param[in] pFooterItem The clicked footer item.
	/// \param[in] button The mouse buttons that were pressed during the click. Any of the values defined by
	///            VB's \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in twips) of the click's position relative to the control's upper-left
	///            corner.
	/// \param[in] y The y-coordinate (in twips) of the click's position relative to the control'supper-left
	///             corner.
	/// \param[in] hitTestDetails Specifies the part of the control that was clicked. Any of the
	///            values defined by the \c HitTestConstants enumeration is valid.
	/// \param[in,out] pRemoveFooterArea If \c VARIANT_FALSE, the caller should remove the footer area;
	///                otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With current versions of comctl32.dll this event won't be raised if the footer item's
	///          \c ItemData property is set to 0.\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FooterItemClick,
	///       ExLVwLibU::_IExplorerListViewEvents::FooterItemClick, ListViewFooterItem::get_ItemData,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FooterItemClick,
	///       ExLVwLibA::_IExplorerListViewEvents::FooterItemClick, ListViewFooterItem::get_ItemData,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_FooterItemClick(IListViewFooterItem* pFooterItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails, VARIANT_BOOL* pRemoveFooterArea);
	/// \brief <em>Raises the \c FreeColumnData event</em>
	///
	/// \param[in] pColumn The column whose associated data shall be freed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeColumnData,
	///       ExLVwLibU::_IExplorerListViewEvents::FreeColumnData, Raise_RemovingColumn, Raise_RemovedColumn,
	///       ListViewColumn::put_ColumnData
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeColumnData,
	///       ExLVwLibA::_IExplorerListViewEvents::FreeColumnData, Raise_RemovingColumn, Raise_RemovedColumn,
	///       ListViewColumn::put_ColumnData
	/// \endif
	inline HRESULT Raise_FreeColumnData(IListViewColumn* pColumn);
	/// \brief <em>Raises the \c FreeFooterItemData event</em>
	///
	/// \param[in] pFooterItem The item whose associated data shall be freed.
	/// \param[in] itemData The data associated with the footer item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With current versions of comctl32.dll this event won't be raised if the footer item's
	///          \c ItemData property is set to 0.\n
	///          Requires comctl32.dll version 6.10 or higher.\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeFooterItemData,
	///       ExLVwLibU::_IExplorerListViewEvents::FreeFooterItemData, ListViewFooterItem::get_ItemData
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeFooterItemData,
	///       ExLVwLibA::_IExplorerListViewEvents::FreeFooterItemData, ListViewFooterItem::get_ItemData
	/// \endif
	inline HRESULT Raise_FreeFooterItemData(IListViewFooterItem* pFooterItem, LONG itemData);
	/// \brief <em>Raises the \c FreeItemData event</em>
	///
	/// \param[in] pListItem The item whose associated data shall be freed.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeItemData,
	///       ExLVwLibU::_IExplorerListViewEvents::FreeItemData, Raise_RemovingItem, Raise_RemovedItem,
	///       ListViewItem::put_ItemData
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_FreeItemData,
	///       ExLVwLibA::_IExplorerListViewEvents::FreeItemData, Raise_RemovingItem, Raise_RemovedItem,
	///       ListViewItem::put_ItemData
	/// \endif
	inline HRESULT Raise_FreeItemData(IListViewItem* pListItem);
	/// \brief <em>Raises the \c GetSubItemControl event</em>
	///
	/// \param[in] pListSubItem The sub-item that the representation control is requested for.
	/// \param[in] controlKind The kind of representation control being requested. Any of the values defined
	///            by the \c SubItemControlKindConstants enumeration are valid.
	/// \param[in] editMode Specifies how the label-edit mode is being entered. Any of the values defined by
	///            the \c SubItemEditModeConstants enumeration is valid.
	/// \param[in,out] pSubItemControl The representation control to use for the specified sub-item. Any of
	///                the values defined by the \c SubItemControlConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks With current versions of comctl32.dll, providing a sub-item control is the only way to
	///          custom-draw sub-items in Tiles view mode.\n
	///          Requires comctl32.dll version 6.10 or higher.\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GetSubItemControl,
	///       ExLVwLibU::_IExplorerListViewEvents::GetSubItemControl, Raise_ConfigureSubItemControl,
	///       Raise_CustomDraw, ExLVwLibU::SubItemControlKindConstants, ExLVwLibU::SubItemEditModeConstants,
	///       ExLVwLibU::SubItemControlConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GetSubItemControl,
	///       ExLVwLibA::_IExplorerListViewEvents::GetSubItemControl, Raise_ConfigureSubItemControl,
	///       Raise_CustomDraw, ExLVwLibA::SubItemControlKindConstants, ExLVwLibA::SubItemEditModeConstants,
	///       ExLVwLibA::SubItemControlConstants
	/// \endif
	inline HRESULT Raise_GetSubItemControl(IListViewSubItem* pListSubItem, SubItemControlKindConstants controlKind, SubItemEditModeConstants editMode, SubItemControlConstants* pSubItemControl);
	/// \brief <em>Raises the \c GroupAsynchronousDrawFailed event</em>
	///
	/// \param[in] pGroup The group whose image failed to be drawn.
	/// \param[in,out] pNotificationDetails A \c NMLVASYNCDRAWN struct holding the notification details.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupAsynchronousDrawFailed,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupAsynchronousDrawFailed, get_DrawImagesAsynchronously,
	///       ExLVwLibU::FAILEDIMAGEDETAILS, Raise_ItemAsynchronousDrawFailed,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms670576.aspx">NMLVASYNCDRAWN</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupAsynchronousDrawFailed,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupAsynchronousDrawFailed, get_DrawImagesAsynchronously,
	///       ExLVwLibA::FAILEDIMAGEDETAILS, Raise_ItemAsynchronousDrawFailed,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms670576.aspx">NMLVASYNCDRAWN</a>
	/// \endif
	inline HRESULT Raise_GroupAsynchronousDrawFailed(IListViewGroup* pGroup, NMLVASYNCDRAWN* pNotificationDetails);
	/// \brief <em>Raises the \c GroupCustomDraw event</em>
	///
	/// \param[in] pGroup The group that the notification refers to.
	/// \param[in,out] pTextColor An \c OLE_COLOR value specifying the color to draw the group's text in.
	///                The client may change this value.
	/// \param[in,out] pHeaderAlignment The alignment to draw the group's header text with. Any of the values
	///                defined by the \c AlignmentConstants enumeration is valid. The client may change this
	///                value.
	/// \param[in,out] pFooterAlignment The alignment to draw the group's footer text with. Any of the values
	///                defined by the \c AlignmentConstants enumeration is valid. The client may change this
	///                value.
	/// \param[in] drawStage The stage of custom drawing this event is raised for. Any of the values
	///            defined by the \c CustomDrawStageConstants enumeration is valid.
	/// \param[in] groupState The group's current state (focused, selected etc.). Most of the values
	///            defined by the \c CustomDrawItemStateConstants enumeration are valid.
	/// \param[in] hDC The handle of the device context in which all drawing shall take place.
	/// \param[in] pDrawingRectangle A \c RECTANGLE structure specifying the bounding rectangle of the
	///            area that needs to be drawn.
	/// \param[in] pTextRectangle A \c RECTANGLE structure specifying the bounding rectangle of the area,
	///            in which the group's text is to be drawn.
	/// \param[in,out] pFurtherProcessing A value controlling further drawing. Most of the values defined
	///                by the \c CustomDrawReturnValuesConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.0 or higher.\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupCustomDraw,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupCustomDraw, Raise_CustomDraw, Raise_HeaderCustomDraw,
	///       get_GroupFooterForeColor, get_GroupHeaderForeColor, ExLVwLibU::RECTANGLE,
	///       ExLVwLibU::AlignmentConstants, ExLVwLibU::CustomDrawStageConstants,
	///       ExLVwLibU::CustomDrawItemStateConstants, ExLVwLibU::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb774865.aspx">NM_CUSTOMDRAW (list view)</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupCustomDraw,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupCustomDraw, Raise_CustomDraw, Raise_HeaderCustomDraw,
	///       get_GroupFooterForeColor, get_GroupHeaderForeColor, ExLVwLibA::RECTANGLE,
	///       ExLVwLibA::AlignmentConstants, ExLVwLibA::CustomDrawStageConstants,
	///       ExLVwLibA::CustomDrawItemStateConstants, ExLVwLibA::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb774865.aspx">NM_CUSTOMDRAW (list view)</a>
	/// \endif
	inline HRESULT Raise_GroupCustomDraw(IListViewGroup* pGroup, OLE_COLOR* pTextColor, AlignmentConstants* pHeaderAlignment, AlignmentConstants* pFooterAlignment, CustomDrawStageConstants drawStage, CustomDrawItemStateConstants groupState, LONG hDC, RECTANGLE* pDrawingRectangle, RECTANGLE* pTextRectangle, CustomDrawReturnValuesConstants* pFurtherProcessing);
	/// \brief <em>Raises the \c GroupGotFocus event</em>
	///
	/// \param[in] pGroup The group that has received the keyboard focus.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupGotFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupGotFocus, Raise_GroupLostFocus,
	///       Raise_GroupSelectionChanged, get_CaretGroup, ListViewGroup::get_Caret
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupGotFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupGotFocus, Raise_GroupLostFocus,
	///       Raise_GroupSelectionChanged, get_CaretGroup, ListViewGroup::get_Caret
	/// \endif
	inline HRESULT Raise_GroupGotFocus(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c GroupLostFocus event</em>
	///
	/// \param[in] pGroup The group that has lost the keyboard focus.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupLostFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupLostFocus, Raise_GroupGotFocus,
	///       get_CaretGroup, ListViewGroup::get_Caret
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupLostFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupLostFocus, Raise_GroupGotFocus,
	///       get_CaretGroup, ListViewGroup::get_Caret
	/// \endif
	inline HRESULT Raise_GroupLostFocus(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c GroupSelectionChanged event</em>
	///
	/// \param[in] pGroup The group that has been selected/unselected.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupSelectionChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupSelectionChanged, Raise_GroupGotFocus,
	///       Raise_ItemSelectionChanged, ListViewGroup::get_Selected
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupSelectionChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupSelectionChanged, Raise_GroupGotFocus,
	///       Raise_ItemSelectionChanged, ListViewGroup::get_Selected
	/// \endif
	inline HRESULT Raise_GroupSelectionChanged(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c GroupTaskLinkClick event</em>
	///
	/// \param[in] pGroup The group whose task link was clicked.
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The part of the control that was clicked. Any of the values defined by the
	///            \c HitTestConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupTaskLinkClick,
	///       ExLVwLibU::_IExplorerListViewEvents::GroupTaskLinkClick, ListViewGroup::get_TaskText,
	///       Raise_Click, ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_GroupTaskLinkClick,
	///       ExLVwLibA::_IExplorerListViewEvents::GroupTaskLinkClick, ListViewGroup::get_TaskText,
	///       Raise_Click, ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_GroupTaskLinkClick(IListViewGroup* pGroup, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c HeaderAbortedDrag event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa HeaderEndDrag, Proxy_IExplorerListViewEvents::Fire_HeaderAbortedDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderAbortedDrag, Raise_HeaderDrop, Raise_AbortedDrag
	/// \else
	///   \sa HeaderEndDrag, Proxy_IExplorerListViewEvents::Fire_HeaderAbortedDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderAbortedDrag, Raise_HeaderDrop, Raise_AbortedDrag
	/// \endif
	inline HRESULT Raise_HeaderAbortedDrag(void);
	/// \brief <em>Raises the \c HeaderChevronClick event</em>
	///
	/// \param[in] pFirstOverflownColumn The first overflown column.
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in,out] pShowDefaultMenu If \c VARIANT_FALSE, the caller should not show the default overflow
	///                menu; otherwise it should.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderChevronClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderChevronClick, Raise_HeaderClick,
	///       get_ShowHeaderChevron
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderChevronClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderChevronClick, Raise_HeaderClick,
	///       get_ShowHeaderChevron
	/// \endif
	inline HRESULT Raise_HeaderChevronClick(IListViewColumn* pFirstOverflownColumn, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, VARIANT_BOOL* pShowDefaultMenu);
	/// \brief <em>Raises the \c HeaderClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderClick, Raise_HeaderDblClick, Raise_HeaderMClick,
	///       Raise_HeaderRClick, Raise_HeaderXClick, Raise_ColumnClick, Raise_HeaderChevronClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderClick, Raise_HeaderDblClick, Raise_HeaderMClick,
	///       Raise_HeaderRClick, Raise_HeaderXClick, Raise_ColumnClick, Raise_HeaderChevronClick
	/// \endif
	inline HRESULT Raise_HeaderClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderContextMenu event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the menu's proposed position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the menu's proposed position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderContextMenu,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderContextMenu, Raise_HeaderRClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderContextMenu,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderContextMenu, Raise_HeaderRClick
	/// \endif
	inline HRESULT Raise_HeaderContextMenu(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderCustomDraw event</em>
	///
	/// \param[in] pColumn The column header that the notification refers to. May be \c NULL.
	/// \param[in] drawStage The stage of custom drawing this event is raised for. Most of the values
	///            defined by the \c CustomDrawStageConstants enumeration is valid.
	/// \param[in] columnState The column header's current state (focused, selected etc.). Some of the
	///            values defined by the \c CustomDrawItemStateConstants enumeration are valid.
	/// \param[in] hDC The handle of the device context in which all drawing shall take place.
	/// \param[in] pDrawingRectangle A \c RECTANGLE structure specifying the bounding rectangle of the
	///            area that needs to be drawn.
	/// \param[in,out] pFurtherProcessing A value controlling further drawing. Most of the values defined
	///                by the \c CustomDrawReturnValuesConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderCustomDraw,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderCustomDraw, Raise_CustomDraw, Raise_GroupCustomDraw,
	///       Raise_HeaderOwnerDrawItem, ExLVwLibU::RECTANGLE, ExLVwLibU::CustomDrawStageConstants,
	///       ExLVwLibU::CustomDrawItemStateConstants, ExLVwLibU::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms671991.aspx">NM_CUSTOMDRAW (header)</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderCustomDraw,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderCustomDraw, Raise_CustomDraw, Raise_GroupCustomDraw,
	///       Raise_HeaderOwnerDrawItem, ExLVwLibA::RECTANGLE, ExLVwLibA::CustomDrawStageConstants,
	///       ExLVwLibA::CustomDrawItemStateConstants, ExLVwLibA::CustomDrawReturnValuesConstants,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms671991.aspx">NM_CUSTOMDRAW (header)</a>
	/// \endif
	inline HRESULT Raise_HeaderCustomDraw(IListViewColumn* pColumn, CustomDrawStageConstants drawStage, CustomDrawItemStateConstants columnState, LONG hDC, RECTANGLE* pDrawingRectangle, CustomDrawReturnValuesConstants* pFurtherProcessing);
	/// \brief <em>Raises the \c HeaderDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbLeftButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderDblClick, Raise_HeaderClick, Raise_HeaderMDblClick,
	///       Raise_HeaderRDblClick, Raise_HeaderXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderDblClick, Raise_HeaderClick, Raise_HeaderMDblClick,
	///       Raise_HeaderRDblClick, Raise_HeaderXDblClick
	/// \endif
	inline HRESULT Raise_HeaderDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderDividerDblClick event</em>
	///
	/// \param[in] pColumn The column header that the double-clicked column divider belongs to.
	/// \param[in,out] pAutoSizeColumn If \c VARIANT_TRUE, the caller should auto-size the specified column;
	///                otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDividerDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderDividerDblClick, Raise_HeaderDblClick,
	///       Raise_ResizingColumn, ListViewColumn::get_Width
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDividerDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderDividerDblClick, Raise_HeaderDblClick,
	///       Raise_ResizingColumn, ListViewColumn::get_Width
	/// \endif
	inline HRESULT Raise_HeaderDividerDblClick(IListViewColumn* pColumn, VARIANT_BOOL* pAutoSizeColumn);
	/// \brief <em>Raises the \c HeaderDragMouseMove event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] xListView The x-coordinate (in pixels) of the mouse cursor's position relative to the
	///            control's upper-left corner.
	/// \param[in] yListView The y-coordinate (in pixels) of the mouse cursor's position relative to the
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDragMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderDragMouseMove, Raise_HeaderMouseMove,
	///       Raise_HeaderOLEDragMouseMove, Raise_DragMouseMove, HeaderBeginDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderDragMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderDragMouseMove, Raise_HeaderMouseMove,
	///       Raise_HeaderOLEDragMouseMove, Raise_DragMouseMove, HeaderBeginDrag
	/// \endif
	inline HRESULT Raise_HeaderDragMouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, OLE_XPOS_PIXELS xListView, OLE_YPOS_PIXELS yListView);
	/// \brief <em>Raises the \c HeaderDrop event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa HeaderEndDrag, Proxy_IExplorerListViewEvents::Fire_HeaderDrop,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderDrop, Raise_HeaderAbortedDrag, Raise_Drop
	/// \else
	///   \sa HeaderEndDrag, Proxy_IExplorerListViewEvents::Fire_HeaderDrop,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderDrop, Raise_HeaderAbortedDrag, Raise_Drop
	/// \endif
	inline HRESULT Raise_HeaderDrop(void);
	/// \brief <em>Raises the \c HeaderGotFocus event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderGotFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderGotFocus, Raise_HeaderLostFocus,
	///       get_IncludeHeaderInTabOrder
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderGotFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderGotFocus, Raise_HeaderLostFocus,
	///       get_IncludeHeaderInTabOrder
	/// \endif
	inline HRESULT Raise_HeaderGotFocus(void);
	/// \brief <em>Raises the \c HeaderItemGetDisplayInfo event</em>
	///
	/// \param[in] pColumn The column header that the value is required for.
	/// \param[in] requestedInfo Specifies which properties' values are required. Some combinations of
	///            the values defined by the \c RequestedInfoConstants enumeration are valid.
	/// \param[out] pIconIndex The zero-based index of the requested icon. If the \c requestedInfo
	///             parameter doesn't include \c riIconIndex, the caller should ignore this value.
	/// \param[in] maxColumnCaptionLength The maximum number of characters the column header's text may
	///            consist of. If the \c requestedInfo parameter doesn't include \c riItemText, the client
	///            should ignore this value.
	/// \param[out] pColumnCaption The column header's caption. If the \c requestedInfo parameter doesn't
	///             include \c riItemText, the caller should ignore this value.
	/// \param[in,out] pDontAskAgain If \c VARIANT_TRUE, the caller should always use the same settings
	///                and never fire this event again for these properties of this column header;
	///                otherwise it shouldn't make the values persistent.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderItemGetDisplayInfo,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderItemGetDisplayInfo, ListViewColumn::put_IconIndex,
	///       put_hImageList, ListViewColumn::put_Caption, ExLVwLibU::RequestedInfoConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderItemGetDisplayInfo,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderItemGetDisplayInfo, ListViewColumn::put_IconIndex,
	///       put_hImageList, ListViewColumn::put_Caption, ExLVwLibA::RequestedInfoConstants
	/// \endif
	inline HRESULT Raise_HeaderItemGetDisplayInfo(IListViewColumn* pColumn, RequestedInfoConstants requestedInfo, LONG* pIconIndex, LONG maxColumnCaptionLength, BSTR* pColumnCaption, VARIANT_BOOL* pDontAskAgain);
	/// \brief <em>Raises the \c HeaderKeyDown event</em>
	///
	/// \param[in,out] pKeyCode The pressed key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYDOWN
	///                message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyDown,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderKeyDown, Raise_HeaderKeyUp, Raise_HeaderKeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyDown,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderKeyDown, Raise_HeaderKeyUp, Raise_HeaderKeyPress
	/// \endif
	inline HRESULT Raise_HeaderKeyDown(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c HeaderKeyPress event</em>
	///
	/// \param[in,out] pKeyAscii The pressed key's ASCII code. If set to 0, the caller should eat the
	///                \c WM_CHAR message.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyPress,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderKeyPress, Raise_HeaderKeyDown, Raise_HeaderKeyUp
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyPress,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderKeyPress, Raise_HeaderKeyDown, Raise_HeaderKeyUp
	/// \endif
	inline HRESULT Raise_HeaderKeyPress(SHORT* pKeyAscii);
	/// \brief <em>Raises the \c HeaderKeyUp event</em>
	///
	/// \param[in,out] pKeyCode The released key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYUP message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyUp,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderKeyUp, Raise_HeaderKeyDown, Raise_HeaderKeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderKeyUp,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderKeyUp, Raise_HeaderKeyDown, Raise_HeaderKeyPress
	/// \endif
	inline HRESULT Raise_HeaderKeyUp(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c HeaderLostFocus event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderLostFocus,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderLostFocus, Raise_HeaderGotFocus,
	///       get_IncludeHeaderInTabOrder
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderLostFocus,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderLostFocus, Raise_HeaderGotFocus,
	///       get_IncludeHeaderInTabOrder
	/// \endif
	inline HRESULT Raise_HeaderLostFocus(void);
	/// \brief <em>Raises the \c HeaderMClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMClick, Raise_HeaderMDblClick, Raise_HeaderClick,
	///       Raise_HeaderRClick, Raise_HeaderXClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMClick, Raise_HeaderMDblClick, Raise_HeaderClick,
	///       Raise_HeaderRClick, Raise_HeaderXClick
	/// \endif
	inline HRESULT Raise_HeaderMClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMDblClick, Raise_HeaderMClick, Raise_HeaderDblClick,
	///       Raise_HeaderRDblClick, Raise_HeaderXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMDblClick, Raise_HeaderMClick, Raise_HeaderDblClick,
	///       Raise_HeaderRDblClick, Raise_HeaderXDblClick
	/// \endif
	inline HRESULT Raise_HeaderMDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseDown event</em>
	///
	/// \param[in] button The pressed mouse button. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseDown,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseDown, Raise_HeaderMouseUp, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseDown,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseDown, Raise_HeaderMouseUp, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseEnter event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseEnter, Raise_HeaderMouseLeave,
	///       Raise_ColumnMouseEnter, Raise_HeaderMouseHover, Raise_HeaderMouseMove,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseEnter, Raise_HeaderMouseLeave,
	///       Raise_ColumnMouseEnter, Raise_HeaderMouseHover, Raise_HeaderMouseMove,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseHover event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseHover,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseHover, Raise_HeaderMouseEnter,
	///       Raise_HeaderMouseLeave, Raise_HeaderMouseMove, put_HeaderHoverTime,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseHover,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseHover, Raise_HeaderMouseEnter,
	///       Raise_HeaderMouseLeave, Raise_HeaderMouseMove, put_HeaderHoverTime,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseLeave event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseLeave, Raise_HeaderMouseEnter,
	///       Raise_ColumnMouseLeave, Raise_HeaderMouseHover, Raise_HeaderMouseMove,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseLeave, Raise_HeaderMouseEnter,
	///       Raise_ColumnMouseLeave, Raise_HeaderMouseHover, Raise_HeaderMouseMove,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseMove event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseMove, Raise_HeaderMouseEnter,
	///       Raise_HeaderMouseLeave, Raise_HeaderMouseDown, Raise_HeaderMouseUp, Raise_HeaderMouseWheel,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseMove, Raise_HeaderMouseEnter,
	///       Raise_HeaderMouseLeave, Raise_HeaderMouseDown, Raise_HeaderMouseUp, Raise_HeaderMouseWheel,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseUp event</em>
	///
	/// \param[in] button The released mouse buttons. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseUp,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseUp, Raise_HeaderMouseDown, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick,
	///       ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseUp,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseUp, Raise_HeaderMouseDown, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick,
	///       ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderMouseWheel event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the header
	///            control's upper-left corner.
	/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
	///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
	/// \param[in] wheelDelta The distance the wheel has been rotated.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseWheel,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderMouseWheel, Raise_HeaderMouseMove, Raise_MouseWheel,
	///       Raise_EditMouseWheel, ExLVwLibU::ExtendedMouseButtonConstants, ExLVwLibU::ScrollAxisConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderMouseWheel,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderMouseWheel, Raise_HeaderMouseMove, Raise_MouseWheel,
	///       Raise_EditMouseWheel, ExLVwLibA::ExtendedMouseButtonConstants, ExLVwLibA::ScrollAxisConstants
	/// \endif
	inline HRESULT Raise_HeaderMouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
	/// \brief <em>Raises the \c HeaderOLECompleteDrag event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
	///            defined by the \c OLEDropEffectConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLECompleteDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLECompleteDrag, Raise_HeaderOLEStartDrag,
	///       Raise_OLECompleteDrag, ExLVwLibU::IOLEDataObject::GetData, HeaderOLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLECompleteDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLECompleteDrag, Raise_HeaderOLEStartDrag,
	///       Raise_OLECompleteDrag, ExLVwLibA::IOLEDataObject::GetData, HeaderOLEDrag
	/// \endif
	inline HRESULT Raise_HeaderOLECompleteDrag(IOLEDataObject* pData, OLEDropEffectConstants performedEffect);
	/// \brief <em>Raises the \c HeaderOLEDragDrop event</em>
	///
	/// \param[in] pData The dropped data.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the client
	///                finally executed.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragDrop,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragDrop, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragMouseMove, Raise_HeaderOLEDragLeave, Raise_HeaderMouseUp, Raise_OLEDragDrop,
	///       get_RegisterForOLEDragDrop, FinishOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragDrop,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragDrop, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragMouseMove, Raise_HeaderOLEDragLeave, Raise_HeaderMouseUp, Raise_OLEDragDrop,
	///       get_RegisterForOLEDragDrop, FinishOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_HeaderOLEDragDrop(IDataObject* pData, LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c HeaderOLEDragEnter event</em>
	///
	/// \param[in] fakedEnter If \c FALSE, the method replaces the cached data object; otherwise not.
	/// \param[in] pData The dragged data. If \c NULL, the cached data object is used. We use this when
	///            we call this method from other places than \c DragEnter.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the client
	///                wants to be used on drop.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragEnter, Raise_HeaderOLEDragMouseMove,
	///       Raise_HeaderOLEDragLeave, Raise_HeaderOLEDragDrop, Raise_HeaderMouseEnter, Raise_OLEDragEnter,
	///       get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragEnter, Raise_HeaderOLEDragMouseMove,
	///       Raise_HeaderOLEDragLeave, Raise_HeaderOLEDragDrop, Raise_HeaderMouseEnter, Raise_OLEDragEnter,
	///       get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_HeaderOLEDragEnter(BOOL fakedEnter, IDataObject* pData, LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c HeaderOLEDragEnterPotentialTarget event</em>
	///
	/// \param[in] hWndPotentialTarget The potential drop target window's handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragEnterPotentialTarget,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragEnterPotentialTarget,
	///       Raise_HeaderOLEDragLeavePotentialTarget, Raise_OLEDragEnterPotentialTarget, HeaderOLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragEnterPotentialTarget,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragEnterPotentialTarget,
	///       Raise_HeaderOLEDragLeavePotentialTarget, Raise_OLEDragEnterPotentialTarget, HeaderOLEDrag
	/// \endif
	inline HRESULT Raise_HeaderOLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
	/// \brief <em>Raises the \c HeaderOLEDragLeave event</em>
	///
	/// \param[in] fakedLeave If \c FALSE, the method kills the \c ID_DRAGSCROLL timer and releases the
	///            cached data object; otherwise not.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragLeave, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragMouseMove, Raise_HeaderOLEDragDrop, Raise_HeaderMouseLeave,
	///       Raise_OLEDragLeave, get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragLeave, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragMouseMove, Raise_HeaderOLEDragDrop, Raise_HeaderMouseLeave,
	///       Raise_OLEDragLeave, get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition
	/// \endif
	inline HRESULT Raise_HeaderOLEDragLeave(BOOL fakedLeave, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c HeaderOLEDragLeavePotentialTarget event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragLeavePotentialTarget,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragLeavePotentialTarget,
	///       Raise_HeaderOLEDragEnterPotentialTarget, Raise_OLEDragLeavePotentialTarget, HeaderOLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragLeavePotentialTarget,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragLeavePotentialTarget,
	///       Raise_HeaderOLEDragEnterPotentialTarget, Raise_OLEDragLeavePotentialTarget, HeaderOLEDrag
	/// \endif
	inline HRESULT Raise_HeaderOLEDragLeavePotentialTarget(void);
	/// \brief <em>Raises the \c HeaderOLEDragMouseMove event</em>
	///
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the client
	///                wants to be used on drop.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEDragMouseMove, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragLeave, Raise_HeaderOLEDragDrop, Raise_HeaderMouseMove,
	///       Raise_OLEDragMouseMove, get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEDragMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEDragMouseMove, Raise_HeaderOLEDragEnter,
	///       Raise_HeaderOLEDragLeave, Raise_HeaderOLEDragDrop, Raise_HeaderMouseMove,
	///       Raise_OLEDragMouseMove, get_RegisterForOLEDragDrop, SetHeaderInsertMarkPosition,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_HeaderOLEDragMouseMove(LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c HeaderOLEGiveFeedback event</em>
	///
	/// \param[in] effect The current drop effect. It is chosen by the potential drop target. Any of
	///            the values defined by the \c DROPEFFECT enumeration is valid.
	/// \param[in,out] pUseDefaultCursors If set to \c VARIANT_TRUE, the system's default mouse cursors
	///                shall be used to visualize the various drop effects. If set to \c VARIANT_FALSE,
	///                the client has set a custom mouse cursor.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEGiveFeedback,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEGiveFeedback, Raise_HeaderOLEQueryContinueDrag,
	///       Raise_OLEGiveFeedback,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEGiveFeedback,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEGiveFeedback, Raise_HeaderOLEQueryContinueDrag,
	///       Raise_OLEGiveFeedback,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_HeaderOLEGiveFeedback(DWORD effect, VARIANT_BOOL* pUseDefaultCursors);
	/// \brief <em>Raises the \c HeaderOLEQueryContinueDrag event</em>
	///
	/// \param[in] pressedEscape If \c TRUE, the user has pressed the \c ESC key since the last time
	///            this event was raised; otherwise not.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in,out] pActionToContinueWith Indicates whether to continue (\c S_OK), cancel
	///                (\c DRAGDROP_S_CANCEL) or complete (\c DRAGDROP_S_DROP) the drag'n'drop operation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEQueryContinueDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEQueryContinueDrag, Raise_HeaderOLEGiveFeedback,
	///       Raise_OLEQueryContinueDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEQueryContinueDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEQueryContinueDrag, Raise_HeaderOLEGiveFeedback,
	///       Raise_OLEQueryContinueDrag
	/// \endif
	inline HRESULT Raise_HeaderOLEQueryContinueDrag(BOOL pressedEscape, DWORD keyState, HRESULT* pActionToContinueWith);
	/// \brief <em>Raises the \c HeaderOLEReceivedNewData event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] formatID An integer value specifying the format the data object has received data for.
	///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
	///            other format that has been registered using the \c RegisterClipboardFormat API function.
	/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
	///            member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS require multiple
	///            \c FORMATETC structs for the same format. In such cases each struct of this format will
	///            have a separate index.
	/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
	///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
	///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEReceivedNewData,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEReceivedNewData, Raise_OLEReceivedNewData,
	///       Raise_HeaderOLESetData, SourceOLEDataObject::GetData, HeaderOLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEReceivedNewData,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEReceivedNewData, Raise_OLEReceivedNewData,
	///       Raise_HeaderOLESetData, SourceOLEDataObject::GetData, HeaderOLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \endif
	HRESULT Raise_HeaderOLEReceivedNewData(IOLEDataObject* pData, LONG formatID, LONG index, LONG dataOrViewAspect);
	/// \brief <em>Raises the \c HeaderOLESetData event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] formatID An integer value specifying the format the drop target is requesting data for.
	///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
	///            other format that has been registered using the \c RegisterClipboardFormat API function.
	/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
	///            member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS require multiple
	///            \c FORMATETC structs for the same format. In such cases each struct of this format will
	///            have a separate index.
	/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
	///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
	///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLESetData,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLESetData, Raise_HeaderOLEStartDrag,
	///       Raise_OLESetData, SourceOLEDataObject::SetData, HeaderOLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLESetData,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLESetData, Raise_HeaderOLEStartDrag,
	///       Raise_OLESetData, SourceOLEDataObject::SetData, HeaderOLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \endif
	HRESULT Raise_HeaderOLESetData(IOLEDataObject* pData, LONG formatID, LONG index, LONG dataOrViewAspect);
	/// \brief <em>Raises the \c HeaderOLEStartDrag event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEStartDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOLEStartDrag, Raise_HeaderOLESetData,
	///       Raise_HeaderOLECompleteDrag, Raise_OLEStartDrag, SourceOLEDataObject::SetData, HeaderOLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOLEStartDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOLEStartDrag, Raise_HeaderOLESetData,
	///       Raise_HeaderOLECompleteDrag, Raise_OLEStartDrag, SourceOLEDataObject::SetData, HeaderOLEDrag
	/// \endif
	inline HRESULT Raise_HeaderOLEStartDrag(IOLEDataObject* pData);
	/// \brief <em>Raises the \c HeaderOwnerDrawItem event</em>
	///
	/// \param[in] pColumn The column header to draw.
	/// \param[in] columnState The column header's current state (focused, selected etc.). Some of the values
	///            defined by the \c OwnerDrawItemStateConstants enumeration are valid.
	/// \param[in] hDC The handle of the device context in which all drawing shall take place.
	/// \param[in] pDrawingRectangle A \c RECTANGLE structure specifying the bounding rectangle of the
	///            area that needs to be drawn.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOwnerDrawItem,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderOwnerDrawItem, Raise_HeaderCustomDraw,
	///       Raise_OwnerDrawItem, ListViewColumn::get_OwnerDrawn, ExLVwLibU::RECTANGLE,
	///       ExLVwLibU::OwnerDrawItemStateConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderOwnerDrawItem,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderOwnerDrawItem, Raise_HeaderCustomDraw,
	///       Raise_OwnerDrawItem, ListViewColumn::get_OwnerDrawn, ExLVwLibU::RECTANGLE,
	///       ExLVwLibA::OwnerDrawItemStateConstants
	/// \endif
	inline HRESULT Raise_HeaderOwnerDrawItem(IListViewColumn* pColumn, OwnerDrawItemStateConstants columnState, LONG hDC, RECTANGLE* pDrawingRectangle);
	/// \brief <em>Raises the \c HeaderRClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderRClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderRClick, Raise_HeaderContextMenu,
	///       Raise_HeaderRDblClick, Raise_HeaderClick, Raise_HeaderMClick, Raise_HeaderXClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderRClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderRClick, Raise_HeaderContextMenu,
	///       Raise_HeaderRDblClick, Raise_HeaderClick, Raise_HeaderMClick, Raise_HeaderXClick
	/// \endif
	inline HRESULT Raise_HeaderRClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderRDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderRDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderRDblClick, Raise_HeaderRClick, Raise_HeaderDblClick,
	///       Raise_HeaderMDblClick, Raise_HeaderXDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderRDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderRDblClick, Raise_HeaderRClick, Raise_HeaderDblClick,
	///       Raise_HeaderMDblClick, Raise_HeaderXDblClick
	/// \endif
	inline HRESULT Raise_HeaderRDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderXClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the header control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderXClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderXClick, Raise_HeaderXDblClick, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderXClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderXClick, Raise_HeaderXDblClick, Raise_HeaderClick,
	///       Raise_HeaderMClick, Raise_HeaderRClick
	/// \endif
	inline HRESULT Raise_HeaderXClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HeaderXDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the header
	///            control's upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).\n
	///          This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderXDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::HeaderXDblClick, Raise_HeaderXClick, Raise_HeaderDblClick,
	///       Raise_HeaderMDblClick, Raise_HeaderRDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HeaderXDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::HeaderXDblClick, Raise_HeaderXClick, Raise_HeaderDblClick,
	///       Raise_HeaderMDblClick, Raise_HeaderRDblClick
	/// \endif
	inline HRESULT Raise_HeaderXDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c HotItemChanged event</em>
	///
	/// \param[in] pPreviousHotItem The previous hot item. May be \ NULL.
	/// \param[in] pNewHotItem The new hot item. May be \ NULL.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HotItemChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::HotItemChanged, get_HotItem, get_HotTracking,
	///       Raise_HotItemChanging
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HotItemChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::HotItemChanged, get_HotItem, get_HotTracking,
	///       Raise_HotItemChanging
	/// \endif
	inline HRESULT Raise_HotItemChanged(IListViewItem* pPreviousHotItem, IListViewItem* pNewHotItem);
	/// \brief <em>Raises the \c HotItemChanging event</em>
	///
	/// \param[in] pPreviousHotItem The previous hot item. May be \ NULL.
	/// \param[in] pNewHotItem The new hot item. May be \ NULL.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort the hot item change; otherwise
	///                not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_HotItemChanging,
	///       ExLVwLibU::_IExplorerListViewEvents::HotItemChanging, get_HotItem, get_HotTracking,
	///       Raise_HotItemChanged
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_HotItemChanging,
	///       ExLVwLibA::_IExplorerListViewEvents::HotItemChanging, get_HotItem, get_HotTracking,
	///       Raise_HotItemChanged
	/// \endif
	inline HRESULT Raise_HotItemChanging(IListViewItem* pPreviousHotItem, IListViewItem* pNewHotItem, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c IncrementalSearching event</em>
	///
	/// \param[in] currentSearchString The control's current incremental search-string.
	/// \param[in,out] pItemToSelect Receives the zero-based index of the item to select. If set to -1, the
	///                control searches an appropriate item based on the search string. If set to -2, the
	///                search is aborted with an error beep. If set to -3, incremental search string
	///                processing is stopped.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_IncrementalSearching,
	///       ExLVwLibU::_IExplorerListViewEvents::IncrementalSearching,
	///       Raise_IncrementalSearchStringChanging, get_IncrementalSearchString,
	///       get_DisabledEvents
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_IncrementalSearching,
	///       ExLVwLibA::_IExplorerListViewEvents::IncrementalSearching,
	///       Raise_IncrementalSearchStringChanging, get_IncrementalSearchString,
	///       get_DisabledEvents
	/// \endif
	inline HRESULT Raise_IncrementalSearching(BSTR currentSearchString, LONG* pItemToSelect);
	/// \brief <em>Raises the \c IncrementalSearchStringChanging event</em>
	///
	/// \param[in] currentSearchString The control's current incremental search-string.
	/// \param[in] keyCodeOfCharToBeAdded The key code of the character to be added to the search-string.
	///            Most of the values defined by VB's \c KeyCodeConstants enumeration are valid.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should discard the character and leave the
	///                search-string unchanged; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_IncrementalSearchStringChanging,
	///       ExLVwLibU::_IExplorerListViewEvents::IncrementalSearchStringChanging, Raise_KeyPress,
	///       Raise_IncrementalSearching, get_IncrementalSearchString
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_IncrementalSearchStringChanging,
	///       ExLVwLibA::_IExplorerListViewEvents::IncrementalSearchStringChanging, Raise_KeyPress,
	///       Raise_IncrementalSearching, get_IncrementalSearchString
	/// \endif
	inline HRESULT Raise_IncrementalSearchStringChanging(BSTR currentSearchString, SHORT keyCodeOfCharToBeAdded, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c InsertedColumn event</em>
	///
	/// \param[in] pColumn The inserted column.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedColumn,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertedColumn, Raise_InsertingColumn, Raise_RemovedColumn
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedColumn,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertedColumn, Raise_InsertingColumn, Raise_RemovedColumn
	/// \endif
	inline HRESULT Raise_InsertedColumn(IListViewColumn* pColumn);
	/// \brief <em>Raises the \c InsertedGroup event</em>
	///
	/// \param[in] pGroup The inserted group.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertedGroup, Raise_InsertingGroup, Raise_RemovedGroup
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertedGroup, Raise_InsertingGroup, Raise_RemovedGroup
	/// \endif
	inline HRESULT Raise_InsertedGroup(IListViewGroup* pGroup);
	/// \brief <em>Raises the \c InsertedItem event</em>
	///
	/// \param[in] pListItem The inserted item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedItem,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertedItem, Raise_InsertingItem, Raise_RemovedItem
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertedItem,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertedItem, Raise_InsertingItem, Raise_RemovedItem
	/// \endif
	inline HRESULT Raise_InsertedItem(IListViewItem* pListItem);
	/// \brief <em>Raises the \c InsertingColumn event</em>
	///
	/// \param[in] pColumn The column being inserted.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort insertion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingColumn,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertingColumn, Raise_InsertedColumn,
	///       Raise_RemovingColumn
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingColumn,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertingColumn, Raise_InsertedColumn,
	///       Raise_RemovingColumn
	/// \endif
	inline HRESULT Raise_InsertingColumn(IVirtualListViewColumn* pColumn, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c InsertingGroup event</em>
	///
	/// \param[in] pGroup The group being inserted.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort insertion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertingGroup, Raise_InsertedGroup, Raise_RemovingGroup
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertingGroup, Raise_InsertedGroup, Raise_RemovingGroup
	/// \endif
	inline HRESULT Raise_InsertingGroup(IVirtualListViewGroup* pGroup, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c InsertingItem event</em>
	///
	/// \param[in] pListItem The item being inserted.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort insertion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingItem,
	///       ExLVwLibU::_IExplorerListViewEvents::InsertingItem, Raise_InsertedItem, Raise_RemovingItem
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InsertingItem,
	///       ExLVwLibA::_IExplorerListViewEvents::InsertingItem, Raise_InsertedItem, Raise_RemovingItem
	/// \endif
	inline HRESULT Raise_InsertingItem(IVirtualListViewItem* pListItem, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c InvokeVerbFromSubItemControl event</em>
	///
	/// \param[in] pListItem The item on which the action has been invoked.
	/// \param[in] verb A string representing the invoked action. For the \c sicHyperlink sub-item control
	///            this is the value of the \c id attribute of the hyperlink tag that specifies the link.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks Requires comctl32.dll version 6.10 or higher.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_InvokeVerbFromSubItemControl,
	///       ExLVwLibU::_IExplorerListViewEvents::InvokeVerbFromSubItemControl, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, ExLVwLibU::SubItemControlConstants, IPropertyControlBase,
	///       IDrawPropertyControl, IPropertyControl
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_InvokeVerbFromSubItemControl,
	///       ExLVwLibA::_IExplorerListViewEvents::InvokeVerbFromSubItemControl, Raise_GetSubItemControl,
	///       Raise_ConfigureSubItemControl, ExLVwLibA::SubItemControlConstants, IPropertyControlBase,
	///       IDrawPropertyControl, IPropertyControl
	/// \endif
	inline HRESULT Raise_InvokeVerbFromSubItemControl(IListViewItem* pListItem, BSTR verb);
	/// \brief <em>Raises the \c ItemActivate event</em>
	///
	/// \param[in] pListItem The item being activated.
	/// \param[in] pListSubItem The sub-item being activated. May be \c NULL.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner. Will be -1 if the item is activated using the keyboard instead of the
	///            mouse.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner. Will be -1 if the item is activated using the keyboard instead of the
	///            mouse.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemActivate,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemActivate, get_ItemActivationMode,
	///       ListViewItem::get_Activating, ListViewSubItem::get_Activating
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemActivate,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemActivate, get_ItemActivationMode,
	///       ListViewItem::get_Activating, ListViewSubItem::get_Activating
	/// \endif
	inline HRESULT Raise_ItemActivate(IListViewItem* pListItem, IListViewSubItem* pListSubItem, SHORT shift, LONG x, LONG y);
	/// \brief <em>Raises the \c ItemAsynchronousDrawFailed event</em>
	///
	/// \param[in] pListItem The item whose image failed to be drawn.
	/// \param[in] pListSubItem The sub-item whose image failed to be drawn. May be \c NULL.
	/// \param[in,out] pNotificationDetails A \c NMLVASYNCDRAWN struct holding the notification details.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemAsynchronousDrawFailed,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemAsynchronousDrawFailed, get_DrawImagesAsynchronously,
	///       ExLVwLibU::FAILEDIMAGEDETAILS, Raise_GroupAsynchronousDrawFailed,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms670576.aspx">NMLVASYNCDRAWN</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemAsynchronousDrawFailed,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemAsynchronousDrawFailed, get_DrawImagesAsynchronously,
	///       ExLVwLibA::FAILEDIMAGEDETAILS, Raise_GroupAsynchronousDrawFailed,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms670576.aspx">NMLVASYNCDRAWN</a>
	/// \endif
	inline HRESULT Raise_ItemAsynchronousDrawFailed(IListViewItem* pListItem, IListViewSubItem* pListSubItem, NMLVASYNCDRAWN* pNotificationDetails);
	/// \brief <em>Raises the \c ItemBeginDrag event</em>
	///
	/// \param[in] pListItem The item that the user wants to drag.
	/// \param[in] pListSubItem The sub-item that the user wants to drag. May be \c NULL.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid, but usually it should be just
	///            \c vbLeftButton.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies in.
	///            Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemBeginDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemBeginDrag, BeginDrag, OLEDrag, Raise_ItemBeginRDrag,
	///       Raise_ColumnBeginDrag, ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemBeginDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemBeginDrag, BeginDrag, OLEDrag, Raise_ItemBeginRDrag,
	///       Raise_ColumnBeginDrag, ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_ItemBeginDrag(IListViewItem* pListItem, IListViewSubItem* pListSubItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ItemBeginRDrag event</em>
	///
	/// \param[in] pListItem The item that the user wants to drag.
	/// \param[in] pListSubItem The sub-item that the user wants to drag. May be \c NULL.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration is valid, but usually it should be just
	///            \c vbRightButton.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies in.
	///            Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemBeginRDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemBeginRDrag, BeginDrag, OLEDrag, Raise_ItemBeginDrag,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemBeginRDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemBeginRDrag, BeginDrag, OLEDrag, Raise_ItemBeginDrag,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_ItemBeginRDrag(IListViewItem* pListItem, IListViewSubItem* pListSubItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ItemGetDisplayInfo event</em>
	///
	/// \param[in] pListItem The item whose properties are requested.
	/// \param[in] pListSubItem The sub-item whose properties are requested. May be \c NULL.
	/// \param[in] requestedInfo Specifies which properties' values are required. Any combination of
	///            the values defined by the \c RequestedInfoConstants enumeration is valid.
	/// \param[out] pIconIndex The zero-based index of the item's or sub-item's icon. If the \c requestedInfo
	///             parameter doesn't include \c riIconIndex, the caller should ignore this value.
	/// \param[out] pIndent The requested indentation. If the \c requestedInfo parameter doesn't
	///             include \c riIndent, the caller should ignore this value.
	/// \param[out] pGroupID The unique ID of the item's listview group. If the \c requestedInfo parameter
	///             doesn't include \c riGroupID, the caller should ignore this value.
	/// \param[out] ppTileViewColumns The requested array of \c TILEVIEWSUBITEM structs. If the
	///             \c requestedInfo parameter doesn't include \c riTileViewColumns, the caller should ignore
	///             this value.
	/// \param[in] maxItemTextLength The maximum number of characters the item's or sub-item's text may
	///            consist of. If the \c requestedInfo parameter doesn't include \c riItemText, the client
	///            should ignore this value.
	/// \param[out] pItemText The item's or sub-item's text. If the \c requestedInfo parameter doesn't include
	///             \c riItemText, the caller should ignore this value.
	/// \param[out] pOverlayIndex The zero-based index of the item's or sub-item's overlay icon. If the
	///             \c requestedInfo parameter doesn't include \c riOverlayIndex, the caller should ignore
	///             this value.
	/// \param[out] pStateImageIndex The one-based index of the item's or sub-item's state image. If the
	///             \c requestedInfo parameter doesn't include \c riStateImageIndex, the caller should
	///             ignore this value.
	/// \param[out] pItemStates A bit field specifying which of the following item or sub-item properties are
	///             equal to \c VARIANT_TRUE: \n
	///             - \c ListViewItem::get_Activating, ListViewSubItem::get_Activating
	///             - \c ListViewItem::get_Caret
	///             - \c ListViewItem::get_DropHilited
	///             - \c ListViewItem::get_Ghosted, ListViewSubItem::get_Ghosted
	///             - \c ListViewItem::get_Glowing, ListViewSubItem::get_Glowing
	///             - \c ListViewItem::get_Selected
	///
	///             Any combination of the following values defined by the \c ItemStateConstants
	///             enumeration is valid:\n
	///             - \c isActivating If the \c requestedInfo parameter doesn't include \c riActivating, the
	///               caller should ignore this flag.
	///             - \c isCaret If the \c requestedInfo parameter doesn't include \c riCaret, the caller
	///               should ignore this flag.
	///             - \c isDropHilited If the \c requestedInfo parameter doesn't include \c riDropHilited,
	///               the caller should ignore this flag.
	///             - \c isGhosted If the \c requestedInfo parameter doesn't include \c riGhosted, the caller
	///               should ignore this flag.
	///             - \c isGlowing If the \c requestedInfo parameter doesn't include \c riGlowing, the caller
	///               should ignore this flag.
	///             - \c isSelected If the \c requestedInfo parameter doesn't include \c riSelected, the
	///               caller should ignore this flag.
	/// \param[in,out] pDontAskAgain If \c VARIANT_TRUE, the caller should always use the same settings
	///                and never fire this event again for these properties of this item or sub-items;
	///                otherwise it shouldn't make the values persistent.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetDisplayInfo,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemGetDisplayInfo, Raise_ItemSetText,
	///       ListViewItem::put_IconIndex, ListViewSubItem::put_IconIndex, put_hImageList,
	///       put_ShowSubItemImages, ListViewItem::put_Indent, ListViewItem::put_Group,
	///       ListViewItem::put_TileViewColumns, ExLVwLibU::TILEVIEWSUBITEM, put_TileViewItemLines,
	///       ListViewItem::put_Text, ListViewSubItem::put_Text, ListViewItem::put_OverlayIndex,
	///       ListViewSubItem::put_OverlayIndex, ListViewItem::put_StateImageIndex,
	///       ListViewSubItem::put_StateImageIndex, put_CallBackMask, put_VirtualMode,
	///       ExLVwLibU::RequestedInfoConstants, ExLVwLibU::ItemStateConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetDisplayInfo,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemGetDisplayInfo, Raise_ItemSetText,
	///       ListViewItem::put_IconIndex, ListViewSubItem::put_IconIndex, put_hImageList,
	///       put_ShowSubItemImages, ListViewItem::put_Indent, ListViewItem::put_Group,
	///       ListViewItem::put_TileViewColumns, ExLVwLibA::TILEVIEWSUBITEM, put_TileViewItemLines,
	///       ListViewItem::put_Text, ListViewSubItem::put_Text, ListViewItem::put_OverlayIndex,
	///       ListViewSubItem::put_OverlayIndex, ListViewItem::put_StateImageIndex,
	///       ListViewSubItem::put_StateImageIndex, put_CallBackMask, put_VirtualMode,
	///       ExLVwLibA::RequestedInfoConstants, ExLVwLibA::ItemStateConstants
	/// \endif
	inline HRESULT Raise_ItemGetDisplayInfo(IListViewItem* pListItem, IListViewSubItem* pListSubItem, RequestedInfoConstants requestedInfo, LONG* pIconIndex, LONG* pIndent, LONG* pGroupID, LPSAFEARRAY* ppTileViewColumns, LONG maxItemTextLength, BSTR* pItemText, LONG* pOverlayIndex, LONG* pStateImageIndex, ItemStateConstants* pItemStates, VARIANT_BOOL* pDontAskAgain);
	/// \brief <em>Raises the \c ItemGetGroup event</em>
	///
	/// \param[in] itemIndex The item's zero-based (control-wide) index.
	/// \param[in] occurrenceIndex The zero-based index of the item's copy for which the group membership is
	///            retrieved.
	/// \param[out] pGroupIndex Must be set to the zero-based index of the listview group that shall contain
	///             the specified copy of the specified item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemGetGroup, Raise_ItemGetOccurrencesCount,
	///       get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemGetGroup, Raise_ItemGetOccurrencesCount,
	///       get_VirtualMode
	/// \endif
	inline HRESULT Raise_ItemGetGroup(LONG itemIndex, LONG occurrenceIndex, LONG* pGroupIndex);
	/// \brief <em>Raises the \c ItemGetInfoTipText event</em>
	///
	/// \param[in] pListItem The item whose info tip text is requested.
	/// \param[in] maxInfoTipLength The maximum number of characters the info tip text may consist of.
	/// \param[out] pInfoTipText The item's info tip text.
	/// \param[in,out] pAbortToolTip If \c VARIANT_TRUE, the caller should NOT show the tooltip;
	///                otherwise it should.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetInfoTipText,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemGetInfoTipText, put_ToolTips,
	///       ListViewItem::SetInfoTipText, Raise_SettingItemInfoTipText
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetInfoTipText,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemGetInfoTipText, put_ToolTips,
	///       ListViewItem::SetInfoTipText, Raise_SettingItemInfoTipText
	/// \endif
	inline HRESULT Raise_ItemGetInfoTipText(IListViewItem* pListItem, LONG maxInfoTipLength, BSTR* pInfoTipText, VARIANT_BOOL* pAbortToolTip);
	/// \brief <em>Raises the \c ItemGetOccurrencesCount event</em>
	///
	/// \param[in] itemIndex The item's zero-based (control-wide) index.
	/// \param[out] pOccurrencesCount Must be set to the number of occurrences of the item in the listview
	///             control.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetOccurrencesCount,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemGetOccurrencesCount, Raise_ItemGetGroup,
	///       get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemGetOccurrencesCount,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemGetOccurrencesCount, Raise_ItemGetGroup,
	///       get_VirtualMode
	/// \endif
	inline HRESULT Raise_ItemGetOccurrencesCount(LONG itemIndex, LONG* pOccurrencesCount);
	/// \brief <em>Raises the \c ItemMouseEnter event</em>
	///
	/// \param[in] pListItem The item that was entered.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemMouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemMouseEnter, Raise_ItemMouseLeave,
	///       Raise_SubItemMouseEnter, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemMouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemMouseEnter, Raise_ItemMouseLeave,
	///       Raise_SubItemMouseEnter, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_ItemMouseEnter(IListViewItem* pListItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ItemMouseLeave event</em>
	///
	/// \param[in] pListItem The item that was left.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemMouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemMouseLeave, Raise_ItemMouseEnter,
	///       Raise_SubItemMouseLeave, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemMouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemMouseLeave, Raise_ItemMouseEnter,
	///       Raise_SubItemMouseLeave, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_ItemMouseLeave(IListViewItem* pListItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c ItemSelectionChanged event</em>
	///
	/// \param[in] itemIndex The item that was selected/deselected.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa put_MultiSelect, Proxy_IExplorerListViewEvents::Fire_ItemSelectionChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemSelectionChanged, Raise_BeginMarqueeSelection,
	///       Raise_SelectedItemRange, Raise_CaretChanged, Raise_GroupSelectionChanged,
	///       ListViewItem::put_Selected
	/// \else
	///   \sa put_MultiSelect, Proxy_IExplorerListViewEvents::Fire_ItemSelectionChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemSelectionChanged, Raise_BeginMarqueeSelection,
	///       Raise_SelectedItemRange, Raise_CaretChanged, Raise_GroupSelectionChanged,
	///       ListViewItem::put_Selected
	/// \endif
	inline HRESULT Raise_ItemSelectionChanged(LVITEMINDEX& itemIndex);
	/// \brief <em>Raises the \c ItemSetText event</em>
	///
	/// \param[in] pListItem The item whose text was changed.
	/// \param[in] itemText The item's new text.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemSetText,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemSetText, Raise_ItemGetDisplayInfo,
	///       ListViewItem::put_Text
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemSetText,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemSetText, Raise_ItemGetDisplayInfo,
	///       ListViewItem::put_Text
	/// \endif
	inline HRESULT Raise_ItemSetText(IListViewItem* pListItem, BSTR itemText);
	/// \brief <em>Raises the \c ItemStateImageChanged event</em>
	///
	/// \param[in] pListItem The item whose state image was changed.
	/// \param[in] previousStateImageIndex The one-based index of the item's previous state image.
	/// \param[in] newStateImageIndex The one-based index of the item's new state image.
	/// \param[in] causedBy The reason for the state image change. Any of the values defined by the
	///            \c StateImageChangeCausedByConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If the \c SimpleSelect property is set to \c VARIANT_TRUE and the state image is toggled
	///          using the keyboard, the state image will be updated for all selected items, but this event
	///          will be raised for the caret item only.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemStateImageChanged,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemStateImageChanged, Raise_ItemStateImageChanging,
	///       Raise_ColumnStateImageChanged, get_SimpleSelect, ListViewItem::get_StateImageIndex,
	///       ExLVwLibU::StateImageChangeCausedByConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemStateImageChanged,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemStateImageChanged, Raise_ItemStateImageChanging,
	///       Raise_ColumnStateImageChanged, get_SimpleSelect, ListViewItem::get_StateImageIndex,
	///       ExLVwLibA::StateImageChangeCausedByConstants
	/// \endif
	inline HRESULT Raise_ItemStateImageChanged(IListViewItem* pListItem, LONG previousStateImageIndex, LONG newStateImageIndex, StateImageChangeCausedByConstants causedBy);
	/// \brief <em>Raises the \c ItemStateImageChanging event</em>
	///
	/// \param[in] pListItem The item whose state image shall be changed.
	/// \param[in] previousStateImageIndex The one-based index of the item's previous state image.
	/// \param[in,out] pNewStateImageIndex The one-based index of the item's new state image. The client
	///                may change this value.
	/// \param[in] causedBy The reason for the state image change. Any of the values defined by the
	///            \c StateImageChangeCausedByConstants enumeration is valid.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should prevent the state image from changing;
	///                otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks If the \c SimpleSelect property is set to \c VARIANT_TRUE and the state image is toggled
	///          using the keyboard, the state image will be updated for all selected items, but this event
	///          will be raised for the caret item only.\n
	///          The user may change the new state image's index.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemStateImageChanging,
	///       ExLVwLibU::_IExplorerListViewEvents::ItemStateImageChanging, Raise_ItemStateImageChanged,
	///       Raise_ColumnStateImageChanging, get_SimpleSelect, ListViewItem::get_StateImageIndex,
	///       ExLVwLibU::StateImageChangeCausedByConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ItemStateImageChanging,
	///       ExLVwLibA::_IExplorerListViewEvents::ItemStateImageChanging, Raise_ItemStateImageChanged,
	///       Raise_ColumnStateImageChanging, get_SimpleSelect, ListViewItem::get_StateImageIndex,
	///       ExLVwLibA::StateImageChangeCausedByConstants
	/// \endif
	inline HRESULT Raise_ItemStateImageChanging(IListViewItem* pListItem, LONG previousStateImageIndex, LONG* pNewStateImageIndex, StateImageChangeCausedByConstants causedBy, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c KeyDown event</em>
	///
	/// \param[in,out] pKeyCode The pressed key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYDOWN message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyDown,
	///       ExLVwLibU::_IExplorerListViewEvents::KeyDown, Raise_IncrementalSearchStringChanging,
	///       Raise_KeyUp, Raise_KeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyDown,
	///       ExLVwLibA::_IExplorerListViewEvents::KeyDown, Raise_IncrementalSearchStringChanging,
	///       Raise_KeyUp, Raise_KeyPress
	/// \endif
	inline HRESULT Raise_KeyDown(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c KeyPress event</em>
	///
	/// \param[in,out] pKeyAscii The pressed key's ASCII code. If set to 0, the caller should eat the
	///                \c WM_CHAR message.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyPress,
	///       ExLVwLibU::_IExplorerListViewEvents::KeyPress, Raise_KeyDown, Raise_KeyUp
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyPress,
	///       ExLVwLibA::_IExplorerListViewEvents::KeyPress, Raise_KeyDown, Raise_KeyUp
	/// \endif
	inline HRESULT Raise_KeyPress(SHORT* pKeyAscii);
	/// \brief <em>Raises the \c KeyUp event</em>
	///
	/// \param[in,out] pKeyCode The released key. Any of the values defined by VB's \c KeyCodeConstants
	///                enumeration is valid. If set to 0, the caller should eat the \c WM_KEYUP message.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyUp,
	///       ExLVwLibU::_IExplorerListViewEvents::KeyUp, Raise_KeyDown, Raise_KeyPress
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_KeyUp,
	///       ExLVwLibA::_IExplorerListViewEvents::KeyUp, Raise_KeyDown, Raise_KeyPress
	/// \endif
	inline HRESULT Raise_KeyUp(SHORT* pKeyCode, SHORT shift);
	/// \brief <em>Raises the \c MapGroupWideToTotalItemIndex event</em>
	///
	/// \param[in] groupIndex The zero-based index of the item's listview group.
	/// \param[in] groupWideItemIndex The item's zero-based group-wide index.
	/// \param[out] pTotalItemIndex Must be set to the item's zero-based total index.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MapGroupWideToTotalItemIndex,
	///       ExLVwLibU::_IExplorerListViewEvents::MapGroupWideToTotalItemIndex, Raise_ItemGetDisplayInfo,
	///       get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MapGroupWideToTotalItemIndex,
	///       ExLVwLibA::_IExplorerListViewEvents::MapGroupWideToTotalItemIndex, Raise_ItemGetDisplayInfo,
	///       get_VirtualMode
	/// \endif
	inline HRESULT Raise_MapGroupWideToTotalItemIndex(LONG groupIndex, LONG groupWideItemIndex, LONG* pTotalItemIndex);
	/// \brief <em>Raises the \c MClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MClick,
	///       ExLVwLibU::_IExplorerListViewEvents::MClick, Raise_MDblClick, Raise_Click, Raise_RClick,
	///       Raise_XClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MClick,
	///       ExLVwLibA::_IExplorerListViewEvents::MClick, Raise_MDblClick, Raise_Click, Raise_RClick,
	///       Raise_XClick
	/// \endif
	inline HRESULT Raise_MClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbMiddleButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::MDblClick, Raise_MClick, Raise_DblClick,
	///       Raise_RDblClick, Raise_XDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::MDblClick, Raise_MClick, Raise_DblClick,
	///       Raise_RDblClick, Raise_XDblClick
	/// \endif
	inline HRESULT Raise_MDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseDown event</em>
	///
	/// \param[in] button The pressed mouse button. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseDown,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseDown, Raise_MouseUp, Raise_Click, Raise_MClick,
	///       Raise_RClick, Raise_XClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseDown,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseDown, Raise_MouseUp, Raise_Click, Raise_MClick,
	///       Raise_RClick, Raise_XClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseDown(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseEnter event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseEnter, Raise_MouseLeave, Raise_ItemMouseEnter,
	///       Raise_MouseHover, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseEnter, Raise_MouseLeave, Raise_ItemMouseEnter,
	///       Raise_MouseHover, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseEnter(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseHover event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseHover,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseHover, Raise_MouseEnter, Raise_MouseLeave,
	///       Raise_MouseMove, put_HoverTime, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseHover,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseHover, Raise_MouseEnter, Raise_MouseLeave,
	///       Raise_MouseMove, put_HoverTime, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseHover(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseLeave event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseLeave, Raise_MouseEnter, Raise_ItemMouseLeave,
	///       Raise_MouseHover, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseLeave, Raise_MouseEnter, Raise_ItemMouseLeave,
	///       Raise_MouseHover, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseLeave(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseMove event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseMove, Raise_MouseEnter, Raise_MouseLeave,
	///       Raise_MouseDown, Raise_MouseUp, Raise_MouseWheel, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseMove, Raise_MouseEnter, Raise_MouseLeave,
	///       Raise_MouseDown, Raise_MouseUp, Raise_MouseWheel, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseMove(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseUp event</em>
	///
	/// \param[in] button The released mouse buttons. Any of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseUp,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseUp, Raise_MouseDown, Raise_Click, Raise_MClick,
	///       Raise_RClick, Raise_XClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseUp,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseUp, Raise_MouseDown, Raise_Click, Raise_MClick,
	///       Raise_RClick, Raise_XClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_MouseUp(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c MouseWheel event</em>
	///
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] scrollAxis Specifies whether the user intents to scroll vertically or horizontally.
	///            Any of the values defined by the \c ScrollAxisConstants enumeration is valid.
	/// \param[in] wheelDelta The distance the wheel has been rotated.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseWheel,
	///       ExLVwLibU::_IExplorerListViewEvents::MouseWheel, Raise_MouseMove, Raise_EditMouseWheel,
	///       Raise_HeaderMouseWheel, ExLVwLibU::ExtendedMouseButtonConstants, ExLVwLibU::ScrollAxisConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_MouseWheel,
	///       ExLVwLibA::_IExplorerListViewEvents::MouseWheel, Raise_MouseMove, Raise_EditMouseWheel,
	///       Raise_HeaderMouseWheel, ExLVwLibA::ExtendedMouseButtonConstants, ExLVwLibA::ScrollAxisConstants
	/// \endif
	inline HRESULT Raise_MouseWheel(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, ScrollAxisConstants scrollAxis, SHORT wheelDelta);
	/// \brief <em>Raises the \c OLECompleteDrag event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] performedEffect The performed drop effect. Any of the values (except \c odeScroll)
	///            defined by the \c OLEDropEffectConstants enumeration is valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLECompleteDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::OLECompleteDrag, Raise_OLEStartDrag,
	///       Raise_HeaderOLECompleteDrag, ExLVwLibU::IOLEDataObject::GetData, OLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLECompleteDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::OLECompleteDrag, Raise_OLEStartDrag,
	///       Raise_HeaderOLECompleteDrag, ExLVwLibA::IOLEDataObject::GetData, OLEDrag
	/// \endif
	inline HRESULT Raise_OLECompleteDrag(IOLEDataObject* pData, OLEDropEffectConstants performedEffect);
	/// \brief <em>Raises the \c OLEDragDrop event</em>
	///
	/// \param[in] pData The dropped data.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the
	///                client finally executed.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragDrop,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragDrop, Raise_OLEDragEnter,
	///       Raise_OLEDragMouseMove, Raise_OLEDragLeave, Raise_MouseUp, Raise_HeaderOLEDragDrop,
	///       get_RegisterForOLEDragDrop, FinishOLEDragDrop,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragDrop,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragDrop, Raise_OLEDragEnter,
	///       Raise_OLEDragMouseMove, Raise_OLEDragLeave, Raise_MouseUp, Raise_HeaderOLEDragDrop,
	///       get_RegisterForOLEDragDrop, FinishOLEDragDrop,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_OLEDragDrop(IDataObject* pData, LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c OLEDragEnter event</em>
	///
	/// \param[in] fakedEnter If \c FALSE, the method replaces the cached data object; otherwise not.
	/// \param[in] pData The dragged data. If \c NULL, the cached data object is used. We use this when
	///            we call this method from other places than \c DragEnter.
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the
	///                client wants to be used on drop.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragEnter, Raise_OLEDragMouseMove,
	///       Raise_OLEDragLeave, Raise_OLEDragDrop, Raise_MouseEnter, Raise_HeaderOLEDragEnter,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragEnter, Raise_OLEDragMouseMove,
	///       Raise_OLEDragLeave, Raise_OLEDragDrop, Raise_MouseEnter, Raise_HeaderOLEDragEnter,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_OLEDragEnter(BOOL fakedEnter, IDataObject* pData, LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c OLEDragEnterPotentialTarget event</em>
	///
	/// \param[in] hWndPotentialTarget The potential drop target window's handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragEnterPotentialTarget,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragEnterPotentialTarget,
	///       Raise_OLEDragLeavePotentialTarget, Raise_HeaderOLEDragEnterPotentialTarget, OLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragEnterPotentialTarget,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragEnterPotentialTarget,
	///       Raise_OLEDragLeavePotentialTarget, Raise_HeaderOLEDragEnterPotentialTarget, OLEDrag
	/// \endif
	inline HRESULT Raise_OLEDragEnterPotentialTarget(LONG hWndPotentialTarget);
	/// \brief <em>Raises the \c OLEDragLeave event</em>
	///
	/// \param[in] fakedLeave If \c FALSE, the method kills the \c ID_DRAGSCROLL timer and releases the
	///            cached data object; otherwise not.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragLeave, Raise_OLEDragEnter,
	///       Raise_OLEDragMouseMove, Raise_OLEDragDrop, Raise_MouseLeave, Raise_HeaderOLEDragLeave
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragLeave, Raise_OLEDragEnter,
	///       Raise_OLEDragMouseMove, Raise_OLEDragDrop, Raise_MouseLeave, Raise_HeaderOLEDragLeave
	/// \endif
	inline HRESULT Raise_OLEDragLeave(BOOL fakedLeave, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c OLEDragLeavePotentialTarget event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragLeavePotentialTarget,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragLeavePotentialTarget,
	///       Raise_OLEDragEnterPotentialTarget, Raise_HeaderOLEDragLeavePotentialTarget, OLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragLeavePotentialTarget,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragLeavePotentialTarget,
	///       Raise_OLEDragEnterPotentialTarget, Raise_HeaderOLEDragLeavePotentialTarget, OLEDrag
	/// \endif
	inline HRESULT Raise_OLEDragLeavePotentialTarget(void);
	/// \brief <em>Raises the \c OLEDragMouseMove event</em>
	///
	/// \param[in,out] pEffect On entry, a bit field of the drop effects (defined by the \c DROPEFFECT
	///                enumeration) supported by the drag source. On return, the drop effect that the
	///                client wants to be used on drop.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in] mousePosition The mouse cursor's position (in pixels) relative to the screen's
	///            upper-left corner.
	/// \param[out] pCallDropTargetHelper If set to \c TRUE, the caller should call the appropriate
	///             \c IDropTargetHelper method; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragMouseMove,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEDragMouseMove, Raise_OLEDragEnter,
	///       Raise_OLEDragLeave, Raise_OLEDragDrop, Raise_MouseMove, Raise_HeaderOLEDragMouseMove,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEDragMouseMove,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEDragMouseMove, Raise_OLEDragEnter,
	///       Raise_OLEDragLeave, Raise_OLEDragDrop, Raise_MouseMove, Raise_HeaderOLEDragMouseMove,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_OLEDragMouseMove(LPDWORD pEffect, DWORD keyState, POINTL mousePosition, BOOL* pCallDropTargetHelper);
	/// \brief <em>Raises the \c OLEGiveFeedback event</em>
	///
	/// \param[in] effect The current drop effect. It is chosen by the potential drop target. Any of
	///            the values defined by the \c DROPEFFECT enumeration is valid.
	/// \param[in,out] pUseDefaultCursors If set to \c VARIANT_TRUE, the system's default mouse cursors
	///                shall be used to visualize the various drop effects. If set to \c VARIANT_FALSE,
	///                the client has set a custom mouse cursor.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEGiveFeedback,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEGiveFeedback, Raise_OLEQueryContinueDrag,
	///       Raise_HeaderOLEGiveFeedback,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEGiveFeedback,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEGiveFeedback, Raise_OLEQueryContinueDrag,
	///       Raise_HeaderOLEGiveFeedback,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms693457.aspx">DROPEFFECT</a>
	/// \endif
	inline HRESULT Raise_OLEGiveFeedback(DWORD effect, VARIANT_BOOL* pUseDefaultCursors);
	/// \brief <em>Raises the \c OLEQueryContinueDrag event</em>
	///
	/// \param[in] pressedEscape If \c TRUE, the user has pressed the \c ESC key since the last time
	///            this event was raised; otherwise not.
	/// \param[in] keyState The pressed modifier keys (Shift, Ctrl, Alt) and mouse buttons. Any
	///            combination of the pressed button's and key's \c MK_* flags is valid.
	/// \param[in,out] pActionToContinueWith Indicates whether to continue (\c S_OK), cancel
	///                (\c DRAGDROP_S_CANCEL) or complete (\c DRAGDROP_S_DROP) the drag'n'drop operation.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEQueryContinueDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEQueryContinueDrag, Raise_OLEGiveFeedback,
	///       Raise_HeaderOLEQueryContinueDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEQueryContinueDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEQueryContinueDrag, Raise_OLEGiveFeedback,
	///       Raise_HeaderOLEQueryContinueDrag
	/// \endif
	inline HRESULT Raise_OLEQueryContinueDrag(BOOL pressedEscape, DWORD keyState, HRESULT* pActionToContinueWith);
	/// \brief <em>Raises the \c OLEReceivedNewData event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] formatID An integer value specifying the format the data object has received data for.
	///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
	///            other format that has been registered using the \c RegisterClipboardFormat API function.
	/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
	///            member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS require multiple
	///            \c FORMATETC structs for the same format. In such cases each struct of this format will
	///            have a separate index.
	/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
	///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
	///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEReceivedNewData,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEReceivedNewData, Raise_HeaderOLEReceivedNewData,
	///       Raise_OLESetData, SourceOLEDataObject::GetData, OLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEReceivedNewData,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEReceivedNewData, Raise_HeaderOLEReceivedNewData,
	///       Raise_OLESetData, SourceOLEDataObject::GetData, OLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \endif
	HRESULT Raise_OLEReceivedNewData(IOLEDataObject* pData, LONG formatID, LONG index, LONG dataOrViewAspect);
	/// \brief <em>Raises the \c OLESetData event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	/// \param[in] formatID An integer value specifying the format the drop target is requesting data for.
	///            Valid values are those defined by VB's \c ClipBoardConstants enumeration, but also any
	///            other format that has been registered using the \c RegisterClipboardFormat API function.
	/// \param[in] index An integer value that is assigned to the internal \c FORMATETC struct's \c lindex
	///            member. Usually it is -1, but some formats like \c CFSTR_FILECONTENTS require multiple
	///            \c FORMATETC structs for the same format. In such cases each struct of this format will
	///            have a separate index.
	/// \param[in] dataOrViewAspect An integer value that is assigned to the internal \c FORMATETC struct's
	///            \c dwAspect member. Any of the \c DVASPECT_* values defined by the Microsoft&reg;
	///            Windows&reg; SDK are valid. The default is \c DVASPECT_CONTENT.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLESetData,
	///       ExLVwLibU::_IExplorerListViewEvents::OLESetData, Raise_OLEStartDrag, Raise_HeaderOLESetData,
	///       SourceOLEDataObject::SetData, OLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLESetData,
	///       ExLVwLibA::_IExplorerListViewEvents::OLESetData, Raise_OLEStartDrag, Raise_HeaderOLESetData,
	///       SourceOLEDataObject::SetData, OLEDrag,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms649049.aspx">RegisterClipboardFormat</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms682177.aspx">FORMATETC</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/bb776902.aspx#CFSTR_FILECONTENTS">CFSTR_FILECONTENTS</a>,
	///       <a href="https://msdn.microsoft.com/en-us/library/ms690318.aspx">DVASPECT</a>
	/// \endif
	HRESULT Raise_OLESetData(IOLEDataObject* pData, LONG formatID, LONG index, LONG dataOrViewAspect);
	/// \brief <em>Raises the \c OLEStartDrag event</em>
	///
	/// \param[in] pData The object that holds the dragged data.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEStartDrag,
	///       ExLVwLibU::_IExplorerListViewEvents::OLEStartDrag, Raise_OLESetData, Raise_OLECompleteDrag,
	///       Raise_HeaderOLEStartDrag, SourceOLEDataObject::SetData, OLEDrag
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OLEStartDrag,
	///       ExLVwLibA::_IExplorerListViewEvents::OLEStartDrag, Raise_OLESetData, Raise_OLECompleteDrag,
	///       Raise_HeaderOLEStartDrag, SourceOLEDataObject::SetData, OLEDrag
	/// \endif
	inline HRESULT Raise_OLEStartDrag(IOLEDataObject* pData);
	/// \brief <em>Raises the \c OwnerDrawItem event</em>
	///
	/// \param[in] pListItem The item to draw.
	/// \param[in] itemState The item's current state (focused, selected etc.). Most of the values
	///            defined by the \c OwnerDrawItemStateConstants enumeration are valid.
	/// \param[in] hDC The handle of the device context in which all drawing shall take place.
	/// \param[in] pDrawingRectangle A \c RECTANGLE structure specifying the bounding rectangle of the
	///            area that needs to be drawn.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_OwnerDrawItem,
	///       ExLVwLibU::_IExplorerListViewEvents::OwnerDrawItem, Raise_CustomDraw,
	///       Raise_HeaderOwnerDrawItem, get_ItemHeight, get_OwnerDrawn, get_View, ExLVwLibU::RECTANGLE,
	///       ExLVwLibU::OwnerDrawItemStateConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_OwnerDrawItem,
	///       ExLVwLibA::_IExplorerListViewEvents::OwnerDrawItem, Raise_CustomDraw,
	///       Raise_HeaderOwnerDrawItem, get_ItemHeight, get_OwnerDrawn, get_View, ExLVwLibA::RECTANGLE,
	///       ExLVwLibA::OwnerDrawItemStateConstants
	/// \endif
	inline HRESULT Raise_OwnerDrawItem(IListViewItem* pListItem, OwnerDrawItemStateConstants itemState, LONG hDC, RECTANGLE* pDrawingRectangle);
	/// \brief <em>Raises the \c RClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RClick,
	///       ExLVwLibU::_IExplorerListViewEvents::RClick, Raise_ContextMenu, Raise_RDblClick, Raise_Click,
	///       Raise_MClick, Raise_XClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RClick,
	///       ExLVwLibA::_IExplorerListViewEvents::RClick, Raise_ContextMenu, Raise_RDblClick, Raise_Click,
	///       Raise_MClick, Raise_XClick
	/// \endif
	inline HRESULT Raise_RClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c RDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be \c vbRightButton (defined by VB's \c MouseButtonConstants enumeration).
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::RDblClick, Raise_RClick, Raise_DblClick, Raise_MDblClick,
	///       Raise_XDblClick
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::RDblClick, Raise_RClick, Raise_DblClick, Raise_MDblClick,
	///       Raise_XDblClick
	/// \endif
	inline HRESULT Raise_RDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c RecreatedControlWindow event</em>
	///
	/// \param[in] hWnd The control's window handle.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RecreatedControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::RecreatedControlWindow, Raise_DestroyedControlWindow,
	///       get_hWnd
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RecreatedControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::RecreatedControlWindow, Raise_DestroyedControlWindow,
	///       get_hWnd
	/// \endif
	inline HRESULT Raise_RecreatedControlWindow(HWND hWnd);
	/// \brief <em>Raises the \c RemovedColumn event</em>
	///
	/// \param[in] pColumn The removed column.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedColumn,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovedColumn, Raise_RemovingColumn, Raise_InsertedColumn
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedColumn,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovedColumn, Raise_RemovingColumn, Raise_InsertedColumn
	/// \endif
	inline HRESULT Raise_RemovedColumn(IVirtualListViewColumn* pColumn);
	/// \brief <em>Raises the \c RemovedGroup event</em>
	///
	/// \param[in] pGroup The removed group.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovedGroup, Raise_RemovingGroup, Raise_InsertedGroup
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovedGroup, Raise_RemovingGroup, Raise_InsertedGroup
	/// \endif
	inline HRESULT Raise_RemovedGroup(IVirtualListViewGroup* pGroup);
	/// \brief <em>Raises the \c RemovedItem event</em>
	///
	/// \param[in] pListItem The removed item.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedItem,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovedItem, Raise_RemovingItem, Raise_InsertedItem
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovedItem,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovedItem, Raise_RemovingItem, Raise_InsertedItem
	/// \endif
	inline HRESULT Raise_RemovedItem(IVirtualListViewItem* pListItem);
	/// \brief <em>Raises the \c RemovingColumn event</em>
	///
	/// \param[in] pColumn The column being removed.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort deletion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingColumn,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovingColumn, Raise_RemovedColumn, Raise_InsertingColumn
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingColumn,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovingColumn, Raise_RemovedColumn, Raise_InsertingColumn
	/// \endif
	inline HRESULT Raise_RemovingColumn(IListViewColumn* pColumn, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c RemovingGroup event</em>
	///
	/// \param[in] pGroup The group being removed.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort deletion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingGroup,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovingGroup, Raise_RemovedGroup, Raise_InsertingGroup
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingGroup,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovingGroup, Raise_RemovedGroup, Raise_InsertingGroup
	/// \endif
	inline HRESULT Raise_RemovingGroup(IListViewGroup* pGroup, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c RemovingItem event</em>
	///
	/// \param[in] pListItem The item being removed.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort deletion; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingItem,
	///       ExLVwLibU::_IExplorerListViewEvents::RemovingItem, Raise_RemovedItem, Raise_InsertingItem
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RemovingItem,
	///       ExLVwLibA::_IExplorerListViewEvents::RemovingItem, Raise_RemovedItem, Raise_InsertingItem
	/// \endif
	inline HRESULT Raise_RemovingItem(IListViewItem* pListItem, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c RenamedItem event</em>
	///
	/// \param[in] pListItem The renamed item.
	/// \param[in] previousItemText The item's previous text.
	/// \param[in] newItemText The item's new text.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RenamedItem,
	///       ExLVwLibU::_IExplorerListViewEvents::RenamedItem, Raise_RenamingItem,
	///       Raise_StartingLabelEditing, Raise_DestroyedEditControlWindow
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RenamedItem,
	///       ExLVwLibA::_IExplorerListViewEvents::RenamedItem, Raise_RenamingItem,
	///       Raise_StartingLabelEditing, Raise_DestroyedEditControlWindow
	/// \endif
	inline HRESULT Raise_RenamedItem(IListViewItem* pListItem, BSTR previousItemText, BSTR newItemText);
	/// \brief <em>Raises the \c RenamingItem event</em>
	///
	/// \param[in] pListItem The item being renamed.
	/// \param[in] previousItemText The item's previous text.
	/// \param[in] newItemText The item's new text.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should abort renaming; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_RenamingItem,
	///       ExLVwLibU::_IExplorerListViewEvents::RenamingItem, Raise_RenamedItem,
	///       Raise_StartingLabelEditing, Raise_DestroyedEditControlWindow
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_RenamingItem,
	///       ExLVwLibA::_IExplorerListViewEvents::RenamingItem, Raise_RenamedItem,
	///       Raise_StartingLabelEditing, Raise_DestroyedEditControlWindow
	/// \endif
	inline HRESULT Raise_RenamingItem(IListViewItem* pListItem, BSTR previousItemText, BSTR newItemText, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c ResizedControlWindow event</em>
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ResizedControlWindow,
	///       ExLVwLibU::_IExplorerListViewEvents::ResizedControlWindow
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ResizedControlWindow,
	///       ExLVwLibA::_IExplorerListViewEvents::ResizedControlWindow
	/// \endif
	inline HRESULT Raise_ResizedControlWindow(void);
	/// \brief <em>Raises the \c ResizingColumn event</em>
	///
	/// \param[in] pColumn The column being resized.
	/// \param[in] pNewColumnWidth The column's new width in pixels. The client may change this value.
	/// \param[in,out] pAbortResizing If \c VARIANT_TRUE, the caller should abort column resizing; otherwise
	///                not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_ResizingColumn,
	///       ExLVwLibU::_IExplorerListViewEvents::ResizingColumn, Raise_BeginColumnResizing,
	///       Raise_EndColumnResizing, ListViewColumn::get_Width
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_ResizingColumn,
	///       ExLVwLibA::_IExplorerListViewEvents::ResizingColumn, Raise_BeginColumnResizing,
	///       Raise_EndColumnResizing, ListViewColumn::get_Width
	/// \endif
	inline HRESULT Raise_ResizingColumn(IListViewColumn* pColumn, LONG* pNewColumnWidth, VARIANT_BOOL* pAbortResizing);
	/// \brief <em>Raises the \c SelectedItemRange event</em>
	///
	/// \param[in] pFirstItem The first item that was selected.
	/// \param[in] pLastItem The last item that was selected.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event won't be raised if \c get_VirtualMode returns \c VARIANT_FALSE.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_SelectedItemRange,
	///       ExLVwLibU::_IExplorerListViewEvents::SelectedItemRange, Raise_ItemSelectionChanged,
	///       Raise_BeginMarqueeSelection, get_VirtualMode
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_SelectedItemRange,
	///       ExLVwLibA::_IExplorerListViewEvents::SelectedItemRange, Raise_ItemSelectionChanged,
	///       Raise_BeginMarqueeSelection, get_VirtualMode
	/// \endif
	inline HRESULT Raise_SelectedItemRange(IListViewItem* pFirstItem, IListViewItem* pLastItem);
	/// \brief <em>Raises the \c SettingItemInfoTipText event</em>
	///
	/// \param[in] pListItem The item for which the info tip text is being set.
	/// \param[in,out] pInfoTipText The info tip text being set. It may be changed by the client application.
	/// \param[in,out] pAbortInfoTip If \c VARIANT_TRUE, the caller should cancel setting the info tip;
	///                otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_SettingItemInfoTipText,
	///       ExLVwLibU::_IExplorerListViewEvents::SettingItemInfoTipText, Raise_ItemGetInfoTipText,
	///       ListViewItem::SetInfoTipText
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_SettingItemInfoTipText,
	///       ExLVwLibA::_IExplorerListViewEvents::SettingItemInfoTipText, Raise_ItemGetInfoTipText,
	///       ListViewItem::SetInfoTipText
	/// \endif
	inline HRESULT Raise_SettingItemInfoTipText(IListViewItem* pListItem, BSTR* pInfoTipText, VARIANT_BOOL* pAbortInfoTip);
	/// \brief <em>Raises the \c StartingLabelEditing event</em>
	///
	/// \param[in] pListItem The item being edited.
	/// \param[in,out] pCancel If \c VARIANT_TRUE, the caller should prevent label-editing; otherwise not.
	///
	/// \return An \c HRESULT error code.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_StartingLabelEditing,
	///       ExLVwLibU::_IExplorerListViewEvents::StartingLabelEditing, Raise_RenamingItem,
	///       Raise_CreatedEditControlWindow
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_StartingLabelEditing,
	///       ExLVwLibA::_IExplorerListViewEvents::StartingLabelEditing, Raise_RenamingItem,
	///       Raise_CreatedEditControlWindow
	/// \endif
	inline HRESULT Raise_StartingLabelEditing(IListViewItem* pListItem, VARIANT_BOOL* pCancel);
	/// \brief <em>Raises the \c SubItemMouseEnter event</em>
	///
	/// \param[in] pListSubItem The sub-item that was entered.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_SubItemMouseEnter,
	///       ExLVwLibU::_IExplorerListViewEvents::SubItemMouseEnter, Raise_SubItemMouseLeave,
	///       Raise_ItemMouseEnter, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_SubItemMouseEnter,
	///       ExLVwLibA::_IExplorerListViewEvents::SubItemMouseEnter, Raise_SubItemMouseLeave,
	///       Raise_ItemMouseEnter, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_SubItemMouseEnter(IListViewSubItem* pListSubItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c SubItemMouseLeave event</em>
	///
	/// \param[in] pListSubItem The sub-item that was left.
	/// \param[in] button The pressed mouse buttons. Any combination of the values defined by VB's
	///            \c MouseButtonConstants enumeration or the \c ExtendedMouseButtonConstants enumeration
	///            is valid.
	/// \param[in] shift The pressed modifier keys (Shift, Ctrl, Alt). Any combination of the values
	///            defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the mouse cursor's position relative to the control's
	///            upper-left corner.
	/// \param[in] hitTestDetails The exact part of the control that the mouse cursor's position lies
	///            in. Most of the values defined by the \c HitTestConstants enumeration are valid.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_SubItemMouseLeave,
	///       ExLVwLibU::_IExplorerListViewEvents::SubItemMouseLeave, Raise_SubItemMouseEnter,
	///       Raise_ItemMouseLeave, Raise_MouseMove, ExLVwLibU::ExtendedMouseButtonConstants,
	///       ExLVwLibU::HitTestConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_SubItemMouseLeave,
	///       ExLVwLibA::_IExplorerListViewEvents::SubItemMouseLeave, Raise_SubItemMouseEnter,
	///       Raise_ItemMouseLeave, Raise_MouseMove, ExLVwLibA::ExtendedMouseButtonConstants,
	///       ExLVwLibA::HitTestConstants
	/// \endif
	inline HRESULT Raise_SubItemMouseLeave(IListViewSubItem* pListSubItem, SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y, HitTestConstants hitTestDetails);
	/// \brief <em>Raises the \c XClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the click. This should always be
	///            a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the click. Any
	///            combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_XClick,
	///       ExLVwLibU::_IExplorerListViewEvents::XClick, Raise_XDblClick, Raise_Click, Raise_MClick,
	///       Raise_RClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_XClick,
	///       ExLVwLibA::_IExplorerListViewEvents::XClick, Raise_XDblClick, Raise_Click, Raise_MClick,
	///       Raise_RClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_XClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	/// \brief <em>Raises the \c XDblClick event</em>
	///
	/// \param[in] button The mouse buttons that were pressed during the double-click. This should
	///            always be a constant defined by the \c ExtendedMouseButtonConstants enumeration.
	/// \param[in] shift The modifier keys (Shift, Ctrl, Alt) that were pressed during the double-click.
	///            Any combination of the values defined by VB's \c ShiftConstants enumeration is valid.
	/// \param[in] x The x-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the double-click's position relative to the control's
	///            upper-left corner.
	///
	/// \return An \c HRESULT error code.
	///
	/// \remarks This event may be disabled.
	///
	/// \if UNICODE
	///   \sa Proxy_IExplorerListViewEvents::Fire_XDblClick,
	///       ExLVwLibU::_IExplorerListViewEvents::XDblClick, Raise_XClick, Raise_DblClick,
	///       Raise_MDblClick, Raise_RDblClick, ExLVwLibU::ExtendedMouseButtonConstants
	/// \else
	///   \sa Proxy_IExplorerListViewEvents::Fire_XDblClick,
	///       ExLVwLibA::_IExplorerListViewEvents::XDblClick, Raise_XClick, Raise_DblClick,
	///       Raise_MDblClick, Raise_RDblClick, ExLVwLibA::ExtendedMouseButtonConstants
	/// \endif
	inline HRESULT Raise_XDblClick(SHORT button, SHORT shift, OLE_XPOS_PIXELS x, OLE_YPOS_PIXELS y);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>Applies the font to the control</em>
	///
	/// This method sets the control's font to the font specified by the \c Font property.
	///
	/// \sa get_Font
	void ApplyFont(void);

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IOleObject
	///
	//@{
	/// \brief <em>Implementation of \c IOleObject::DoVerb</em>
	///
	/// Will be called if one of the control's registered actions (verbs) shall be executed; e. g.
	/// executing the "About" verb will display the About dialog.
	///
	/// \param[in] verbID The requested verb's ID.
	/// \param[in] pMessage A \c MSG structure describing the event (such as a double-click) that
	///            invoked the verb.
	/// \param[in] pActiveSite The \c IOleClientSite implementation of the control's active client site
	///            where the event occurred that invoked the verb.
	/// \param[in] reserved Reserved; must be zero.
	/// \param[in] hWndParent The handle of the document window containing the control.
	/// \param[in] pBoundingRectangle A \c RECT structure containing the coordinates and size in pixels
	///            of the control within the window specified by \c hWndParent.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa EnumVerbs,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms694508.aspx">IOleObject::DoVerb</a>
	virtual HRESULT STDMETHODCALLTYPE DoVerb(LONG verbID, LPMSG pMessage, IOleClientSite* pActiveSite, LONG reserved, HWND hWndParent, LPCRECT pBoundingRectangle);
	/// \brief <em>Implementation of \c IOleObject::EnumVerbs</em>
	///
	/// Will be called if the control's container requests the control's registered actions (verbs); e. g.
	/// we provide a verb "About" that will display the About dialog on execution.
	///
	/// \param[out] ppEnumerator Receives the \c IEnumOLEVERB implementation of the verbs' enumerator.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DoVerb,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms692781.aspx">IOleObject::EnumVerbs</a>
	virtual HRESULT STDMETHODCALLTYPE EnumVerbs(IEnumOLEVERB** ppEnumerator);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Implementation of IOleControl
	///
	//@{
	/// \brief <em>Implementation of \c IOleControl::GetControlInfo</em>
	///
	/// Will be called if the container requests details about the control's keyboard mnemonics and keyboard
	/// behavior.
	///
	/// \param[in, out] pControlInfo The requested details.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/ms693730.aspx">IOleControl::GetControlInfo</a>
	virtual HRESULT STDMETHODCALLTYPE GetControlInfo(LPCONTROLINFO pControlInfo);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>Executes the About verb</em>
	///
	/// Will be called if the control's registered action (verb) "About" shall be executed. We'll
	/// display the About dialog.
	///
	/// \param[in] hWndParent The window to use as parent for any user interface.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa DoVerb, About
	HRESULT DoVerbAbout(HWND hWndParent);

	//////////////////////////////////////////////////////////////////////
	/// \name MFC clones
	///
	//@{
	/// \brief <em>A rewrite of MFC's \c COleControl::RecreateControlWindow</em>
	///
	/// Destroys and re-creates the control window.
	///
	/// \remarks This rewrite probably isn't complete.
	///
	/// \sa <a href="https://msdn.microsoft.com/en-us/library/5tx8h2fd(VS.80).aspx">COleControl::RecreateControlWindow</a>
	void RecreateControlWindow(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name IME support
	///
	//@{
	/// \brief <em>Retrieves a window's current IME context mode</em>
	///
	/// \param[in] hWnd The window whose IME context mode is requested.
	///
	/// \return A constant out of the \c IMEModeConstants enumeration specifying the IME context mode.
	///
	/// \if UNICODE
	///   \sa SetCurrentIMEContextMode, ExLVwLibU::IMEModeConstants, get_IMEMode, get_EditIMEMode
	/// \else
	///   \sa SetCurrentIMEContextMode, ExLVwLibA::IMEModeConstants, get_IMEMode, get_EditIMEMode
	/// \endif
	IMEModeConstants GetCurrentIMEContextMode(HWND hWnd);
	/// \brief <em>Sets a window's current IME context mode</em>
	///
	/// \param[in] hWnd The window whose IME context mode is set.
	/// \param[in] IMEMode A constant out of the \c IMEModeConstants enumeration specifying the IME
	///            context mode to apply.
	///
	/// \if UNICODE
	///   \sa GetCurrentIMEContextMode, ExLVwLibU::IMEModeConstants, put_IMEMode, put_EditIMEMode
	/// \else
	///   \sa GetCurrentIMEContextMode, ExLVwLibA::IMEModeConstants, put_IMEMode, put_EditIMEMode
	/// \endif
	void SetCurrentIMEContextMode(HWND hWnd, IMEModeConstants IMEMode);
	/// \brief <em>Retrieves the control's effective IME context mode</em>
	///
	/// Retrieves the IME context mode that is set for the control after resolving recursive modes like
	/// \c imeInherit.
	///
	/// \return A constant out of the \c IMEModeConstants enumeration specifying the IME context mode.
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::IMEModeConstants, GetEffectiveIMEMode_Edit, get_IMEMode
	/// \else
	///   \sa ExLVwLibA::IMEModeConstants, GetEffectiveIMEMode_Edit, get_IMEMode
	/// \endif
	IMEModeConstants GetEffectiveIMEMode(void);
	/// \brief <em>Retrieves the contained edit control's effective IME context mode</em>
	///
	/// Retrieves the IME context mode that is set for the contained edit control after resolving
	/// recursive modes like \c imeInherit.
	///
	/// \return A constant out of the \c IMEModeConstants enumeration specifying the IME context mode.
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::IMEModeConstants, GetEffectiveIMEMode, get_EditIMEMode
	/// \else
	///   \sa ExLVwLibA::IMEModeConstants, GetEffectiveIMEMode, get_EditIMEMode
	/// \endif
	IMEModeConstants GetEffectiveIMEMode_Edit(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Control window configuration
	///
	//@{
	/// \brief <em>Calculates the extended window style bits</em>
	///
	/// Calculates the extended window style bits that the control must have set to match the current
	/// property settings.
	///
	/// \return A bit field of \c WS_EX_* constants specifying the required extended window styles.
	///
	/// \sa GetStyleBits, SendConfigurationMessages, Create
	DWORD GetExStyleBits(void);
	/// \brief <em>Calculates the window style bits</em>
	///
	/// Calculates the window style bits that the control must have set to match the current property
	/// settings.
	///
	/// \return A bit field of \c WS_* and \c LVS_* constants specifying the required window styles.
	///
	/// \sa GetExStyleBits, SendConfigurationMessages, Create
	DWORD GetStyleBits(void);
	/// \brief <em>Configures the control window by sending messages</em>
	///
	/// Sends \c WM_* and \c LVM_* messages to the control window to make it match the current property
	/// settings. Will be called out of \c Raise_RecreatedControlWindow.
	///
	/// \sa GetExStyleBits, GetStyleBits, Raise_RecreatedControlWindow
	void SendConfigurationMessages(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Value translation
	///
	//@{
	/// \brief <em>Translates a \c MousePointerConstants type mouse cursor into a \c HCURSOR type mouse cursor</em>
	///
	/// \param[in] mousePointer The \c MousePointerConstants type mouse cursor to translate.
	///
	/// \return The translated \c HCURSOR type mouse cursor.
	///
	/// \if UNICODE
	///   \sa ExLVwLibU::MousePointerConstants, OnSetCursor, put_MousePointer, put_HotMousePointer
	/// \else
	///   \sa ExLVwLibA::MousePointerConstants, OnSetCursor, put_MousePointer, put_HotMousePointer
	/// \endif
	HCURSOR MousePointerConst2hCursor(MousePointerConstants mousePointer);
	/// \brief <em>Translates a column's unique ID to its index</em>
	///
	/// \param[in] ID The unique ID of the column whose index is requested.
	///
	/// \return The requested column's index if successful; -1 otherwise.
	///
	/// \sa columnIndexes, ColumnIndexToID, ListViewColumns::get_Item, ListViewColumns::Remove
	int IDToColumnIndex(LONG ID);
	/// \brief <em>Translates a column's index to its unique ID</em>
	///
	/// \param[in] columnIndex The index of the column whose unique ID is requested.
	///
	/// \return The requested column's unique ID if successful; -1 otherwise.
	///
	/// \sa columnIndexes, IDToColumnIndex, ListViewColumn::get_ID
	LONG ColumnIndexToID(int columnIndex);
	/// \brief <em>Translates an item's unique ID to its index</em>
	///
	/// \param[in] ID The unique ID of the item whose index is requested.
	///
	/// \return The requested item's index if successful; -1 otherwise.
	///
	/// \sa itemIDs, ItemIndexToID, ListViewItems::get_Item, ListViewItems::Remove
	int IDToItemIndex(LONG ID);
	/// \brief <em>Translates an item's index to its unique ID</em>
	///
	/// \param[in] itemIndex The index of the item whose unique ID is requested.
	///
	/// \return The requested item's unique ID if successful; -1 otherwise.
	///
	/// \sa itemIDs, IDToItemIndex, ListViewItem::get_ID
	LONG ItemIndexToID(int itemIndex);
	/// \brief <em>Translates a group's unique ID to its position index</em>
	///
	/// \param[in] groupID The unique ID of the group whose position index is requested.
	///
	/// \return The requested group's position index if successful; -1 otherwise.
	///
	/// \sa groups, PositionIndexToGroupID, ListViewGroup::get_Position
	int GroupIDToPositionIndex(int groupID);
	/// \brief <em>Translates a group's position index to its unique ID</em>
	///
	/// \param[in] positionIndex The position index of the group whose unique ID is requested.
	///
	/// \return The requested group's unique ID if successful; -1 otherwise.
	///
	/// \sa groups, GroupIDToPositionIndex, ListViewGroups::get_Item, ListViewGroups::Remove
	int PositionIndexToGroupID(int positionIndex);
	/// \brief <em>Translates a bit field of \c HitTestConstants constants into a bit field of \c LVHT_* constants</em>
	///
	/// \param[in] bitField The \c HitTestConstants bit field to translate.
	///
	/// \return The translated \c LVHT_* bit field.
	///
	/// \remarks The \c LVHT_* constants are not unique, making them somewhat difficult to handle. To
	///          increase our public \c HitTest method's ease of use, we don't simply map the \c LVHT_*
	///          constants to their \c HitTestConstants counterparts like we do in ExplorerTreeView.
	///          Instead the \c HitTestConstants are unique and we do real translation.
	///
	/// \if UNICODE
	///   \sa LVHTFlags2HitTestConstants, ExLVwLibU::HitTestConstants, HitTest
	/// \else
	///   \sa LVHTFlags2HitTestConstants, ExLVwLibA::HitTestConstants, HitTest
	/// \endif
	UINT HitTestConstants2LVHTFlags(HitTestConstants bitField);
	/// \brief <em>Translates a bit field of \c LVHT_* constants into a bit field of \c HitTestConstants constants</em>
	///
	/// \param[in] bitField The \c LVHT_* bit field to translate.
	/// \param[in] itemWasHit If \c TRUE, the method will translate the bit field according to the fact
	///            that an item is hit.
	///
	/// \return The translated \c HitTestConstants bit field.
	///
	/// \remarks The \c LVHT_* constants are not unique, making them somewhat difficult to handle. To
	///          increase our public \c HitTest method's ease of use, we don't simply map the \c LVHT_*
	///          constants to their \c HitTestConstants counterparts like we do in ExplorerTreeView.
	///          Instead the \c HitTestConstants are unique and we do real translation.
	///
	/// \if UNICODE
	///   \sa HitTestConstants2LVHTFlags, ExLVwLibU::HitTestConstants, HitTest
	/// \else
	///   \sa HitTestConstants2LVHTFlags, ExLVwLibA::HitTestConstants, HitTest
	/// \endif
	HitTestConstants LVHTFlags2HitTestConstants(UINT bitField, BOOL itemWasHit);
	//@}
	//////////////////////////////////////////////////////////////////////

	/// \brief <em>Replaces a group ID within the \c groups vector with another group ID</em>
	///
	/// \param[in] oldGroupID The group ID to replace.
	/// \param[in] newGroupID The group ID to replace with.
	///
	/// \sa groups, OnSetGroupInfo, GroupIDToPositionIndex, PositionIndexToGroupID
	void ReplaceGroupID(int oldGroupID, int newGroupID);

	/// \brief <em>Hit-tests the specified point</em>
	///
	/// Retrieves the column that lies below the point ('x'; 'y').
	///
	/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the header
	///            control's upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the header
	///            control's upper-left corner.
	/// \param[out] pFlags A bit field of HHT_* flags, that holds further details about the header control's
	///             part below the specified point.
	///
	/// \return The "hit" column's index.
	///
	/// \remarks Scrolling the control moves the header control, so that a point's listview coordinates
	///          (i. e. relative to the control's upper-left corner) don't necessarily equal the same
	///          point's header coordinates (i. e. relative to the header control's upper-left corner).
	///
	/// \sa HeaderHitTest
	int HeaderHitTest(LONG x, LONG y, UINT* pFlags);
	/// \brief <em>Hit-tests the specified point</em>
	///
	/// Retrieves the item that lies below the point ('x'; 'y').
	///
	/// \param[in] x The x-coordinate (in pixels) of the point to check. It must be relative to the control's
	///            upper-left corner.
	/// \param[in] y The y-coordinate (in pixels) of the point to check. It must be relative to the control's
	///            upper-left corner.
	/// \param[out] pFlags A bit field of \c LVHT_* and \c LVHT_EX_* flags, that holds further details about
	///             the control's part below the specified point.
	/// \param[in,out] pHitItem Receives the "hit" item's index. May be \c NULL.
	/// \param[in,out] pHitSubItem Receives the "hit" sub-item's index. If set to \c NULL, only the item will
	///                be hit-tested.
	/// \param[in] ignoreBoundingBoxDefinition If \c TRUE, the setting of the \c ItemBoundingBoxDefinition
	///            property is ignored; otherwise the returned item index is set to -1, if the
	///            \c ItemBoundingBoxDefinition property's setting and the \c pFlags parameter don't match.
	/// \param[in] wantExtendedFlags If \c TRUE, the method retrieves the normal \c LVHT_* flags as well as
	///            the \c LVHT_EX_* flags; otherwise only the \c LVHT_* flags are retrieved.
	/// \param[in] wantItemIndex If \c TRUE, the method ensures that the returned item and sub-item indexes
	///            refer to an item and a sub-item; otherwise the meaning of those indexes may be different.
	///            E. g. the returned index will be a group id, if the flags contain \c LVHT_EX_GROUP, and a
	///            footer item index, if the flags contain \c LVHT_EX_FOOTER.
	///
	/// \sa HitTest, get_ItemBoundingBoxDefinition, HitTestConstants2LVHTFlags, LVHTFlags2HitTestConstants
	void HitTest(LONG x, LONG y, UINT* pFlags, LVITEMINDEX* pHitItem, PINT pHitSubItem, BOOL ignoreBoundingBoxDefinition = FALSE, BOOL wantExtendedFlags = TRUE, BOOL wantItemIndex = TRUE);
	/// \brief <em>Retrieves whether we're in design mode or in user mode</em>
	///
	/// \return \c TRUE if the control is in design mode (i. e. is placed on a window which is edited
	///         by a form editor); \c FALSE if the control is in user mode (i. e. is placed on a window
	///         being used by an end-user).
	BOOL IsInDesignMode(void);
	/// \brief <em>Auto-scrolls the control</em>
	///
	/// \sa OnTimer, Raise_DragMouseMove, Raise_HeaderDragMouseMove, DragDropStatus::AutoScrolling
	void AutoScroll(void);

	/// \brief <em>Retrieves whether the specified view mode is active</em>
	///
	/// \param[in] view The view mode to check for. Any of the values defined by the \c ViewConstants
	///            enumeration is valid.
	/// \param[in] detectExtendedTiles If \c TRUE, the method checks for 'Extended Tiles' view mode
	///            explicitly; otherwise 'Extended Tiles' and 'Tiles' view modes are treated as being equal.
	///
	/// \return \c TRUE if the control is in the specified view mode; otherwise \c FALSE.
	BOOL IsInViewMode(ViewConstants view, BOOL detectExtendedTiles = TRUE);
	/// \brief <em>Retrieves whether the logical left mouse button is held down</em>
	///
	/// \return \c TRUE if the logical left mouse button is held down; otherwise \c FALSE.
	///
	/// \sa IsRightMouseButtonDown
	BOOL IsLeftMouseButtonDown(void);
	/// \brief <em>Retrieves whether the logical right mouse button is held down</em>
	///
	/// \return \c TRUE if the logical right mouse button is held down; otherwise \c FALSE.
	///
	/// \sa IsLeftMouseButtonDown
	BOOL IsRightMouseButtonDown(void);


	/// \brief <em>Holds constants and flags used with IME support</em>
	struct IMEFlags
	{
	protected:
		/// \brief <em>A table of IME modes to use for Chinese input language</em>
		///
		/// \sa GetIMECountryTable, japaneseIMETable, koreanIMETable
		static IMEModeConstants chineseIMETable[10];
		/// \brief <em>A table of IME modes to use for Japanese input language</em>
		///
		/// \sa GetIMECountryTable, chineseIMETable, koreanIMETable
		static IMEModeConstants japaneseIMETable[10];
		/// \brief <em>A table of IME modes to use for Korean input language</em>
		///
		/// \sa GetIMECountryTable, chineseIMETable, koreanIMETable
		static IMEModeConstants koreanIMETable[10];

	public:
		/// \brief <em>The handle of the default IME context</em>
		HIMC hDefaultIMC;

		IMEFlags()
		{
			hDefaultIMC = NULL;
		}

		/// \brief <em>Retrieves a table of IME modes to use for the current keyboard layout</em>
		///
		/// Retrieves a table of IME modes which can be used to map \c IME_CMODE_* constants to
		/// \c IMEModeConstants constants. The table depends on the current keyboard layout.
		///
		/// \param[in,out] table The IME mode table for the currently active keyboard layout.
		///
		/// \if UNICODE
		///   \sa ExLVwLibU::IMEModeConstants, GetEffectiveIMEMode, get_EditIMEMode
		/// \else
		///   \sa ExLVwLibA::IMEModeConstants, GetEffectiveIMEMode, get_EditIMEMode
		/// \endif
		static void GetIMECountryTable(IMEModeConstants table[10])
		{
			WORD languageID = LOWORD(GetKeyboardLayout(0));
			if(languageID <= MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
				if(languageID == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)) {
					CopyMemory(table, chineseIMETable, sizeof(chineseIMETable));
					return;
				}
				switch(languageID) {
					case MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT):
						CopyMemory(table, japaneseIMETable, sizeof(japaneseIMETable));
						return;
						break;
					case MAKELANGID(LANG_KOREAN, SUBLANG_DEFAULT):
						CopyMemory(table, koreanIMETable, sizeof(koreanIMETable));
						return;
						break;
				}
				if(languageID == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)) {
					CopyMemory(table, chineseIMETable, sizeof(chineseIMETable));
					return;
				}
				table[0] = static_cast<IMEModeConstants>(-10);
				return;
			}

			if(languageID <= MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_HONGKONG)) {
				if(languageID == MAKELANGID(LANG_KOREAN, SUBLANG_SYS_DEFAULT)) {
					CopyMemory(table, koreanIMETable, sizeof(koreanIMETable));
					return;
				}
				if(languageID == MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_HONGKONG)) {
					CopyMemory(table, chineseIMETable, sizeof(chineseIMETable));
					return;
				}
				table[0] = static_cast<IMEModeConstants>(-10);
				return;
			}

			if((languageID != MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE)) && (languageID != MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_MACAU))) {
				table[0] = static_cast<IMEModeConstants>(-10);
				return;
			}

			CopyMemory(table, chineseIMETable, sizeof(chineseIMETable));
		}
	} IMEFlags;

	/// \brief <em>Holds a control instance's properties' settings</em>
	typedef struct Properties
	{
		/// \brief <em>Holds a font property's settings</em>
		typedef struct FontProperty
		{
		protected:
			/// \brief <em>Holds the control's default font</em>
			///
			/// \sa GetDefaultFont
			static FONTDESC defaultFont;

		public:
			/// \brief <em>Holds whether we're listening for events fired by the font object</em>
			///
			/// If greater than 0, we're advised to the \c IFontDisp object identified by \c pFontDisp. I. e.
			/// we will be notified if a property of the font object changes. If 0, we won't receive any events
			/// fired by the \c IFontDisp object.
			///
			/// \sa pFontDisp, pPropertyNotifySink
			int watching;
			/// \brief <em>Flag telling \c OnSetFont not to retrieve the current font if set to \c TRUE</em>
			///
			/// \sa OnSetFont
			UINT dontGetFontObject : 1;
			/// \brief <em>The control's current font</em>
			///
			/// \sa OnSetFont, ApplyFont, owningFontResource
			CFont currentFont;
			/// \brief <em>If \c TRUE, \c currentFont may destroy the font resource; otherwise not</em>
			///
			/// \sa currentFont
			UINT owningFontResource : 1;
			/// \brief <em>A pointer to the font object's implementation of \c IFontDisp</em>
			IFontDisp* pFontDisp;
			/// \brief <em>Receives notifications on changes to this property object's settings</em>
			///
			/// \sa InitializePropertyWatcher, PropertyNotifySinkImpl
			CComObject< PropertyNotifySinkImpl<ExplorerListView> >* pPropertyNotifySink;

			FontProperty()
			{
				watching = 0;
				dontGetFontObject = FALSE;
				owningFontResource = TRUE;
				pFontDisp = NULL;
				pPropertyNotifySink = NULL;
			}

			~FontProperty()
			{
				Release();
			}

			FontProperty& operator =(const FontProperty& source)
			{
				Release();

				InitializePropertyWatcher(source.pPropertyNotifySink->properties.pObjectToNotify, source.pPropertyNotifySink->properties.propertyToWatch);
				pFontDisp = source.pFontDisp;
				if(pFontDisp) {
					pFontDisp->AddRef();
				}
				owningFontResource = source.owningFontResource;
				if(!owningFontResource) {
					currentFont.Attach(source.currentFont.m_hFont);
				}
				dontGetFontObject = source.dontGetFontObject;

				if(source.watching > 0) {
					StartWatching();
				}

				return *this;
			}

			/// \brief <em>Retrieves a default font that may be used</em>
			///
			/// \return A \c FONTDESC structure containing the default font.
			///
			/// \sa defaultFont
			static FONTDESC GetDefaultFont(void)
			{
				return defaultFont;
			}

			/// \brief <em>Initializes an object that will watch this property for changes</em>
			///
			/// \param[in] pObjectToNotify The object to notify on changes.
			/// \param[in] propertyToWatch The property to watch for changes.
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StartWatching, StopWatching
			HRESULT InitializePropertyWatcher(ExplorerListView* pObjectToNotify, DISPID propertyToWatch)
			{
				CComObject< PropertyNotifySinkImpl<ExplorerListView> >::CreateInstance(&pPropertyNotifySink);
				ATLASSUME(pPropertyNotifySink);
				pPropertyNotifySink->AddRef();
				return pPropertyNotifySink->Initialize(pObjectToNotify, propertyToWatch);
			}

			/// \brief <em>Prepares the object for destruction</em>
			void Release(void)
			{
				if(pPropertyNotifySink) {
					StopWatching();
					pPropertyNotifySink->Release();
					pPropertyNotifySink = NULL;
				}
				ATLASSERT(watching == 0);
				if(owningFontResource) {
					if(!currentFont.IsNull()) {
						currentFont.DeleteObject();
					}
				} else {
					currentFont.Detach();
				}
				if(pFontDisp) {
					pFontDisp->Release();
					pFontDisp = NULL;
				}
			}

			/// \brief <em>Starts watching the property object for changes</em>
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StopWatching, InitializePropertyWatcher
			HRESULT StartWatching(void)
			{
				if(pFontDisp) {
					ATLASSUME(pPropertyNotifySink);
					HRESULT hr = pPropertyNotifySink->StartWatching(pFontDisp);
					ATLASSERT(SUCCEEDED(hr));
					if(SUCCEEDED(hr)) {
						++watching;
					}
					return hr;
				}
				return E_FAIL;
			}

			/// \brief <em>Stops watching the property object for changes</em>
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StartWatching, InitializePropertyWatcher
			HRESULT StopWatching(void)
			{
				if(watching > 0) {
					ATLASSUME(pPropertyNotifySink);
					HRESULT hr = pPropertyNotifySink->StopWatching(pFontDisp);
					ATLASSERT(SUCCEEDED(hr));
					if(SUCCEEDED(hr)) {
						--watching;
					}
					return hr;
				}
				return E_FAIL;
			}
		} FontProperty;

		/// \brief <em>Holds a picture property's settings</em>
		typedef struct PictureProperty
		{
			/// \brief <em>Holds whether we're listening for events fired by the picture object</em>
			///
			/// If greater than 0, we're advised to the \c IPictureDisp object identified by \c pPictureDisp.
			/// I. e. we will be notified if a property of the picture object changes. If 0, we won't receive any
			/// events fired by the \c IPictureDisp object.
			///
			/// \sa pPictureDisp, pPropertyNotifySink
			int watching;
			/// \brief <em>Flag telling \c OnSetHotCursor not to retrieve the current hot cursor if set to \c TRUE</em>
			///
			/// \sa OnSetHotCursor
			UINT dontGetPictureObject : 1;
			/// \brief <em>A pointer to the picture object's implementation of \c IPictureDisp</em>
			IPictureDisp* pPictureDisp;
			/// \brief <em>Receives notifications on changes to this property object's settings</em>
			///
			/// \sa InitializePropertyWatcher, PropertyNotifySinkImpl
			CComObject< PropertyNotifySinkImpl<ExplorerListView> >* pPropertyNotifySink;

			PictureProperty()
			{
				watching = 0;
				dontGetPictureObject = FALSE;
				pPictureDisp = NULL;
				pPropertyNotifySink = NULL;
			}

			~PictureProperty()
			{
				Release();
			}

			PictureProperty& operator =(const PictureProperty& source)
			{
				Release();

				pPictureDisp = source.pPictureDisp;
				if(pPictureDisp) {
					pPictureDisp->AddRef();
				}
				InitializePropertyWatcher(source.pPropertyNotifySink->properties.pObjectToNotify, source.pPropertyNotifySink->properties.propertyToWatch);
				if(source.watching > 0) {
					StartWatching();
				}
				return *this;
			}

			/// \brief <em>Initializes an object that will watch this property for changes</em>
			///
			/// \param[in] pObjectToNotify The object to notify on changes.
			/// \param[in] propertyToWatch The property to watch for changes.
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StartWatching, StopWatching
			HRESULT InitializePropertyWatcher(ExplorerListView* pObjectToNotify, DISPID propertyToWatch)
			{
				CComObject< PropertyNotifySinkImpl<ExplorerListView> >::CreateInstance(&pPropertyNotifySink);
				ATLASSUME(pPropertyNotifySink);
				pPropertyNotifySink->AddRef();
				return pPropertyNotifySink->Initialize(pObjectToNotify, propertyToWatch);
			}

			/// \brief <em>Prepares the object for destruction</em>
			void Release(void)
			{
				if(pPropertyNotifySink) {
					StopWatching();
					pPropertyNotifySink->Release();
					pPropertyNotifySink = NULL;
				}
				ATLASSERT(watching == 0);
				if(pPictureDisp) {
					pPictureDisp->Release();
					pPictureDisp = NULL;
				}
			}

			/// \brief <em>Starts watching the property object for changes</em>
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StopWatching, InitializePropertyWatcher
			HRESULT StartWatching(void)
			{
				if(pPictureDisp) {
					ATLASSUME(pPropertyNotifySink);
					HRESULT hr = pPropertyNotifySink->StartWatching(pPictureDisp);
					ATLASSERT(SUCCEEDED(hr));
					if(SUCCEEDED(hr)) {
						++watching;
					}
					return hr;
				}
				return E_FAIL;
			}

			/// \brief <em>Stops watching the property object for changes</em>
			///
			/// \return An \c HRESULT error code.
			///
			/// \sa StartWatching, InitializePropertyWatcher
			HRESULT StopWatching(void)
			{
				if(watching > 0) {
					ATLASSUME(pPropertyNotifySink);
					HRESULT hr = pPropertyNotifySink->StopWatching(pPictureDisp);
					ATLASSERT(SUCCEEDED(hr));
					if(SUCCEEDED(hr)) {
						--watching;
					}
					return hr;
				}
				return E_FAIL;
			}
		} PictureProperty;

		/// \brief <em>The autoscroll-zone's default width</em>
		///
		/// The default width (in pixels) of the border around the control's client area, that's
		/// sensitive for auto-scrolling during a drag'n'drop operation. If the mouse cursor's position
		/// lies within this area during a drag'n'drop operation, the control will be auto-scrolled.
		///
		/// \sa dragScrollTimeBase, Raise_DragMouseMove, Raise_HeaderDragMouseMove
		static const int DRAGSCROLLZONEWIDTH = 16;

		/// \brief <em>Holds the \c AbsoluteBkImagePosition property's setting</em>
		///
		/// \sa get_AbsoluteBkImagePosition, put_AbsoluteBkImagePosition
		UINT absoluteBkImagePosition : 1;
		/// \brief <em>Holds the \c AllowHeaderDragDrop property's setting</em>
		///
		/// \sa get_AllowHeaderDragDrop, put_AllowHeaderDragDrop
		UINT allowHeaderDragDrop : 1;
		/// \brief <em>Holds the \c AllowLabelEditing property's setting</em>
		///
		/// \sa get_AllowLabelEditing, put_AllowLabelEditing
		UINT allowLabelEditing : 1;
		/// \brief <em>Holds the \c AlwaysShowSelection property's setting</em>
		///
		/// \sa get_AlwaysShowSelection, put_AlwaysShowSelection
		UINT alwaysShowSelection : 1;
		/// \brief <em>Holds the \c Appearance property's setting</em>
		///
		/// \sa get_Appearance, put_Appearance
		AppearanceConstants appearance;
		/// \brief <em>Holds the \c AutoArrangeItems property's setting</em>
		///
		/// \sa get_AutoArrangeItems, put_AutoArrangeItems
		AutoArrangeItemsConstants autoArrangeItems;
		/// \brief <em>Holds the \c AutoSizeColumns property's setting</em>
		///
		/// \sa get_AutoSizeColumns, put_AutoSizeColumns
		UINT autoSizeColumns : 1;
		/// \brief <em>Holds the \c BackColor property's setting</em>
		///
		/// \sa get_BackColor, put_BackColor
		OLE_COLOR backColor;
		/// \brief <em>Holds the \c BackgroundDrawMode property's setting</em>
		///
		/// \sa get_BackgroundDrawMode, put_BackgroundDrawMode
		BackgroundDrawModeConstants backgroundDrawMode;
		/// \brief <em>Holds the \c BkImage property's setting</em>
		///
		/// \sa get_BkImage, put_BkImage
		VARIANT bkImage;
		/// \brief <em>If \c TRUE, we own the background bitmap and may destroy it</em>
		UINT ownsBkImageBitmap : 1;
		/// \brief <em>Holds the \c BkImagePositionX property's setting</em>
		///
		/// \sa get_BkImagePositionX, put_BkImagePositionX
		LONG bkImagePositionX;
		/// \brief <em>Holds the \c BkImagePositionY property's setting</em>
		///
		/// \sa get_BkImagePositionY, put_BkImagePositionY
		LONG bkImagePositionY;
		/// \brief <em>Holds the \c BkImageStyle property's setting</em>
		///
		/// \sa get_BkImageStyle, put_BkImageStyle
		BkImageStyleConstants bkImageStyle;
		/// \brief <em>Holds the \c BlendSelectionLasso property's setting</em>
		///
		/// \sa get_BlendSelectionLasso, put_BlendSelectionLasso
		UINT blendSelectionLasso : 1;
		/// \brief <em>Holds the \c BorderSelect property's setting</em>
		///
		/// \sa get_BorderSelect, put_BorderSelect
		UINT borderSelect : 1;
		/// \brief <em>Holds the \c BorderStyle property's setting</em>
		///
		/// \sa get_BorderStyle, put_BorderStyle
		BorderStyleConstants borderStyle;
		/// \brief <em>Holds the \c CallBackMask property's setting</em>
		///
		/// \sa get_CallBackMask, put_CallBackMask
		CallBackMaskConstants callBackMask;
		/// \brief <em>Holds the \c CheckItemOnSelect property's setting</em>
		///
		/// \sa get_CheckItemOnSelect, put_CheckItemOnSelect
		UINT checkItemOnSelect : 1;
		/// \brief <em>Holds the \c ClickableColumnHeaders property's setting</em>
		///
		/// \sa get_ClickableColumnHeaders, put_ClickableColumnHeaders
		UINT clickableColumnHeaders : 1;
		/// \brief <em>Holds the \c ColumnHeaderVisibility property's setting</em>
		///
		/// \sa get_ColumnHeaderVisibility, put_ColumnHeaderVisibility
		ColumnHeaderVisibilityConstants columnHeaderVisibility;
		/// \brief <em>Holds the \c DisabledEvents property's setting</em>
		///
		/// \sa get_DisabledEvents, put_DisabledEvents
		DisabledEventsConstants disabledEvents;
		/// \brief <em>Holds the \c DontRedraw property's setting</em>
		///
		/// \sa get_DontRedraw, put_DontRedraw
		UINT dontRedraw : 1;
		/// \brief <em>Holds the \c DragScrollTimeBase property's setting</em>
		///
		/// \sa get_DragScrollTimeBase, put_DragScrollTimeBase
		long dragScrollTimeBase;
		/// \brief <em>Holds the \c DrawImagesAsynchronously property's setting</em>
		///
		/// \sa get_DrawImagesAsynchronously, put_DrawImagesAsynchronously
		UINT drawImagesAsynchronously : 1;
		/// \brief <em>Holds the \c EditBackColor property's setting</em>
		///
		/// \sa get_EditBackColor, put_EditBackColor
		OLE_COLOR editBackColor;
		/// \brief <em>Holds the \c EditForeColor property's setting</em>
		///
		/// \sa get_EditForeColor, put_EditForeColor
		OLE_COLOR editForeColor;
		/// \brief <em>Holds the \c EditHoverTime property's setting</em>
		///
		/// \sa get_EditHoverTime, put_EditHoverTime
		long editHoverTime;
		/// \brief <em>Holds the \c EditIMEMode property's setting</em>
		///
		/// \sa get_EditIMEMode, put_EditIMEMode
		IMEModeConstants editIMEMode;
		/// \brief <em>Holds the \c EmptyMarkupText property's setting</em>
		///
		/// \sa get_EmptyMarkupText, put_EmptyMarkupText
		LPWSTR pEmptyMarkupText;
		/// \brief <em>Holds the \c EmptyMarkupTextAlignment property's setting</em>
		///
		/// \sa get_EmptyMarkupTextAlignment, put_EmptyMarkupTextAlignment
		AlignmentConstants emptyMarkupTextAlignment;
		/// \brief <em>Holds the \c Enabled property's setting</em>
		///
		/// \sa get_Enabled, put_Enabled
		UINT enabled : 1;
		/// \brief <em>Holds the \c FilterChangedTimeout property's setting</em>
		///
		/// \sa get_FilterChangedTimeout, put_FilterChangedTimeout
		long filterChangedTimeout;
		/// \brief <em>Holds the \c Font property's settings</em>
		///
		/// \sa get_Font, put_Font, putref_Font
		FontProperty font;
		/// \brief <em>Holds the \c FooterIntroText property's setting</em>
		///
		/// \sa get_FooterIntroText, put_FooterIntroText
		CComBSTR footerIntroText;
		/// \brief <em>Holds the \c ForeColor property's setting</em>
		///
		/// \sa get_ForeColor, put_ForeColor
		OLE_COLOR foreColor;
		/// \brief <em>Holds the \c FullRowSelect property's setting</em>
		///
		/// \sa get_FullRowSelect, put_FullRowSelect
		FullRowSelectConstants fullRowSelect;
		/// \brief <em>Holds the \c GridLines property's setting</em>
		///
		/// \sa get_GridLines, put_GridLines
		UINT gridLines : 1;
		/// \brief <em>Holds the \c GroupFooterForeColor property's setting</em>
		///
		/// \sa get_GroupFooterForeColor, put_GroupFooterForeColor
		OLE_COLOR groupFooterForeColor;
		/// \brief <em>Holds the \c GroupHeaderForeColor property's setting</em>
		///
		/// \sa get_GroupHeaderForeColor, put_GroupHeaderForeColor
		OLE_COLOR groupHeaderForeColor;
		/// \brief <em>Holds the \c GroupLocale property's setting</em>
		///
		/// \sa get_GroupLocale, put_GroupLocale
		LCID groupLocale;
		/// \brief <em>Holds the \c GroupMarginBottom property's setting</em>
		///
		/// \sa get_GroupMarginBottom, put_GroupMarginBottom
		OLE_YSIZE_PIXELS groupMarginBottom;
		/// \brief <em>Holds the \c GroupMarginLeft property's setting</em>
		///
		/// \sa get_GroupMarginLeft, put_GroupMarginLeft
		OLE_XSIZE_PIXELS groupMarginLeft;
		/// \brief <em>Holds the \c GroupMarginRight property's setting</em>
		///
		/// \sa get_GroupMarginRight, put_GroupMarginRight
		OLE_XSIZE_PIXELS groupMarginRight;
		/// \brief <em>Holds the \c GroupMarginTop property's setting</em>
		///
		/// \sa get_GroupMarginTop, put_GroupMarginTop
		OLE_YSIZE_PIXELS groupMarginTop;
		/// \brief <em>Holds the \c GroupSortOrder property's setting</em>
		///
		/// \sa get_GroupSortOrder, put_GroupSortOrder
		SortOrderConstants groupSortOrder;
		/// \brief <em>Holds the \c GroupTextParsingFlags property's setting</em>
		///
		/// \sa get_GroupTextParsingFlags, put_GroupTextParsingFlags
		DWORD groupTextParsingFlagsForCompareString;
		/// \brief <em>Holds the \c GroupTextParsingFlags property's setting</em>
		///
		/// \sa get_GroupTextParsingFlags, put_GroupTextParsingFlags
		ULONG groupTextParsingFlagsForVarFromStr;
		/// \brief <em>Holds the \c HeaderFullDragging property's setting</em>
		///
		/// \sa get_HeaderFullDragging, put_HeaderFullDragging
		UINT headerFullDragging : 1;
		/// \brief <em>Holds the \c HeaderHotTracking property's setting</em>
		///
		/// \sa get_HeaderHotTracking, put_HeaderHotTracking
		UINT headerHotTracking : 1;
		/// \brief <em>Holds the \c HeaderHoverTime property's setting</em>
		///
		/// \sa get_HeaderHoverTime, put_HeaderHoverTime
		long headerHoverTime;
		/// \brief <em>Holds the \c HeaderOLEDragImageStyle property's setting</em>
		///
		/// \sa get_HeaderOLEDragImageStyle, put_HeaderOLEDragImageStyle
		OLEDragImageStyleConstants headerOLEDragImageStyle;
		/// \brief <em>Holds the \c HideLabels property's setting</em>
		///
		/// \sa get_HideLabels, put_HideLabels
		UINT hideLabels : 1;
		/// \brief <em>Holds the \c HotForeColor property's setting</em>
		///
		/// \sa get_HotForeColor, put_HotForeColor
		OLE_COLOR hotForeColor;
		/// \brief <em>Holds the \c HotMouseIcon property's settings</em>
		///
		/// \sa get_HotMouseIcon, put_HotMouseIcon, putref_HotMouseIcon
		PictureProperty hotMouseIcon;
		/// \brief <em>Holds the \c HotMousePointer property's setting</em>
		///
		/// \sa get_HotMousePointer, put_HotMousePointer
		MousePointerConstants hotMousePointer;
		/// \brief <em>Holds the \c HotTracking property's setting</em>
		///
		/// \sa get_HotTracking, put_HotTracking
		UINT hotTracking : 1;
		/// \brief <em>Holds the \c HotTrackingHoverTime property's setting</em>
		///
		/// \sa get_HotTrackingHoverTime, put_HotTrackingHoverTime
		long hotTrackingHoverTime;
		/// \brief <em>Holds the \c HoverTime property's setting</em>
		///
		/// \sa get_HoverTime, put_HoverTime
		long hoverTime;
		/// \brief <em>Holds the \c IMEMode property's setting</em>
		///
		/// \sa get_IMEMode, put_IMEMode
		IMEModeConstants IMEMode;
		/// \brief <em>Holds the \c IncludeHeaderInTabOrder property's setting</em>
		///
		/// \sa get_IncludeHeaderInTabOrder, put_IncludeHeaderInTabOrder
		UINT includeHeaderInTabOrder : 1;
		/// \brief <em>Holds the \c InsertMarkColor property's setting</em>
		///
		/// \sa get_InsertMarkColor, put_InsertMarkColor
		OLE_COLOR insertMarkColor;
		/// \brief <em>Holds the \c ItemActivationMode property's setting</em>
		///
		/// \sa get_ItemActivationMode, put_ItemActivationMode
		ItemActivationModeConstants itemActivationMode;
		/// \brief <em>Holds the \c ItemAlignment property's setting</em>
		///
		/// \sa get_ItemAlignment, put_ItemAlignment
		ItemAlignmentConstants itemAlignment;
		/// \brief <em>Holds the \c ItemBoundingBoxDefinition property's setting</em>
		///
		/// \sa get_ItemBoundingBoxDefinition, put_ItemBoundingBoxDefinition
		ItemBoundingBoxDefinitionConstants itemBoundingBoxDefinition;
		/// \brief <em>Holds the \c ItemHeight property's setting</em>
		///
		/// \sa get_ItemHeight, put_ItemHeight
		OLE_YSIZE_PIXELS itemHeight;
		/// \brief <em>Holds the \c JustifyIconColumns property's setting</em>
		///
		/// \sa get_JustifyIconColumns, put_JustifyIconColumns
		UINT justifyIconColumns : 1;
		/// \brief <em>Holds the \c LabelWrap property's setting</em>
		///
		/// \sa get_LabelWrap, put_LabelWrap
		UINT labelWrap : 1;
		/// \brief <em>Holds the \c MinItemRowsVisibleInGroups property's setting</em>
		///
		/// \sa get_MinItemRowsVisibleInGroups, put_MinItemRowsVisibleInGroups
		long minItemRowsVisibleInGroups;
		/// \brief <em>Holds the \c MouseIcon property's settings</em>
		///
		/// \sa get_MouseIcon, put_MouseIcon, putref_MouseIcon
		PictureProperty mouseIcon;
		/// \brief <em>Holds the \c MousePointer property's setting</em>
		///
		/// \sa get_MousePointer, put_MousePointer
		MousePointerConstants mousePointer;
		/// \brief <em>Holds the \c MultiSelect property's setting</em>
		///
		/// \sa get_MultiSelect, put_MultiSelect
		UINT multiSelect : 1;
		/// \brief <em>Holds the \c OLEDragImageStyle property's setting</em>
		///
		/// \sa get_OLEDragImageStyle, put_OLEDragImageStyle
		OLEDragImageStyleConstants oleDragImageStyle;
		/// \brief <em>Holds the \c OutlineColor property's setting</em>
		///
		/// \sa get_OutlineColor, put_OutlineColor
		OLE_COLOR outlineColor;
		/// \brief <em>Holds the \c OwnerDrawn property's setting</em>
		///
		/// \sa get_OwnerDrawn, put_OwnerDrawn
		UINT ownerDrawn : 1;
		/// \brief <em>Holds the \c ProcessContextMenuKeys property's setting</em>
		///
		/// \sa get_ProcessContextMenuKeys, put_ProcessContextMenuKeys
		UINT processContextMenuKeys : 1;
		/// \brief <em>Holds the \c Regional property's setting</em>
		///
		/// \sa get_Regional, put_Regional
		UINT regional : 1;
		/// \brief <em>Holds the \c RegisterForOLEDragDrop property's setting</em>
		///
		/// \sa get_RegisterForOLEDragDrop, put_RegisterForOLEDragDrop
		UINT registerForOLEDragDrop : 1;
		/// \brief <em>Holds the \c ResizableColumns property's setting</em>
		///
		/// \sa get_ResizableColumns, put_ResizableColumns
		UINT resizableColumns : 1;
		/// \brief <em>Holds the \c RightToLeft property's setting</em>
		///
		/// \sa get_RightToLeft, put_RightToLeft
		RightToLeftConstants rightToLeft;
		/// \brief <em>Holds the \c ScrollBars property's setting</em>
		///
		/// \sa get_ScrollBars, put_ScrollBars
		ScrollBarsConstants scrollBars;
		/// \brief <em>Holds the \c SelectedColumnBackColor property's setting</em>
		///
		/// \sa get_SelectedColumnBackColor, put_SelectedColumnBackColor
		OLE_COLOR selectedColumnBackColor;
		/// \brief <em>Holds the system default color for the \c SelectedColumnBackColor property</em>
		///
		/// \sa selectedColumnBackColor
		OLE_COLOR defaultSelectedColumnBackColor;
		/// \brief <em>Holds the \c ShowFilterBar property's setting</em>
		///
		/// \sa get_ShowFilterBar, put_ShowFilterBar
		UINT showFilterBar : 1;
		/// \brief <em>Holds the \c ShowGroups property's setting</em>
		///
		/// \sa get_ShowGroups, put_ShowGroups
		UINT showGroups : 1;
		/// \brief <em>Holds the \c ShowHeaderChevron property's setting</em>
		///
		/// \sa get_ShowHeaderChevron, put_ShowHeaderChevron
		UINT showHeaderChevron : 1;
		/// \brief <em>Holds the \c ShowHeaderStateImages property's setting</em>
		///
		/// \sa get_ShowHeaderStateImages, put_ShowHeaderStateImages
		UINT showHeaderStateImages : 1;
		/// \brief <em>Holds the \c ShowStateImages property's setting</em>
		///
		/// \sa get_ShowStateImages, put_ShowStateImages
		UINT showStateImages : 1;
		/// \brief <em>Holds the \c ShowSubItemImages property's setting</em>
		///
		/// \sa get_ShowSubItemImages, put_ShowSubItemImages
		UINT showSubItemImages : 1;
		/// \brief <em>Holds the \c SimpleSelect property's setting</em>
		///
		/// \sa get_SimpleSelect, put_SimpleSelect
		UINT simpleSelect : 1;
		/// \brief <em>Holds the \c SingleRow property's setting</em>
		///
		/// \sa get_SingleRow, put_SingleRow
		UINT singleRow : 1;
		/// \brief <em>Holds the \c SnapToGrid property's setting</em>
		///
		/// \sa get_SnapToGrid, put_SnapToGrid
		UINT snapToGrid : 1;
		/// \brief <em>Holds the \c SortOrder property's setting</em>
		///
		/// \sa get_SortOrder, put_SortOrder
		SortOrderConstants sortOrder;
		/// \brief <em>Holds the \c SupportOLEDragImages property's setting</em>
		///
		/// \sa get_SupportOLEDragImages, put_SupportOLEDragImages
		UINT supportOLEDragImages : 1;
		/// \brief <em>Holds the \c TextBackColor property's setting</em>
		///
		/// \sa get_TextBackColor, put_TextBackColor
		OLE_COLOR textBackColor;
		/// \brief <em>Holds the \c TileViewItemLines property's setting</em>
		///
		/// \sa get_TileViewItemLines, put_TileViewItemLines
		long tileViewItemLines;
		/// \brief <em>Holds the \c TileViewLabelMarginBottom property's setting</em>
		///
		/// \sa get_TileViewLabelMarginBottom, put_TileViewLabelMarginBottom
		OLE_YSIZE_PIXELS tileViewLabelMarginBottom;
		/// \brief <em>Holds the \c TileViewLabelMarginLeft property's setting</em>
		///
		/// \sa get_TileViewLabelMarginLeft, put_TileViewLabelMarginLeft
		OLE_XSIZE_PIXELS tileViewLabelMarginLeft;
		/// \brief <em>Holds the \c TileViewLabelMarginRight property's setting</em>
		///
		/// \sa get_TileViewLabelMarginRight, put_TileViewLabelMarginRight
		OLE_XSIZE_PIXELS tileViewLabelMarginRight;
		/// \brief <em>Holds the \c TileViewLabelMarginTop property's setting</em>
		///
		/// \sa get_TileViewLabelMarginTop, put_TileViewLabelMarginTop
		OLE_YSIZE_PIXELS tileViewLabelMarginTop;
		/// \brief <em>Holds the \c TileViewSubItemForeColor property's setting</em>
		///
		/// \sa get_TileViewSubItemForeColor, put_TileViewSubItemForeColor
		OLE_COLOR tileViewSubItemForeColor;
		/// \brief <em>Holds the system default color for the \c TileViewSubItemForeColor property</em>
		///
		/// \sa tileViewSubItemForeColor
		OLE_COLOR defaultTileViewSubItemForeColor;
		/// \brief <em>Holds the \c TileViewTileHeight property's setting</em>
		///
		/// \sa get_TileViewTileHeight, put_TileViewTileHeight
		OLE_YSIZE_PIXELS tileViewTileHeight;
		/// \brief <em>Holds the \c TileViewTileWidth property's setting</em>
		///
		/// \sa get_TileViewTileWidth, put_TileViewTileWidth
		OLE_XSIZE_PIXELS tileViewTileWidth;
		/// \brief <em>Holds the \c ToolTips property's setting</em>
		///
		/// \sa get_ToolTips, put_ToolTips
		ToolTipsConstants toolTips;
		/// \brief <em>Holds the \c UnderlinedItems property's setting</em>
		///
		/// \sa get_UnderlinedItems, put_UnderlinedItems
		UnderlinedItemsConstants underlinedItems;
		/// \brief <em>Holds the \c UseMinColumnWidths property's setting</em>
		///
		/// \sa get_UseMinColumnWidths, put_UseMinColumnWidths
		UINT useMinColumnWidths : 1;
		/// \brief <em>Holds the \c UseSystemFont property's setting</em>
		///
		/// \sa get_UseSystemFont, put_UseSystemFont
		UINT useSystemFont : 1;
		/// \brief <em>Holds the \c UseWorkAreas property's setting</em>
		///
		/// \sa get_UseWorkAreas, put_UseWorkAreas
		UINT useWorkAreas : 1;
		/// \brief <em>Holds the \c View property's setting</em>
		///
		/// \sa get_View, put_View
		ViewConstants view;
		/// \brief <em>Holds the \c VirtualItemCount property's setting</em>
		///
		/// \sa get_VirtualItemCount, put_VirtualItemCount
		long virtualItemCount;
		/// \brief <em>Holds the \c VirtualMode property's setting</em>
		///
		/// \sa get_VirtualMode, put_VirtualMode
		UINT virtualMode : 1;

		Properties()
		{
			pEmptyMarkupText = NULL;
			ResetToDefaults();
		}

		~Properties()
		{
			Release();
		}

		/// \brief <em>Prepares the object for destruction</em>
		void Release(void)
		{
			SECUREFREE(pEmptyMarkupText);
			font.Release();
			hotMouseIcon.Release();
			mouseIcon.Release();
		}

		/// \brief <em>Resets all properties to their defaults</em>
		void ResetToDefaults(void)
		{
			SECUREFREE(pEmptyMarkupText);

			absoluteBkImagePosition = FALSE;
			allowHeaderDragDrop = TRUE;
			allowLabelEditing = TRUE;
			alwaysShowSelection = TRUE;
			appearance = a3D;
			autoArrangeItems = aaiNone;
			autoSizeColumns = FALSE;
			backColor = 0x80000000 | COLOR_WINDOW;
			backgroundDrawMode = bdmNormal;
			VariantInit(&bkImage);
			ownsBkImageBitmap = FALSE;
			bkImagePositionX = 0;
			bkImagePositionY = 0;
			bkImageStyle = bisWatermark;
			blendSelectionLasso = TRUE;
			borderSelect = FALSE;
			borderStyle = bsNone;
			callBackMask = static_cast<CallBackMaskConstants>(0);
			checkItemOnSelect = FALSE;
			clickableColumnHeaders = TRUE;
			columnHeaderVisibility = chvVisibleInDetailsView;
			disabledEvents = static_cast<DisabledEventsConstants>(deListMouseEvents | deListClickEvents | deEditMouseEvents | deHeaderMouseEvents | deHeaderClickEvents | deListKeyboardEvents | deHeaderKeyboardEvents | deEditKeyboardEvents | deColumnInsertionEvents | deColumnDeletionEvents | deFreeColumnData | deGroupInsertionEvents | deGroupDeletionEvents | deItemInsertionEvents | deItemDeletionEvents | deFreeItemData | deCustomDraw | deHeaderCustomDraw | deHotItemChangeEvents | deFreeFooterItemData | deGetSubItemControl);
			dontRedraw = FALSE;
			dragScrollTimeBase = -1;
			drawImagesAsynchronously = FALSE;
			editBackColor = 0x80000000 | COLOR_WINDOW;
			editForeColor = 0x80000000 | COLOR_WINDOWTEXT;
			editHoverTime = -1;
			editIMEMode = imeInherit;
			pEmptyMarkupText = NULL;
			emptyMarkupTextAlignment = alCenter;
			enabled = TRUE;
			filterChangedTimeout = -1;
			footerIntroText = L"";
			foreColor = 0x80000000 | COLOR_WINDOWTEXT;
			fullRowSelect = frsExtendedMode;
			gridLines = FALSE;
			groupFooterForeColor = 0x80000000 | COLOR_WINDOWTEXT;
			groupHeaderForeColor = 0x80000000 | COLOR_WINDOWTEXT;
			groupLocale = static_cast<LCID>(-1);
			groupMarginBottom = 0;
			groupMarginLeft = 0;
			groupMarginRight = 0;
			groupMarginTop = 12;
			groupSortOrder = soAscending;
			groupTextParsingFlagsForCompareString = 0;
			groupTextParsingFlagsForVarFromStr = 0;
			headerFullDragging = TRUE;
			headerHotTracking = FALSE;
			headerHoverTime = -1;
			headerOLEDragImageStyle = odistClassic;
			hideLabels = FALSE;
			hotForeColor = static_cast<OLE_COLOR>(-1);
			hotMousePointer = mpDefault;
			hotTracking = FALSE;
			hotTrackingHoverTime = -1;
			hoverTime = -1;
			IMEMode = imeInherit;
			includeHeaderInTabOrder = FALSE;
			insertMarkColor = RGB(0, 0, 0);
			itemActivationMode = iamOneDoubleClick;
			itemAlignment = iaTop;
			itemBoundingBoxDefinition = static_cast<ItemBoundingBoxDefinitionConstants>(ibbdItemIcon | ibbdItemLabel | ibbdItemStateImage);
			itemHeight = 17;
			justifyIconColumns = FALSE;
			labelWrap = TRUE;
			minItemRowsVisibleInGroups = 0;
			mousePointer = mpDefault;
			multiSelect = TRUE;
			oleDragImageStyle = odistClassic;
			outlineColor = 0x80000000 | COLOR_BTNFACE;
			ownerDrawn = FALSE;
			processContextMenuKeys = TRUE;
			regional = FALSE;
			registerForOLEDragDrop = FALSE;
			resizableColumns = TRUE;
			rightToLeft = static_cast<RightToLeftConstants>(0);
			scrollBars = sbNormal;
			selectedColumnBackColor = static_cast<OLE_COLOR>(-1);
			showFilterBar = FALSE;
			showGroups = FALSE;
			showHeaderChevron = FALSE;
			showHeaderStateImages = FALSE;
			showStateImages = FALSE;
			showSubItemImages = FALSE;
			simpleSelect = FALSE;
			singleRow = FALSE;
			snapToGrid = FALSE;
			sortOrder = soAscending;
			supportOLEDragImages = TRUE;
			textBackColor = CLR_NONE;
			tileViewItemLines = 1;
			tileViewLabelMarginBottom = 0;
			tileViewLabelMarginLeft = 0;
			tileViewLabelMarginRight = 0;
			tileViewLabelMarginTop = 0;
			tileViewSubItemForeColor = static_cast<OLE_COLOR>(-1);
			tileViewTileHeight = -1;
			tileViewTileWidth = -1;
			toolTips = static_cast<ToolTipsConstants>(ttLabelTipsAlways | ttInfoTips);
			underlinedItems = static_cast<UnderlinedItemsConstants>(0);
			useMinColumnWidths = FALSE;
			useSystemFont = TRUE;
			useWorkAreas = FALSE;
			view = vIcons;
			virtualItemCount = 0;
			virtualMode = FALSE;
		}
	} Properties;
	/// \brief <em>Holds the control's properties' settings</em>
	Properties properties;

	/// \brief <em>Holds some frequently used settings</em>
	///
	/// Holds some settings that otherwise would be requested from the control window very often.
	/// The cached settings are updated whenever the corresponding control window's settings change.
	struct CachedSettings
	{
		/// \brief <em>Holds the \c ilExtraLarge imagelist</em>
		///
		/// \sa hLargeImageList, hSmallImageList, get_hImageList, put_hImageList, OnSetImageList
		HIMAGELIST hExtraLargeImageList;
		/// \brief <em>Holds the \c ilHighResolution imagelist</em>
		///
		/// \sa get_hImageList, put_hImageList
		HIMAGELIST hHighResImageList;
		/// \brief <em>Holds the \c ilHeaderHighResolution imagelist</em>
		///
		/// \sa get_hImageList, put_hImageList
		HIMAGELIST hHighResHeaderImageList;
		/// \brief <em>Holds the \c ilLarge imagelist</em>
		///
		/// \sa hExtraLargeImageList, hSmallImageList, get_hImageList, put_hImageList, OnSetImageList
		HIMAGELIST hLargeImageList;
		/// \brief <em>Holds the \c ilSmall imagelist</em>
		///
		/// \sa hExtraLargeImageList, hLargeImageList, get_hImageList, put_hImageList, OnSetImageList
		HIMAGELIST hSmallImageList;
		/// \brief <em>Holds the \c ilState imagelist</em>
		///
		/// \sa hHeaderStateImageList, get_hImageList, put_hImageList, OnSetImageList
		HIMAGELIST hStateImageList;
		/// \brief <em>Holds the \c ilGroups imagelist</em>
		///
		/// \sa hExtraLargeImageList, hLargeImageList, hSmallImageList, hFooterItemsImageList, get_hImageList,
		///     put_hImageList, OnSetImageList
		HIMAGELIST hGroupsImageList;
		/// \brief <em>Holds the \c ilFooterItems imagelist</em>
		///
		/// \sa hExtraLargeImageList, hLargeImageList, hSmallImageList, hGroupsImageList, get_hImageList,
		///     put_hImageList, OnSetImageList
		HIMAGELIST hFooterItemsImageList;
		/// \brief <em>Holds the \c ilHeaderState imagelist</em>
		///
		/// \sa hStateImageList, get_hImageList, put_hImageList, OnHeaderSetImageList
		HIMAGELIST hHeaderStateImageList;
		/// \brief <em>Holds the \c HotTracking property's setting</em>
		///
		/// \sa get_HotTracking, put_HotTracking, OnSetExtendedListViewStyle
		UINT hotTracking : 1;
		/// \brief <em>Holds the \c HotItem property's setting</em>
		///
		/// \sa get_HotItem, putref_HotItem, OnSetHotItem, OnHotTrackNotification
		LVITEMINDEX hotItem;
		/// \brief <em>Temporarily holds the \c HotItem property's setting</em>
		///
		/// \sa get_HotItem, putref_HotItem, OnSetHotItem, OnHotTrackNotification
		LVITEMINDEX hotItemTmp;

		CachedSettings()
		{
			hHighResImageList = NULL;
			hHighResHeaderImageList = NULL;
			hExtraLargeImageList = NULL;
			hLargeImageList = NULL;
			hSmallImageList = NULL;
			hStateImageList = NULL;
			hGroupsImageList = NULL;
			hFooterItemsImageList = NULL;
			hHeaderStateImageList = NULL;
			hotTracking = FALSE;
			hotItem.iItem = -1;
			hotItem.iGroup = 0;
			hotItemTmp = hotItem;
		}

		/// \brief <em>Fills the caches with the settings of the specified control window</em>
		///
		/// \param[in] hWndLvw The listview window whose settings will be cached.
		/// \param[in] hWndHeader The listview window's contained header window.
		void CacheSettings(HWND hWndLvw, HWND hWndHeader)
		{
			hHighResImageList = NULL;
			hHighResHeaderImageList = NULL;
			BOOL isInTilesView = FALSE;
			//if(RunTimeHelper::IsCommCtrl6()) {
				if(::SendMessage(hWndLvw, LVM_GETVIEW, 0, 0) == LV_VIEW_TILE) {
					isInTilesView = TRUE;
				}
			//}

			if(isInTilesView) {
				hExtraLargeImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_NORMAL, 0));
				hLargeImageList = NULL;
			} else {
				hExtraLargeImageList = NULL;
				hLargeImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_NORMAL, 0));
			}
			hSmallImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_SMALL, 0));
			hStateImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_STATE, 0));
			hGroupsImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_GROUPHEADER, 0));
			hFooterItemsImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndLvw, LVM_GETIMAGELIST, LVSIL_FOOTERITEMS, 0));
			hotTracking = ((::SendMessage(hWndLvw, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0) & LVS_EX_TRACKSELECT) == LVS_EX_TRACKSELECT);

			CComPtr<IListView_WIN7> pListView7 = NULL;
			CComPtr<IListView_WINVISTA> pListViewVista = NULL;
			if(::SendMessage(hWndLvw, LVM_QUERYINTERFACE, reinterpret_cast<WPARAM>(&IID_IListView_WIN7), reinterpret_cast<LPARAM>(&pListView7)) && pListView7) {
				ATLASSUME(pListView7);
				ATLVERIFY(SUCCEEDED(pListView7->GetHotItem(&hotItem)));
			} else if(::SendMessage(hWndLvw, LVM_QUERYINTERFACE, reinterpret_cast<WPARAM>(&IID_IListView_WINVISTA), reinterpret_cast<LPARAM>(&pListViewVista)) && pListViewVista) {
				ATLASSUME(pListViewVista);
				ATLVERIFY(SUCCEEDED(pListViewVista->GetHotItem(&hotItem)));
			} else {
				hotItem.iItem = static_cast<int>(::SendMessage(hWndLvw, LVM_GETHOTITEM, 0, 0));
			}

			hHeaderStateImageList = reinterpret_cast<HIMAGELIST>(::SendMessage(hWndHeader, HDM_GETIMAGELIST, HDSIL_STATE, 0));
		}
	} cachedSettings;

	/// \brief <em>Holds the control's flags</em>
	struct Flags
	{
		/// \brief <em>Holds the last \c LVBKIMAGE::hbm value that was passed to \c OnListSetBkImage</em>
		///
		/// \sa OnSetBkImage
		HBITMAP hCurrentBackgroundBitmap;
		/// \brief <em>If \c TRUE, we raised the \c HeaderDblClick event</em>
		///
		/// \sa Raise_HeaderDblClick, OnHeaderLButtonDblClk
		UINT raisedHeaderDblClick : 1;
		/// \brief <em>If \c TRUE, we'll ignore the control's next \c NM_RCLICK notification</em>
		///
		/// \sa OnHeaderRButtonUp, OnContextMenu, OnRClickNotification
		UINT ignoreRClickNotification : 1;
		/// \brief <em>If \c TRUE, we've received a \c WM_RBUTTONUP message and are free to raise the \c ContextMenu event</em>
		///
		/// If the user clicks on a state image using the right mouse button, we receive two reflected
		/// \c WM_CONTEXTMENU messages for some unknown reason. The first one after the \c NM_RCLICK
		/// notification, the second one after the \c WM_RBUTTONUP message. The message after \c NM_RCLICK is
		/// the one that is wrong.\n
		/// To not raise the \c ContextMenu event twice, we're verifying that we've received \c WM_RBUTTONUP
		/// before raising the event.
		///
		/// \sa OnHeaderRButtonUp, OnContextMenu, Raise_ContextMenu
		UINT receivedRButtonUp : 1;
		/// \brief <em>If \c TRUE, we will avoid the info tip being displayed</em>
		///
		/// \sa OnGetInfoTipNotification, OnToolTipGetDispInfoNotificationW
		UINT cancelToolTip : 1;
		/// \brief <em>Holds the unique ID of the item currently being deleted</em>
		///
		/// \sa OnDeleteItem, OnDeleteItemNotification
		LONG itemIDBeingRemoved;
		/// \brief <em>If \c TRUE, we're using themes</em>
		///
		/// \sa OnThemeChanged
		UINT usingThemes : 1;

		Flags()
		{
			hCurrentBackgroundBitmap = NULL;
			raisedHeaderDblClick = FALSE;
			ignoreRClickNotification = FALSE;
			receivedRButtonUp = FALSE;
			cancelToolTip = FALSE;
			itemIDBeingRemoved = -1;
			usingThemes = FALSE;
		}
	} flags;

	/// \brief <em>Holds the settings of the current sorting process</em>
	///
	/// \sa SortItems, CompareItems
	struct SortingSettings
	{
		/// \brief <em>If \c TRUE, text comparisons should be case sensitive</em>
		UINT caseSensitive : 1;
		/// \brief <em>The five sorting criteria to use</em>
		///
		/// Holds the five sorting criteria to use. If the items are equivalent regarding the first one,
		/// the second will be used. If the result is equivalence again, the third one is used and so on.
		SortByConstants sortingCriteria[5];
		/// \brief <em>The column by which to sort if sorting by (sub-)item text</em>
		int column;
		/// \brief <em>The locale identifier to use when comparing strings</em>
		///
		/// If set to -1, the current thread's locale identifier is used.
		LCID localeID;
		/// \brief <em>Holds the flags to specify when calling conversion routines, e.g. for converting strings to date time values</em>
		ULONG flagsForVarFromStr;
		/// \brief <em>Holds the flags to specify when calling \c CompareString</em>
		///
		/// \sa <a href="https://msdn.microsoft.com/en-us/library/dd317759.aspx">CompareString</a>
		DWORD flagsForCompareString;

		SortingSettings()
		{
			caseSensitive = FALSE;
			sortingCriteria[0] = sobShell;
			sortingCriteria[1] = sobText;
			sortingCriteria[2] = sobNone;
			sortingCriteria[3] = sobNone;
			sortingCriteria[4] = sobNone;
			column = -1;
			localeID = static_cast<LCID>(-1);
			flagsForVarFromStr = 0;
			flagsForCompareString = 0;
		}
	} sortingSettings;

	//////////////////////////////////////////////////////////////////////
	/// \name Item management
	///
	//@{
	/// \brief <em>Holds additional item data</em>
	typedef struct ItemData
	{
		/// \brief <em>Specifies an user-defined integer value associated with the item</em>
		LPARAM lParam;
	} ItemData;
	#ifdef USE_STL
		/// \brief <em>A list of all item IDs</em>
		///
		/// Holds the unique IDs of all list view items in the control. The item's index in the control equals
		/// its index in the vector.
		///
		/// \sa OnInsertItem, OnDeleteAllItems, OnDeleteItemNotification, OnGetItem, OnSetItem,
		///     ListViewItem::get_ID
		std::vector<LONG> itemIDs;
		/// \brief <em>A list of all items</em>
		///
		/// Holds additional data for each listview item in the control.
		///
		/// \remarks This list is used only with version 5.x of comctl32.dll.
		///
		/// \sa OnInsertItem, OnDeleteAllItems, OnDeleteItemNotification, OnGetItem, OnSetItem,
		///     ListViewItem::get_ID
		std::list<ItemData> itemParams;
	#else
		/// \brief <em>A list of all items</em>
		///
		/// Holds the unique IDs of all list box items in the control. The item's index in the control equals
		/// its index in the vector.
		///
		/// \sa OnInsertItem, OnDeleteAllItems, OnDeleteItemNotification, OnGetItem, OnSetItem,
		///     ListViewItem::get_ID
		CAtlArray<LONG> itemIDs;
		/// \brief <em>A list of all items</em>
		///
		/// Holds additional data for each listview item in the control.
		///
		/// \remarks This list is used only with version 5.x of comctl32.dll.
		///
		/// \sa OnInsertItem, OnDeleteAllItems, OnDeleteItemNotification, OnGetItem, OnSetItem,
		///     ListViewItem::get_ID
		CAtlList<ItemData> itemParams;
	#endif
	/// \brief <em>Retrieves a new unique item ID at each call</em>
	///
	/// \return A new unique item ID.
	///
	/// \sa itemIDs, ListViewItem::get_ID
	LONG GetNewItemID(void);
	#ifdef USE_STL
		/// \brief <em>A map of all \c ListViewItemContainer objects that we've created</em>
		///
		/// Holds pointers to all \c ListViewItemContainer objects that we've created. We use this map to
		/// inform the containers of item deletions. The container's ID is stored as key; the container's
		/// \c IItemContainer implementation is stored as value.
		///
		/// \sa CreateItemContainer, RegisterItemContainer, ListViewItemContainer
		std::unordered_map<DWORD, IItemContainer*> itemContainers;
	#else
		/// \brief <em>A map of all \c ListViewItemContainer objects that we've created</em>
		///
		/// Holds pointers to all \c ListViewItemContainer objects that we've created. We use this map to
		/// inform the containers of item deletions. The container's ID is stored as key; the container's
		/// \c IItemContainer implementation is stored as value.
		///
		/// \sa CreateItemContainer, RegisterItemContainer, ListViewItemContainer
		CAtlMap<DWORD, IItemContainer*> itemContainers;
	#endif
	/// \brief <em>Registers the specified \c ListViewItemContainer collection</em>
	///
	/// Registers the specified \c ListViewItemContainer collection so that it is informed of item deletions.
	///
	/// \param[in] pContainer The container's \c IItemContainer implementation.
	///
	/// \sa DeregisterItemContainer, itemContainers, RemoveItemFromItemContainers
	void RegisterItemContainer(IItemContainer* pContainer);
	/// \brief <em>De-registers the specified \c ListViewItemContainer collection</em>
	///
	/// De-registers the specified \c ListViewItemContainer collection so that it no longer is informed of
	/// item deletions.
	///
	/// \param[in] containerID The container's ID.
	///
	/// \sa RegisterItemContainer, itemContainers
	void DeregisterItemContainer(DWORD containerID);
	/// \brief <em>Removes the specified item from all registered \c ListViewItemContainer collections</em>
	///
	/// \param[in] itemIdentifier <strong>Non-virtual mode:</strong> The unique ID of the item to remove.
	///            <strong>Virtual mode:</strong> The zero-based index of the item to remove. If -1, all
	///            items are removed.
	///
	/// \sa itemContainers, RegisterItemContainer, OnDeleteItem, OnDeleteItemNotification,
	///     OnDeleteAllItems, OnDeleteAllItemsNotification, Raise_DestroyedControlWindow
	void RemoveItemFromItemContainers(LONG itemIdentifier);
	///@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Column management
	///
	//@{
	/// \brief <em>Holds additional column data</em>
	typedef struct ColumnData
	{
		/// \brief <em>Specifies an user-defined integer value associated with the column</em>
		LPARAM lParam;
		/// \brief <em>The locale identifier to use when comparing strings</em>
		///
		/// If set to -1, the current thread's locale identifier is used.
		LCID localeID;
		/// \brief <em>Holds the flags to specify when calling conversion routines, e.g. for converting strings to date time values</em>
		ULONG flagsForVarFromStr;
		/// \brief <em>Holds the flags to specify when calling \c CompareString</em>
		///
		/// \sa <a href="https://msdn.microsoft.com/en-us/library/dd317759.aspx">CompareString</a>
		DWORD flagsForCompareString;
	} ColumnData;
	#ifdef USE_STL
		/// \brief <em>A map of all columns</em>
		///
		/// Holds the indexes of all listview columns in the control. The column's ID is stored as key, the
		/// column's index is stored as value.
		///
		/// \sa OnHeaderInsertItem, OnDeleteColumn, OnHeaderGetItem, OnHeaderSetItem, ListViewColumn::get_ID
		std::unordered_map< LONG, int, ItemIndexHasher<LONG> > columnIndexes;
		/// \brief <em>A list of all columns</em>
		///
		/// Holds additional data for each listview item in the control.
		///
		/// \sa OnHeaderInsertItem, OnDeleteColumn, OnHeaderGetItem, OnHeaderSetItem, ListViewColumn::get_ID
		std::list<ColumnData> columnParams;
	#else
		/// \brief <em>A map of all columns</em>
		///
		/// Holds the indexes of all listview columns in the control. The column's ID is stored as key, the
		/// column's index is stored as value.
		///
		/// \sa OnHeaderInsertItem, OnDeleteColumn, OnHeaderGetItem, OnHeaderSetItem, ListViewColumn::get_ID
		CAtlMap<LONG, int> columnIndexes;
		/// \brief <em>A list of all columns</em>
		///
		/// Holds additional data for each listview item in the control.
		///
		/// \sa OnHeaderInsertItem, OnDeleteColumn, OnHeaderGetItem, OnHeaderSetItem, ListViewColumn::get_ID
		CAtlList<ColumnData> columnParams;
	#endif
	/// \brief <em>Retrieves a new unique column ID at each call</em>
	///
	/// \return A new unique column ID.
	///
	/// \sa columnIndexes, ListViewColumn::get_ID
	LONG GetNewColumnID(void);
	/// \brief <em>Retrieves the locale identifier to use when sorting by the specified column</em>
	///
	/// When sorting by item text, it might be necessary to know with which locale identifier the text has
	/// been created. For instance, if the item text actually is a date value and the items shall be sorted
	/// by date and not alphabetically, the control needs to know whether the date string is in e.g. British
	/// or German format.\n
	/// This method retrieves the locale identifier that has been associated with the specified column.
	///
	/// \param[in] columnIndex The zero-based index of the column for which to retrieve the locale
	///            identifier.
	///
	/// \return The locale identifier on success or -1 on failure.
	///
	/// \sa SetColumnLocale, ListViewColumn::get_Locale
	LCID GetColumnLocale(int columnIndex);
	/// \brief <em>Sets the locale identifier to use when sorting by the specified column</em>
	///
	/// When sorting by item text, it might be necessary to know with which locale identifier the text has
	/// been created. For instance, if the item text actually is a date value and the items shall be sorted
	/// by date and not alphabetically, the control needs to know whether the date string is in e.g. British
	/// or German format.\n
	/// This method associates the specified locale identifier with the specified column.
	///
	/// \param[in] columnIndex The zero-based index of the column for which to set the locale identifier.
	/// \param[in] localeID The locale identifier to set.
	///
	/// \sa GetColumnLocale, ListViewColumn::put_Locale
	void SetColumnLocale(int columnIndex, LCID localeID);
	/// \brief <em>Retrieves the text parsing options to apply when sorting by the specified column</em>
	///
	/// When sorting by item text, it might be necessary to parse the strings into numerical or date-time
	/// values or to pass them to the \c CompareString function. \c CompareString and the conversion
	/// functions accept various flags with which the comparison or conversion can be customized.
	/// This method retrieves these flags for the specified function type and column.
	///
	/// \param[in] columnIndex The zero-based index of the column for which to retrieve the flags.
	/// \param[in] parsingFunction The parsing function for which to retrieve the flags. Any of the values
	///            defined by the \c TextParsingFunctionConstants enumeration is valid.
	///
	/// \return The locale identifier on success or -1 on failure.
	///
	/// \if UNICODE
	///   \sa SetColumnTextParsingFlags, ListViewColumn::get_TextParsingFlag,
	///       ExLVwLibU::TextParsingFunctionConstants
	/// \else
	///   \sa SetColumnTextParsingFlags, ListViewColumn::get_TextParsingFlag,
	///       ExLVwLibA::TextParsingFunctionConstants
	/// \endif
	DWORD GetColumnTextParsingFlags(int columnIndex, TextParsingFunctionConstants parsingFunction);
	/// \brief <em>Sets the text parsing options to apply when sorting by the specified column</em>
	///
	/// When sorting by item text, it might be necessary to parse the strings into numerical or date-time
	/// values or to pass them to the \c CompareString function. \c CompareString and the conversion
	/// functions accept various flags with which the comparison or conversion can be customized.
	/// This method sets these flags for the specified function type and column.
	///
	/// \param[in] columnIndex The zero-based index of the column for which to set the flags.
	/// \param[in] parsingFunction The parsing function for which to set the flags. Any of the values
	///            defined by the \c TextParsingFunctionConstants enumeration is valid.
	/// \param[in] options The flags to set.
	///
	/// \if UNICODE
	///   \sa GetColumnTextParsingFlags, ListViewColumn::put_TextParsingFlags,
	///       ExLVwLibU::TextParsingFunctionConstants
	/// \else
	///   \sa GetColumnTextParsingFlags, ListViewColumn::put_TextParsingFlags,
	///       ExLVwLibA::TextParsingFunctionConstants
	/// \endif
	void SetColumnTextParsingFlags(int columnIndex, TextParsingFunctionConstants parsingFunction, DWORD options);
	///@}
	//////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////
	/// \name Group management
	///
	//@{
	/// \brief <em>Holds the last group ID returned by \c GetUniqueGroupID</em>
	///
	/// \sa GetUniqueGroupID
	int nextGroupID;
	#ifdef USE_STL
		/// \brief <em>A vector of all groups</em>
		///
		/// Holds the IDs of all listview groups in the control. The position of the group's ID within this
		/// vector is the same as the group's position within the control.
		///
		/// \sa OnInsertGroup, OnInsertGroupSorted, OnRemoveGroup, OnSetGroupInfo, ListViewGroup::get_Position
		std::vector<int> groups;
	#else
		/// \brief <em>A vector of all groups</em>
		///
		/// Holds the IDs of all listview groups in the control. The position of the group's ID within this
		/// vector is the same as the group's position within the control.
		///
		/// \sa OnInsertGroup, OnInsertGroupSorted, OnRemoveGroup, OnSetGroupInfo, ListViewGroup::get_Position
		CAtlArray<int> groups;
	#endif
	/// \brief <em>Retrieves an unique group ID</em>
	///
	/// \return An unique group ID.
	///
	/// \sa nextGroupID, groups, ListViewGroup::get_ID
	int GetUniqueGroupID(void);
	///@}
	//////////////////////////////////////////////////////////////////////


	/// \brief <em>Holds the index of the item below the mouse cursor</em>
	///
	/// \attention This member is not reliable with \c deListMouseEvents being set.
	LVITEMINDEX itemUnderMouse;
	/// \brief <em>Holds the index of the sub-item below the mouse cursor</em>
	///
	/// \attention This member is not reliable with \c deListMouseEvents being set.
	int subItemUnderMouse;
	/// \brief <em>Holds the index of the column below the mouse cursor</em>
	///
	/// \attention This member is not reliable with \c deHeaderMouseEvents being set.
	int columnUnderMouse;

	/// \brief <em>Holds mouse status variables</em>
	typedef struct MouseStatus
	{
	protected:
		/// \brief <em>Holds all mouse buttons that may cause a click event in the immediate future</em>
		///
		/// A bit field of \c SHORT values representing those mouse buttons that are currently pressed and
		/// may cause a click event in the immediate future.
		///
		/// \sa StoreClickCandidate, IsClickCandidate, RemoveClickCandidate, Raise_HeaderClick,
		///     Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick
		SHORT clickCandidates;

	public:
		/// \brief <em>If \c TRUE, the \c MouseEnter event was already raised</em>
		///
		/// \attention This member is not reliable with \c deEditMouseEvents being set.
		///
		/// \sa Raise_MouseEnter, Raise_EditMouseEnter
		UINT enteredControl : 1;
		/// \brief <em>If \c TRUE, the \c MouseHover event was already raised</em>
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		///
		/// \sa Raise_MouseHover, Raise_EditMouseHover
		UINT hoveredControl : 1;
		/// \brief <em>Holds the mouse cursor's last position</em>
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		POINT lastPosition;
		/// \brief <em>Holds the index of the last clicked item</em>
		///
		/// Holds the index of the last clicked item. We use this to ensure that the \c *DblClick events
		/// are not raised accidently.
		///
		/// \attention This member is not reliable with \c deListClickEvents being set.
		///
		/// \sa Raise_HeaderClick, Raise_HeaderDblClick, Raise_HeaderMClick, Raise_HeaderMDblClick,
		///     Raise_HeaderRClick, Raise_HeaderRDblClick, Raise_HeaderXClick, Raise_HeaderXDblClick
		int lastClickedItem;
		/// \brief <em>Holds the index of the item over which the mouse was pressed</em>
		///
		/// Holds the index of the item over which the mouse was pressed. We use this to ensure that the
		/// \c Header*Click events are not raised accidently.
		///
		/// \attention This member is not reliable with \c deHeaderMouseEvents being set.
		///
		/// \sa Raise_HeaderClick, Raise_HeaderMClick, Raise_HeaderRClick, Raise_HeaderXClick,
		///     Raise_HeaderMouseDown, Raise_HeaderMouseUp
		int mouseDownItem;

		MouseStatus()
		{
			clickCandidates = 0;
			enteredControl = FALSE;
			hoveredControl = FALSE;
			lastClickedItem = -1;
			mouseDownItem = -1;
		}

		/// \brief <em>Changes flags to indicate the \c MouseEnter event was just raised</em>
		///
		/// \sa enteredControl, HoverControl, LeaveControl
		void EnterControl(void)
		{
			RemoveAllClickCandidates();
			enteredControl = TRUE;
			lastClickedItem = -1;
			mouseDownItem = -1;
		}

		/// \brief <em>Changes flags to indicate the \c MouseHover event was just raised</em>
		///
		/// \sa enteredControl, hoveredControl, EnterControl, LeaveControl
		void HoverControl(void)
		{
			enteredControl = TRUE;
			hoveredControl = TRUE;
		}

		/// \brief <em>Changes flags to indicate the \c MouseLeave event was just raised</em>
		///
		/// \sa enteredControl, hoveredControl, EnterControl
		void LeaveControl(void)
		{
			enteredControl = FALSE;
			hoveredControl = FALSE;
			lastClickedItem = -1;
		}

		/// \brief <em>Stores a mouse button as click candidate</em>
		///
		/// param[in] button The mouse button to store.
		///
		/// \sa clickCandidates, IsClickCandidate, RemoveClickCandidate
		void StoreClickCandidate(SHORT button)
		{
			// avoid combined click events
			if(clickCandidates == 0) {
				clickCandidates |= button;
			}
		}

		/// \brief <em>Retrieves whether a mouse button is a click candidate</em>
		///
		/// \param[in] button The mouse button to check.
		///
		/// \return \c TRUE if the button is stored as a click candidate; otherwise \c FALSE.
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		///
		/// \sa clickCandidates, StoreClickCandidate, RemoveClickCandidate
		BOOL IsClickCandidate(SHORT button)
		{
			return (clickCandidates & button);
		}

		/// \brief <em>Removes a mouse button from the list of click candidates</em>
		///
		/// \param[in] button The mouse button to remove.
		///
		/// \sa clickCandidates, RemoveAllClickCandidates, StoreClickCandidate, IsClickCandidate
		void RemoveClickCandidate(SHORT button)
		{
			clickCandidates &= ~button;
		}

		/// \brief <em>Clears the list of click candidates</em>
		///
		/// \sa clickCandidates, RemoveClickCandidate, StoreClickCandidate, IsClickCandidate
		void RemoveAllClickCandidates(void)
		{
			clickCandidates = 0;
		}
	} MouseStatus;

	/// \brief <em>Holds mouse status variables</em>
	typedef struct MouseStatusEx
	{
	protected:
		/// \brief <em>Holds all mouse buttons that may cause a click event in the immediate future</em>
		///
		/// A bit field of \c SHORT values representing those mouse buttons that are currently pressed and
		/// may cause a click event in the immediate future.
		///
		/// \sa StoreClickCandidate, IsClickCandidate, RemoveClickCandidate, Raise_Click, Raise_MClick,
		///     Raise_RClick, Raise_XClick
		SHORT clickCandidates;

	public:
		/// \brief <em>If \c TRUE, the \c MouseEnter event was already raised</em>
		///
		/// \attention This member is not reliable with \c deEditMouseEvents being set.
		///
		/// \sa Raise_MouseEnter, Raise_EditMouseEnter
		UINT enteredControl : 1;
		/// \brief <em>If \c TRUE, the \c MouseHover event was already raised</em>
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		///
		/// \sa Raise_MouseHover, Raise_EditMouseHover
		UINT hoveredControl : 1;
		/// \brief <em>Holds the mouse cursor's last position</em>
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		POINT lastPosition;
		/// \brief <em>Holds the index of the last clicked item</em>
		///
		/// Holds the index of the last clicked item. We use this to ensure that the \c *DblClick events
		/// are not raised accidently.
		///
		/// \attention This member is not reliable with \c deListClickEvents being set.
		///
		/// \sa Raise_Click, Raise_DblClick, Raise_MClick, Raise_MDblClick, Raise_RClick, Raise_RDblClick,
		///     Raise_XClick, Raise_XDblClick
		LVITEMINDEX lastClickedItem;
		/// \brief <em>Holds the last released button</em>
		///
		/// In \c OnLinkClickNotification we need to know which button has been used to perform the click.
		/// Therefore when a mouse button is released, we store this button.
		///
		/// \remarks The button is identified by its corresponding value in VB's \c MouseButtonConstants
		///          enumeration.
		///
		/// \sa OnLinkClickNotification
		SHORT lastMouseUpButton;

		MouseStatusEx()
		{
			clickCandidates = 0;
			enteredControl = FALSE;
			hoveredControl = FALSE;
			lastClickedItem.iItem = -1;
			lastClickedItem.iGroup = 0;
			lastMouseUpButton = 0;
		}

		/// \brief <em>Changes flags to indicate the \c MouseEnter event was just raised</em>
		///
		/// \sa enteredControl, HoverControl, LeaveControl
		void EnterControl(void)
		{
			RemoveAllClickCandidates();
			enteredControl = TRUE;
			lastClickedItem.iItem = -1;
			lastClickedItem.iGroup = 0;
		}

		/// \brief <em>Changes flags to indicate the \c MouseHover event was just raised</em>
		///
		/// \sa enteredControl, hoveredControl, EnterControl, LeaveControl
		void HoverControl(void)
		{
			enteredControl = TRUE;
			hoveredControl = TRUE;
		}

		/// \brief <em>Changes flags to indicate the \c MouseLeave event was just raised</em>
		///
		/// \sa enteredControl, hoveredControl, EnterControl
		void LeaveControl(void)
		{
			enteredControl = FALSE;
			hoveredControl = FALSE;
			lastClickedItem.iItem = -1;
			lastClickedItem.iGroup = 0;
		}

		/// \brief <em>Stores a mouse button as click candidate</em>
		///
		/// param[in] button The mouse button to store.
		///
		/// \sa clickCandidates, IsClickCandidate, RemoveClickCandidate
		void StoreClickCandidate(SHORT button)
		{
			// avoid combined click events
			if(clickCandidates == 0) {
				clickCandidates |= button;
			}
		}

		/// \brief <em>Retrieves whether a mouse button is a click candidate</em>
		///
		/// \param[in] button The mouse button to check.
		///
		/// \return \c TRUE if the button is stored as a click candidate; otherwise \c FALSE.
		///
		/// \attention This member is not reliable with \c deListMouseEvents respectively
		///            \c deEditMouseEvents being set.
		///
		/// \sa clickCandidates, StoreClickCandidate, RemoveClickCandidate
		BOOL IsClickCandidate(SHORT button)
		{
			return (clickCandidates & button);
		}

		/// \brief <em>Removes a mouse button from the list of click candidates</em>
		///
		/// \param[in] button The mouse button to remove.
		///
		/// \sa clickCandidates, RemoveAllClickCandidates, StoreClickCandidate, IsClickCandidate
		void RemoveClickCandidate(SHORT button)
		{
			clickCandidates &= ~button;
		}

		/// \brief <em>Clears the list of click candidates</em>
		///
		/// \sa clickCandidates, RemoveClickCandidate, StoreClickCandidate, IsClickCandidate
		void RemoveAllClickCandidates(void)
		{
			clickCandidates = 0;
		}
	} MouseStatusEx;

	/// \brief <em>Holds the control's mouse status</em>
	///
	/// \sa mouseStatus_Header, mouseStatus_Edit
	MouseStatusEx mouseStatus;
	/// \brief <em>Holds the contained header control's mouse status</em>
	///
	/// \sa mouseStatus, mouseStatus_Edit
	MouseStatus	mouseStatus_Header;
	/// \brief <em>Holds the contained edit control's mouse status</em>
	///
	/// \sa mouseStatus, mouseStatus_Header
	MouseStatus	mouseStatus_Edit;

	/// \brief <em>Holds data and flags related to the \c CaretChanged event</em>
	///
	/// \sa Raise_CaretChanged
	struct CaretChangedStatus
	{
		/// \brief <em>The current caret item</em>
		LVITEMINDEX newCaretItem;
		/// \brief <em>The previous caret item</em>
		LVITEMINDEX previousCaretItem;

		CaretChangedStatus()
		{
			newCaretItem.iItem = -1;
			newCaretItem.iGroup = 0;
			previousCaretItem.iItem = -1;
			previousCaretItem.iGroup = 0;
		}
	} caretChangedStatus;

	//////////////////////////////////////////////////////////////////////
	/// \name Drag'n'Drop
	///
	//@{
	/// \brief <em>The \c CLSID_WICImagingFactory object used to create WIC objects that are required during drag image creation</em>
	///
	/// \sa OnGetDragImage, CreateThumbnail
	CComPtr<IWICImagingFactory> pWICImagingFactory;
	/// \brief <em>Creates a thumbnail of the specified icon in the specified size</em>
	///
	/// \param[in] hIcon The icon to create the thumbnail for.
	/// \param[in] size The thumbnail's size in pixels.
	/// \param[in,out] pBits The thumbnail's DIB bits.
	/// \param[in] doAlphaChannelPostProcessing WIC has problems to handle the alpha channel of the icon
	///            specified by \c hIcon. If this parameter is set to \c TRUE, some post-processing is done
	///            to correct the pixel failures. Otherwise the failures are not corrected.
	///
	/// \return An \c HRESULT error code.
	///
	/// \sa OnGetDragImage, pWICImagingFactory
	HRESULT CreateThumbnail(HICON hIcon, SIZE& size, LPRGBQUAD pBits, BOOL doAlphaChannelPostProcessing);

	/// \brief <em>Holds data and flags related to drag'n'drop</em>
	struct DragDropStatus
	{
		/// \brief <em>The currently dragged column</em>
		int draggedColumn;
		/// \brief <em>The \c IListViewItemContainer implementation of the collection of the dragged items</em>
		IListViewItemContainer* pDraggedItems;
		/// \brief <em>The handle of the imagelist containing the drag image</em>
		///
		/// \sa get_hDragImageList
		HIMAGELIST hDragImageList;
		/// \brief <em>Enables or disables auto-destruction of \c hDragImageList</em>
		///
		/// Controls whether the imagelist defined by \c hDragImageList is auto-destroyed. If set to
		/// \c TRUE, it is destroyed in \c EndDrag; otherwise not.
		///
		/// \sa hDragImageList, EndDrag
		UINT autoDestroyImgLst : 1;
		/// \brief <em>Indicates whether the drag image is visible or hidden</em>
		///
		/// If this value is 0, the drag image is visible; otherwise not.
		///
		/// \sa get_hDragImageList, get_ShowDragImage, put_ShowDragImage, ShowDragImage, HideDragImage,
		///     IsDragImageVisible
		int dragImageIsHidden;
		/// \brief <em>The index of the last drop target</em>
		LVITEMINDEX lastDropTarget;
		/// \brief <em>If \c TRUE, the drag image will move within the header control along the x-axis only</em>
		UINT restrictedDragImage : 1;

		//////////////////////////////////////////////////////////////////////
		/// \name OLE Drag'n'Drop
		///
		//@{
		/// \brief <em>The currently dragged data</em>
		CComPtr<IOLEDataObject> pActiveDataObject;
		/// \brief <em>The currently dragged data for the case that the we're the drag source</em>
		CComPtr<IDataObject> pSourceDataObject;
		/// \brief <em>Holds the mouse cursors last position (in screen coordinates)</em>
		POINTL lastMousePosition;
		/// \brief <em>The \c IDropTargetHelper object used for drag image support</em>
		///
		/// \sa put_SupportOLEDragImages,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms646238.aspx">IDropTargetHelper</a>
		IDropTargetHelper* pDropTargetHelper;
		/// \brief <em>Holds the mouse button (as \c MK_* constant) that the drag'n'drop operation is performed with</em>
		DWORD draggingMouseButton;
		/// \brief <em>If \c TRUE, the current OLE drag'n'drop operation affects the header control</em>
		UINT isOverHeader : 1;
		/// \brief <em>If \c TRUE, the source of the current OLE drag'n'drop operation is the header control</em>
		UINT headerIsSource : 1;
		/// \brief <em>If \c TRUE, we'll hide and re-show the drag image in \c IDropTarget::DragEnter so that the item count label is displayed</em>
		///
		/// \sa DragEnter, OLEDrag
		UINT useItemCountLabelHack : 1;
		/// \brief <em>Holds the \c IDataObject to pass to \c IDropTargetHelper::Drop in \c FinishOLEDragDrop</em>
		///
		/// \sa FinishOLEDragDrop, Drop,
		///     <a href="https://msdn.microsoft.com/en-us/library/ms688421.aspx">IDataObject</a>,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb762027.aspx">IDropTargetHelper::Drop</a>
		IDataObject* drop_pDataObject;
		/// \brief <em>Holds the mouse position to pass to \c IDropTargetHelper::Drop in \c FinishOLEDragDrop</em>
		///
		/// \sa FinishOLEDragDrop, Drop,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb762027.aspx">IDropTargetHelper::Drop</a>
		POINT drop_mousePosition;
		/// \brief <em>Holds the drop effect to pass to \c IDropTargetHelper::Drop in \c FinishOLEDragDrop</em>
		///
		/// \sa FinishOLEDragDrop, Drop,
		///     <a href="https://msdn.microsoft.com/en-us/library/bb762027.aspx">IDropTargetHelper::Drop</a>
		DWORD drop_effect;
		//@}
		//////////////////////////////////////////////////////////////////////

		/// \brief <em>Holds data and flags related to auto-scrolling</em>
		///
		/// \sa AutoScroll
		struct AutoScrolling
		{
			/// \brief <em>Holds the current speed multiplier used for horizontal auto-scrolling</em>
			LONG currentHScrollVelocity;
			/// \brief <em>Holds the current speed multiplier used for vertical auto-scrolling</em>
			LONG currentVScrollVelocity;
			/// \brief <em>Holds the current interval of the auto-scroll timer</em>
			LONG currentTimerInterval;
			/// \brief <em>Holds the last point of time at which the control was auto-scrolled downwards</em>
			DWORD lastScroll_Down;
			/// \brief <em>Holds the last point of time at which the control was auto-scrolled to the left</em>
			DWORD lastScroll_Left;
			/// \brief <em>Holds the last point of time at which the control was auto-scrolled to the right</em>
			DWORD lastScroll_Right;
			/// \brief <em>Holds the last point of time at which the control was auto-scrolled upwardly</em>
			DWORD lastScroll_Up;

			AutoScrolling()
			{
				Reset();
			}

			/// \brief <em>Resets all member variables to their defaults</em>
			void Reset(void)
			{
				currentHScrollVelocity = 0;
				currentVScrollVelocity = 0;
				currentTimerInterval = 0;
				lastScroll_Down = 0;
				lastScroll_Left = 0;
				lastScroll_Right = 0;
				lastScroll_Up = 0;
			}
		} autoScrolling;

		DragDropStatus()
		{
			pActiveDataObject = NULL;
			pSourceDataObject = NULL;
			pDropTargetHelper = NULL;
			draggingMouseButton = 0;
			isOverHeader = FALSE;
			headerIsSource = FALSE;
			useItemCountLabelHack = FALSE;
			drop_pDataObject = NULL;

			draggedColumn = -1;
			pDraggedItems = NULL;
			hDragImageList = NULL;
			autoDestroyImgLst = FALSE;
			dragImageIsHidden = 1;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
		}

		~DragDropStatus()
		{
			if(pDropTargetHelper) {
				pDropTargetHelper->Release();
			}
			ATLASSERT(!pDraggedItems);
		}

		/// \brief <em>Resets all member variables to their defaults</em>
		void Reset(void)
		{
			draggedColumn = -1;
			if(this->pDraggedItems) {
				this->pDraggedItems->Release();
				this->pDraggedItems = NULL;
			}
			if((hDragImageList != NULL) && autoDestroyImgLst) {
				ImageList_Destroy(hDragImageList);
			}
			hDragImageList = NULL;
			autoDestroyImgLst = FALSE;
			dragImageIsHidden = 1;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;

			if(this->pActiveDataObject) {
				this->pActiveDataObject = NULL;
			}
			if(this->pSourceDataObject) {
				this->pSourceDataObject = NULL;
			}
			draggingMouseButton = 0;
			isOverHeader = FALSE;
			headerIsSource = FALSE;
			useItemCountLabelHack = FALSE;
			drop_pDataObject = NULL;
		}

		/// \brief <em>Decrements the \c dragImageIsHidden flag</em>
		///
		/// \param[in] commonDragDropOnly If \c TRUE, the method does nothing if we're within an OLE
		///            drag'n'drop operation.
		///
		/// \sa dragImageIsHidden, HideDragImage, IsDragImageVisible
		void ShowDragImage(BOOL commonDragDropOnly)
		{
			if(hDragImageList) {
				--dragImageIsHidden;
				if(dragImageIsHidden == 0) {
					ImageList_DragShowNolock(TRUE);
				}
			} else if(pDropTargetHelper && !commonDragDropOnly) {
				--dragImageIsHidden;
				if(dragImageIsHidden == 0) {
					pDropTargetHelper->Show(TRUE);
				}
			}
		}

		/// \brief <em>Increments the \c dragImageIsHidden flag</em>
		///
		/// \param[in] commonDragDropOnly If \c TRUE, the method does nothing if we're within an OLE
		///            drag'n'drop operation.
		///
		/// \sa dragImageIsHidden, ShowDragImage, IsDragImageVisible
		void HideDragImage(BOOL commonDragDropOnly)
		{
			if(hDragImageList) {
				++dragImageIsHidden;
				if(dragImageIsHidden == 1) {
					ImageList_DragShowNolock(FALSE);
				}
			} else if(pDropTargetHelper && !commonDragDropOnly) {
				++dragImageIsHidden;
				if(dragImageIsHidden == 1) {
					pDropTargetHelper->Show(FALSE);
				}
			}
		}

		/// \brief <em>Retrieves whether we're currently displaying a drag image</em>
		///
		/// \return \c TRUE, if we're displaying a drag image; otherwise \c FALSE.
		///
		/// \sa dragImageIsHidden, ShowDragImage, HideDragImage
		BOOL IsDragImageVisible(void)
		{
			return (dragImageIsHidden == 0);
		}

		/// \brief <em>Performs any tasks that must be done after a drag'n'drop operation started</em>
		///
		/// \param[in] hWndLvw The listview window, that the method will work on to calculate the position
		///            of the drag image's hotspot.
		/// \param[in] pDraggedItems The \c IListViewItemContainer implementation of the collection of
		///            the dragged items.
		/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
		///            visualize the drag'n'drop operation. If -1, the method will create the drag image
		///            itself; if \c NULL, no drag image will be displayed.
		/// \param[in,out] pXHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to
		///                \c NULL, this parameter is ignored. If the \c hDragImageList parameter is set to
		///                -1, this parameter is set to the hotspot calculated by the method.
		/// \param[in,out] pYHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to
		///                \c NULL, this parameter is ignored. If the \c hDragImageList parameter is set to
		///                -1, this parameter is set to the hotspot calculated by the method.
		///
		/// \return An \c HRESULT error code.
		///
		/// \sa EndDrag
		HRESULT BeginDrag(HWND hWndLvw, IListViewItemContainer* pDraggedItems, HIMAGELIST hDragImageList, PINT pXHotSpot, PINT pYHotSpot)
		{
			ATLASSUME(pDraggedItems);
			if(!pDraggedItems) {
				return E_INVALIDARG;
			}

			UINT b = FALSE;
			if(hDragImageList == static_cast<HIMAGELIST>(LongToHandle(-1))) {
				OLE_HANDLE h = NULL;
				OLE_XPOS_PIXELS xUpperLeft = 0;
				OLE_YPOS_PIXELS yUpperLeft = 0;
				if(FAILED(pDraggedItems->CreateDragImage(&xUpperLeft, &yUpperLeft, &h))) {
					return E_FAIL;
				}
				hDragImageList = static_cast<HIMAGELIST>(LongToHandle(h));
				b = TRUE;

				DWORD position = GetMessagePos();
				POINT mousePosition = {GET_X_LPARAM(position), GET_Y_LPARAM(position)};
				::ScreenToClient(hWndLvw, &mousePosition);
				if(CWindow(hWndLvw).GetExStyle() & WS_EX_LAYOUTRTL) {
					SIZE dragImageSize = {0};
					ImageList_GetIconSize(hDragImageList, reinterpret_cast<PINT>(&dragImageSize.cx), reinterpret_cast<PINT>(&dragImageSize.cy));
					*pXHotSpot = xUpperLeft + dragImageSize.cx - mousePosition.x;
				} else {
					*pXHotSpot = mousePosition.x - xUpperLeft;
				}
				*pYHotSpot = mousePosition.y - yUpperLeft;
			}

			if(this->hDragImageList && this->autoDestroyImgLst) {
				ImageList_Destroy(this->hDragImageList);
			}

			this->autoDestroyImgLst = b;
			this->hDragImageList = hDragImageList;
			if(this->pDraggedItems) {
				this->pDraggedItems->Release();
				this->pDraggedItems = NULL;
			}
			pDraggedItems->Clone(&this->pDraggedItems);
			ATLASSUME(this->pDraggedItems);
			this->lastDropTarget.iItem = -1;
			this->lastDropTarget.iGroup = 0;

			dragImageIsHidden = 1;
			autoScrolling.Reset();
			return S_OK;
		}

		/// \brief <em>Performs any tasks that must be done after a drag'n'drop operation ended</em>
		///
		/// \sa BeginDrag
		void EndDrag(void)
		{
			if(pDraggedItems) {
				pDraggedItems->Release();
				pDraggedItems = NULL;
			}
			if(autoDestroyImgLst && hDragImageList) {
				ImageList_Destroy(hDragImageList);
			}
			hDragImageList = NULL;
			dragImageIsHidden = 1;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
			autoScrolling.Reset();
		}

		/// \brief <em>Retrieves whether we're in drag'n'drop mode</em>
		///
		/// \return \c TRUE if we're in drag'n'drop mode; otherwise \c FALSE.
		///
		/// \sa BeginDrag, EndDrag
		BOOL IsDragging(void)
		{
			return (pDraggedItems != NULL);
		}

		/// \brief <em>Performs any tasks that must be done after a drag'n'drop operation started</em>
		///
		/// \param[in] hWndHeader The header control, that the method will work on to calculate the position
		///            of the drag image's hotspot.
		/// \param[in] pDraggedColumn The dragged column.
		/// \param[in] hDragImageList The imagelist containing the drag image that shall be used to
		///            visualize the drag'n'drop operation. If -1, the method will create the drag image
		///            itself; if \c NULL, no drag image will be displayed.
		/// \param[in,out] pXHotSpot The x-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to
		///                \c NULL, this parameter is ignored. If the \c hDragImageList parameter is set to
		///                -1, this parameter is set to the hotspot calculated by the method.
		/// \param[in,out] pYHotSpot The y-coordinate (in pixels) of the drag image's hotspot relative to the
		///                drag image's upper-left corner. If the \c hDragImageList parameter is set to
		///                \c NULL, this parameter is ignored. If the \c hDragImageList parameter is set to
		///                -1, this parameter is set to the hotspot calculated by the method.
		///
		/// \return An \c HRESULT error code.
		///
		/// \sa HeaderEndDrag, BeginDrag
		HRESULT HeaderBeginDrag(HWND hWndHeader, IListViewColumn* pDraggedColumn, HIMAGELIST hDragImageList, PINT pXHotSpot, PINT pYHotSpot)
		{
			ATLASSUME(pDraggedColumn);
			if(!pDraggedColumn) {
				return E_INVALIDARG;
			}

			UINT b = FALSE;
			if(hDragImageList == static_cast<HIMAGELIST>(LongToHandle(-1))) {
				OLE_HANDLE h = NULL;
				OLE_XPOS_PIXELS xUpperLeft = 0;
				OLE_YPOS_PIXELS yUpperLeft = 0;
				if(FAILED(pDraggedColumn->CreateDragImage(&xUpperLeft, &yUpperLeft, &h))) {
					return E_FAIL;
				}
				hDragImageList = static_cast<HIMAGELIST>(LongToHandle(h));
				b = TRUE;

				DWORD position = GetMessagePos();
				POINT mousePosition = {GET_X_LPARAM(position), GET_Y_LPARAM(position)};
				::ScreenToClient(hWndHeader, &mousePosition);
				if(CWindow(hWndHeader).GetExStyle() & WS_EX_LAYOUTRTL) {
					SIZE dragImageSize = {0};
					ImageList_GetIconSize(hDragImageList, reinterpret_cast<PINT>(&dragImageSize.cx), reinterpret_cast<PINT>(&dragImageSize.cy));
					*pXHotSpot = xUpperLeft + dragImageSize.cx - mousePosition.x;
				} else {
					*pXHotSpot = mousePosition.x - xUpperLeft;
				}
				*pYHotSpot = mousePosition.y - yUpperLeft;
			}

			if(this->hDragImageList && this->autoDestroyImgLst) {
				ImageList_Destroy(this->hDragImageList);
			}

			this->autoDestroyImgLst = b;
			this->hDragImageList = hDragImageList;
			LONG l = -1;
			pDraggedColumn->get_Index(&l);
			this->draggedColumn = l;

			dragImageIsHidden = 1;
			autoScrolling.Reset();
			return S_OK;
		}

		/// \brief <em>Performs any tasks that must be done after a drag'n'drop operation ended</em>
		///
		/// \sa HeaderBeginDrag, EndDrag
		void HeaderEndDrag(void)
		{
			this->draggedColumn = -1;
			if(autoDestroyImgLst && hDragImageList) {
				ImageList_Destroy(hDragImageList);
			}
			hDragImageList = NULL;
			dragImageIsHidden = 1;
			autoScrolling.Reset();
		}

		/// \brief <em>Retrieves whether we're in column drag'n'drop mode</em>
		///
		/// \return \c TRUE if we're in column drag'n'drop mode; otherwise \c FALSE.
		///
		/// \sa HeaderBeginDrag, HeaderEndDrag
		BOOL HeaderIsDragging(void)
		{
			return (draggedColumn != -1);
		}

		/// \brief <em>Performs any tasks that must be done if \c IDropTarget::DragEnter is called</em>
		///
		/// \return An \c HRESULT error code.
		///
		/// \sa HeaderOLEDragLeaveOrDrop, OLEDragEnter
		HRESULT HeaderOLEDragEnter(void)
		{
			isOverHeader = TRUE;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
			autoScrolling.Reset();
			return S_OK;
		}

		/// \brief <em>Performs any tasks that must be done if \c IDropTarget::DragLeave or \c IDropTarget::Drop is called</em>
		///
		/// \sa HeaderOLEDragEnter, OLEDragLeaveOrDrop
		void HeaderOLEDragLeaveOrDrop(void)
		{
			isOverHeader = FALSE;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
			autoScrolling.Reset();
		}

		/// \brief <em>Performs any tasks that must be done if \c IDropTarget::DragEnter is called</em>
		///
		/// \return An \c HRESULT error code.
		///
		/// \sa OLEDragLeaveOrDrop, HeaderOLEDragEnter
		HRESULT OLEDragEnter(void)
		{
			isOverHeader = FALSE;
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
			autoScrolling.Reset();
			return S_OK;
		}

		/// \brief <em>Performs any tasks that must be done if \c IDropTarget::DragLeave or \c IDropTarget::Drop is called</em>
		///
		/// \sa OLEDragEnter, HeaderOLEDragLeaveOrDrop
		void OLEDragLeaveOrDrop(void)
		{
			lastDropTarget.iItem = -1;
			lastDropTarget.iGroup = 0;
			autoScrolling.Reset();
		}
	} dragDropStatus;

	/// \brief <em>Holds data and flags related to label-editing</em>
	struct LabelEditStatus
	{
		/// \brief <em>The index of the item that currently is edited</em>
		LVITEMINDEX editedItem;
		/// \brief <em>The edited item's text that it had before label-editing started</em>
		BSTR previousText;
		/// \brief <em>If \c FALSE, the control rejects the new item text and re-enters label-edit mode immediately</em>
		///
		/// \sa OnEndLabelEditNotification, Raise_DestroyedEditControlWindow
		BOOL acceptText;
		#ifdef INCLUDESHELLBROWSERINTERFACE
			/// \brief <em>A text with which the label-edit control should be initialized</em>
			TCHAR pTextToSetOnBegin[MAX_ITEMTEXTLENGTH + 1];
		#endif

		LabelEditStatus()
		{
			Reset();
			#ifdef INCLUDESHELLBROWSERINTERFACE
				pTextToSetOnBegin[0] = TEXT('\0');
			#endif
		}

		/// \brief <em>Resets all members to their defaults</em>
		void Reset(void)
		{
			editedItem.iItem = -1;
			editedItem.iGroup = 0;
			previousText = NULL;
			acceptText = TRUE;
		}
	} labelEditStatus;

	/// \brief <em>Holds IDs and intervals of timers that we use</em>
	///
	/// \sa OnTimer
	static struct Timers
	{
		/// \brief <em>The ID of the timer that is used to redraw the control window after recreation</em>
		static const UINT_PTR ID_REDRAW = 12;
		/// \brief <em>The ID of the timer that is used to auto-scroll the control window during drag'n'drop</em>
		static const UINT_PTR ID_DRAGSCROLL = 13;
		/// \brief <em>The ID of the timer that is used to raise the \c CaretChanged event</em>
		///
		/// \sa Raise_CaretChanged
		static const UINT_PTR ID_CARETCHANGED = 16;
		/// \brief <em>The ID of the timer that is used to configure the control window after recreation</em>
		static const UINT_PTR ID_CREATED = 17;

		/// \brief <em>The interval of the timer that is used to redraw the control window after recreation</em>
		static const UINT INT_REDRAW = 10;
		/// \brief <em>The interval of the timer that is used to raise the \c CaretChanged event</em>
		///
		/// \sa Raise_CaretChanged
		static const UINT INT_CARETCHANGED = 10;
		/// \brief <em>The interval of the timer that is used to configure the control window after recreation</em>
		static const UINT INT_CREATED = 10;
	} timers;

	/// \brief <em>The handle of the control's built in state imagelist</em>
	HIMAGELIST hBuiltInStateImageList;
	/// \brief <em>The handle of the header control's built in state imagelist</em>
	HIMAGELIST hBuiltInHeaderStateImageList;
	/// \brief <em>The handle of the brush that the contained edit control's background is drawn with</em>
	HBRUSH hEditBackColorBrush;

	//////////////////////////////////////////////////////////////////////
	/// \name Version information
	///
	//@{
	/// \brief <em>Retrieves whether we're using version 6.0 of comctl32.dll</em>
	///
	/// \return \c TRUE if we're using comctl32.dll version 6.0; otherwise \c FALSE.
	///
	/// \sa IsComctl32Version610OrNewer
	BOOL IsComctl32Version600(void);
	/// \brief <em>Retrieves whether we're using at least version 6.10 of comctl32.dll</em>
	///
	/// \return \c TRUE if we're using comctl32.dll version 6.10 or higher; otherwise \c FALSE.
	///
	/// \sa IsComctl32Version600
	BOOL IsComctl32Version610OrNewer(void);
	//@}
	//////////////////////////////////////////////////////////////////////

	#ifdef INCLUDESHELLBROWSERINTERFACE
		//////////////////////////////////////////////////////////////////////
		/// \name ShellBrowser interface
		///
		//@{
		/// \brief <em>Holds any data that is specific to the \c ShellListView interface</em>
		struct ShellBrowserInterface
		{
			/// \brief <em>Holds the \c IMessageListener implementation of the attached \c ShellListView</em>
			IMessageListener* pMessageListener;
			/// \brief <em>Holds the \c IInternalMessageListener implementation of the attached \c ShellListView</em>
			IInternalMessageListener* pInternalMessageListener;
			/// \brief <em>Holds the build number of the attached \c ShellListView control</em>
			UINT shellBrowserBuildNumber;

			ShellBrowserInterface()
			{
				pMessageListener = NULL;
				pInternalMessageListener = NULL;
				shellBrowserBuildNumber = 0;
			}
		} shellBrowserInterface;
		//@}
		//////////////////////////////////////////////////////////////////////
	#endif

private:
	/// \brief <em>Holds the \c LPARAM parameter of the control's last \c WM_KEYDOWN message</em>
	///
	/// \attention This member is not reliable with \c deListKeyboardEvents being set.
	///
	/// \sa OnKeyDown, Raise_IncrementalSearchStringChanging
	LPARAM lastKeyDownLParam;
	/// \brief <em>Holds the settings of the listview column that is being inserted or removed</em>
	///
	/// With comctl32.dll version 6.10 or higher, \c VirtualListViewColumn requires data that is stored in
	/// the column's \c LVCOLUMN structure, but not in its \c HDITEM structure. So we buffer the \c LVCOLUMN
	/// structure and then pass both structures together to the \c VirtualListViewColumn object.
	///
	/// \attention The \c pszText member isn't really buffered. The address is copied, but the string itself
	///            isn't.
	///
	/// \sa OnInsertColumn, OnHeaderInsertItem, VirtualListViewColumn,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms670563.aspx">LVCOLUMN</a>,
	///     <a href="https://msdn.microsoft.com/en-us/library/ms671802.aspx">HDITEM</a>
	LVCOLUMN bufferedColumnData;
};     // ExplorerListView

OBJECT_ENTRY_AUTO(__uuidof(ExplorerListView), ExplorerListView)